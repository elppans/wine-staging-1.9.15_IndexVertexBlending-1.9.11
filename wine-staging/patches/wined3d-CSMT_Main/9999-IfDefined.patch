From: Wine Staging Team <webmaster@fds-team.de>
Subject: Autogenerated #ifdef patch for wined3d-CSMT_Main.

Based on patches by:
    Henri Verbeet <hverbeet@codeweavers.com>
    Matteo Bruni <mbruni@codeweavers.com>
    Sebastian Lackner <sebastian@fds-team.de>
    Stefan Dösinger <stefan@codeweavers.com>
    Stefan Dösinger <stefandoesinger@gmx.at>

diff --git a/dlls/d3d9/tests/visual.c b/dlls/d3d9/tests/visual.c
--- a/dlls/d3d9/tests/visual.c
+++ b/dlls/d3d9/tests/visual.c
@@ -1336,7 +1336,11 @@ static void color_fill_test(void)
          * result on Wine.
          * {D3DFMT_YUY2,     "D3DFMT_YUY2",     BLOCKS,                              0},
          * {D3DFMT_UYVY,     "D3DFMT_UYVY",     BLOCKS,                              0}, */
+#if !defined(STAGING_CSMT)
         {D3DFMT_DXT1,     "D3DFMT_DXT1",     BLOCKS | TODO_FILL_RETURN,           0},
+#else  /* STAGING_CSMT */
+        {D3DFMT_DXT1,     "D3DFMT_DXT1",     BLOCKS,                              0},
+#endif /* STAGING_CSMT */
         /* Vendor-specific formats like ATI2N are a non-issue here since they're not
          * supported as offscreen plain surfaces and do not support D3DUSAGE_RENDERTARGET
          * when created as texture. */
diff --git a/dlls/wined3d/arb_program_shader.c b/dlls/wined3d/arb_program_shader.c
--- a/dlls/wined3d/arb_program_shader.c
+++ b/dlls/wined3d/arb_program_shader.c
@@ -704,7 +704,11 @@ static void shader_arb_load_constants_internal(struct shader_arb_priv *priv,
     {
         const struct wined3d_shader *pshader = state->shader[WINED3D_SHADER_TYPE_PIXEL];
         const struct arb_ps_compiled_shader *gl_shader = priv->compiled_fprog;
+#if !defined(STAGING_CSMT)
         UINT rt_height = state->fb->render_targets[0]->height;
+#else  /* STAGING_CSMT */
+        UINT rt_height = state->fb.render_targets[0]->height;
+#endif /* STAGING_CSMT */
 
         /* Load DirectX 9 float constants for pixel shader */
         priv->highest_dirty_ps_const = shader_arb_load_constants_f(pshader, gl_info, GL_FRAGMENT_PROGRAM_ARB,
@@ -729,6 +733,14 @@ static void shader_arb_update_float_vertex_constants(struct wined3d_device *devi
 {
     struct wined3d_context *context = context_get_current();
     struct shader_arb_priv *priv = device->shader_priv;
+#if defined(STAGING_CSMT)
+    unsigned int i;
+
+    for (i = 0; i < device->context_count; ++i)
+    {
+        device->contexts[i]->constant_update_mask |= WINED3D_SHADER_CONST_VS_F;
+    }
+#endif /* STAGING_CSMT */
 
     /* We don't want shader constant dirtification to be an O(contexts), so just dirtify the active
      * context. On a context switch the old context will be fully dirtified */
@@ -742,6 +754,14 @@ static void shader_arb_update_float_pixel_constants(struct wined3d_device *devic
 {
     struct wined3d_context *context = context_get_current();
     struct shader_arb_priv *priv = device->shader_priv;
+#if defined(STAGING_CSMT)
+    unsigned int i;
+
+    for (i = 0; i < device->context_count; ++i)
+    {
+        device->contexts[i]->constant_update_mask |= WINED3D_SHADER_CONST_PS_F;
+    }
+#endif /* STAGING_CSMT */
 
     /* We don't want shader constant dirtification to be an O(contexts), so just dirtify the active
      * context. On a context switch the old context will be fully dirtified */
@@ -4720,7 +4740,11 @@ static void shader_arb_select(void *shader_priv, struct wined3d_context *context
         }
         else
         {
+#if !defined(STAGING_CSMT)
             UINT rt_height = state->fb->render_targets[0]->height;
+#else  /* STAGING_CSMT */
+            UINT rt_height = state->fb.render_targets[0]->height;
+#endif /* STAGING_CSMT */
             shader_arb_ps_local_constants(compiled, context, state, rt_height);
         }
 
@@ -8017,8 +8041,16 @@ static void arbfp_blit_surface(struct wined3d_device *device, enum wined3d_blit_
     /* Leave the opengl state valid for blitting */
     arbfp_blit_unset(context->gl_info);
 
+#if !defined(STAGING_CSMT)
     if (wined3d_settings.strict_draw_ordering
             || (dst_texture->swapchain && (dst_texture->swapchain->front_buffer == dst_texture)))
+#else  /* STAGING_CSMT */
+    if (wined3d_settings.cs_multithreaded)
+        context->gl_info->gl_ops.gl.p_glFinish();
+    else if (wined3d_settings.strict_draw_ordering
+            || (dst_texture->swapchain
+            && (dst_texture->swapchain->front_buffer == dst_texture)))
+#endif /* STAGING_CSMT */
         context->gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
     context_release(context);
diff --git a/dlls/wined3d/buffer.c b/dlls/wined3d/buffer.c
--- a/dlls/wined3d/buffer.c
+++ b/dlls/wined3d/buffer.c
@@ -32,7 +32,11 @@ WINE_DEFAULT_DEBUG_CHANNEL(d3d);
 #define WINED3D_BUFFER_HASDESC      0x01    /* A vertex description has been found. */
 #define WINED3D_BUFFER_USE_BO       0x02    /* Use a buffer object for this buffer. */
 #define WINED3D_BUFFER_DOUBLEBUFFER 0x04    /* Keep both a buffer object and a system memory copy for this buffer. */
+#if !defined(STAGING_CSMT)
 #define WINED3D_BUFFER_DISCARD      0x08    /* A DISCARD lock has occurred since the last preload. */
+#else  /* STAGING_CSMT */
+#define WINED3D_BUFFER_DISCARD      0x08    /* The next PreLoad may discard the buffer contents. */
+#endif /* STAGING_CSMT */
 #define WINED3D_BUFFER_SYNC         0x10    /* There has been at least one synchronized map since the last preload. */
 #define WINED3D_BUFFER_APPLESYNC    0x20    /* Using sync as in GL_APPLE_flush_buffer_range. */
 
@@ -41,7 +45,11 @@ WINE_DEFAULT_DEBUG_CHANNEL(d3d);
 #define VB_MAXFULLCONVERSIONS 5       /* Number of full conversions before we stop converting */
 #define VB_RESETFULLCONVS     20      /* Reset full conversion counts after that number of draws */
 
+#if !defined(STAGING_CSMT)
 static void buffer_invalidate_bo_range(struct wined3d_buffer *buffer, unsigned int offset, unsigned int size)
+#else  /* STAGING_CSMT */
+void buffer_invalidate_bo_range(struct wined3d_buffer *buffer, unsigned int offset, unsigned int size)
+#endif /* STAGING_CSMT */
 {
     if (!offset && (!size || size == buffer->resource.size))
         goto invalidate_all;
@@ -122,7 +130,11 @@ static void delete_gl_buffer(struct wined3d_buffer *This, const struct wined3d_g
 }
 
 /* Context activation is done by the caller. */
+#if !defined(STAGING_CSMT)
 static void buffer_create_buffer_object(struct wined3d_buffer *This, struct wined3d_context *context)
+#else  /* STAGING_CSMT */
+void buffer_create_buffer_object(struct wined3d_buffer *This, struct wined3d_context *context)
+#endif /* STAGING_CSMT */
 {
     GLenum gl_usage = GL_STATIC_DRAW_ARB;
     GLenum error;
@@ -194,7 +206,14 @@ static void buffer_create_buffer_object(struct wined3d_buffer *This, struct wine
     if (This->flags & WINED3D_BUFFER_DOUBLEBUFFER)
         buffer_invalidate_bo_range(This, 0, 0);
     else
+#if !defined(STAGING_CSMT)
         wined3d_resource_free_sysmem(&This->resource);
+#else  /* STAGING_CSMT */
+    {
+        wined3d_resource_free_sysmem(&This->resource);
+        This->resource.map_heap_memory = NULL;
+    }
+#endif /* STAGING_CSMT */
 
     return;
 
@@ -461,7 +480,12 @@ void buffer_get_memory(struct wined3d_buffer *buffer, struct wined3d_context *co
     data->buffer_object = buffer->buffer_object;
     if (!buffer->buffer_object)
     {
+#if !defined(STAGING_CSMT)
         if ((buffer->flags & WINED3D_BUFFER_USE_BO) && !buffer->resource.map_count)
+#else  /* STAGING_CSMT */
+        if ((!buffer->resource.map_count || buffer->flags & WINED3D_BUFFER_DOUBLEBUFFER)
+                && buffer->flags & WINED3D_BUFFER_USE_BO)
+#endif /* STAGING_CSMT */
         {
             buffer_create_buffer_object(buffer, context);
             if (buffer->buffer_object)
@@ -499,6 +523,9 @@ BYTE *buffer_get_sysmem(struct wined3d_buffer *buffer, struct wined3d_context *c
 
     if (!wined3d_resource_allocate_sysmem(&buffer->resource))
         ERR("Failed to allocate system memory.\n");
+#if defined(STAGING_CSMT)
+    buffer->resource.heap_memory = buffer->resource.map_heap_memory;
+#endif /* STAGING_CSMT */
 
     buffer_bind(buffer, context);
     GL_EXTCALL(glGetBufferSubData(buffer->buffer_type_hint, 0, buffer->resource.size, buffer->resource.heap_memory));
@@ -672,13 +699,18 @@ drop_query:
 /* The caller provides a GL context */
 static void buffer_direct_upload(struct wined3d_buffer *This, const struct wined3d_gl_info *gl_info, DWORD flags)
 {
+#if !defined(STAGING_CSMT)
     BYTE *map;
     UINT start, len;
+#else  /* STAGING_CSMT */
+    UINT start = 0, len = 0;
+#endif /* STAGING_CSMT */
 
     /* This potentially invalidates the element array buffer binding, but the
      * caller always takes care of this. */
     GL_EXTCALL(glBindBuffer(This->buffer_type_hint, This->buffer_object));
     checkGLcall("glBindBuffer");
+#if !defined(STAGING_CSMT)
     if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
     {
         GLbitfield mapflags;
@@ -709,6 +741,25 @@ static void buffer_direct_upload(struct wined3d_buffer *This, const struct wined
     {
         ERR("Failed to map opengl buffer\n");
         return;
+#else  /* STAGING_CSMT */
+
+    if (flags & WINED3D_BUFFER_DISCARD)
+    {
+        GL_EXTCALL(glBufferData(This->buffer_type_hint, This->resource.size, NULL, GL_STREAM_DRAW));
+        checkGLcall("glBufferData");
+    }
+    else if (flags & WINED3D_BUFFER_SYNC && This->flags & WINED3D_BUFFER_APPLESYNC)
+    {
+        /* OSX doesn't do non-blocking asynchonous glBufferSubData like Linux drivers do, so we want to set
+         * GL_BUFFER_SERIALIZED_MODIFY_APPLE to GL_FALSE. Unfortunately ARB_sync and APPLE_fence are pretty
+         * slow on OSX. Putting the buffer back into synchronized mode for future maps is a lot faster.
+         * (GeForce 650M, Mavericks). The difference between ARB_sync and normal buffer operation is small
+         * in the glMapBuffer codepath without CSMT. */
+        glFinish();
+        GL_EXTCALL(glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_SERIALIZED_MODIFY_APPLE, GL_TRUE));
+        checkGLcall("glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_SERIALIZED_MODIFY_APPLE, GL_TRUE)");
+        This->flags &= ~WINED3D_BUFFER_APPLESYNC;
+#endif /* STAGING_CSMT */
     }
 
     while (This->modified_areas)
@@ -717,6 +768,7 @@ static void buffer_direct_upload(struct wined3d_buffer *This, const struct wined
         start = This->maps[This->modified_areas].offset;
         len = This->maps[This->modified_areas].size;
 
+#if !defined(STAGING_CSMT)
         memcpy(map + start, (BYTE *)This->resource.heap_memory + start, len);
 
         if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
@@ -735,6 +787,14 @@ static void buffer_direct_upload(struct wined3d_buffer *This, const struct wined
 }
 
 void buffer_mark_used(struct wined3d_buffer *buffer)
+#else  /* STAGING_CSMT */
+        GL_EXTCALL(glBufferSubData(This->buffer_type_hint, start, len, (BYTE *)This->resource.heap_memory + start));
+        checkGLcall("glBufferSubData");
+    }
+}
+
+static void buffer_mark_used(struct wined3d_buffer *buffer)
+#endif /* STAGING_CSMT */
 {
     buffer->flags &= ~(WINED3D_BUFFER_SYNC | WINED3D_BUFFER_DISCARD);
 }
@@ -753,12 +813,14 @@ void buffer_internal_preload(struct wined3d_buffer *buffer, struct wined3d_conte
 
     TRACE("buffer %p.\n", buffer);
 
+#if !defined(STAGING_CSMT)
     if (buffer->resource.map_count)
     {
         WARN("Buffer is mapped, skipping preload.\n");
         return;
     }
 
+#endif /* STAGING_CSMT */
     buffer_mark_used(buffer);
 
     if (!buffer->buffer_object)
@@ -934,10 +996,22 @@ void buffer_internal_preload(struct wined3d_buffer *buffer, struct wined3d_conte
 
 void CDECL wined3d_buffer_preload(struct wined3d_buffer *buffer)
 {
+#if !defined(STAGING_CSMT)
     struct wined3d_context *context;
     context = context_acquire(buffer->resource.device, NULL);
     buffer_internal_preload(buffer, context, NULL);
     context_release(context);
+#else  /* STAGING_CSMT */
+    struct wined3d_device *device = buffer->resource.device;
+
+    if (buffer->resource.map_count)
+    {
+        WARN("Buffer is mapped, skipping preload.\n");
+        return;
+    }
+
+    wined3d_cs_emit_buffer_preload(device->cs, buffer);
+#endif /* STAGING_CSMT */
 }
 
 struct wined3d_resource * CDECL wined3d_buffer_get_resource(struct wined3d_buffer *buffer)
@@ -951,9 +1025,34 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
 {
     LONG count;
     BYTE *base;
+#if defined(STAGING_CSMT)
+    struct wined3d_device *device = buffer->resource.device;
+    struct wined3d_context *context;
+#endif /* STAGING_CSMT */
 
     TRACE("buffer %p, offset %u, size %u, data %p, flags %#x.\n", buffer, offset, size, data, flags);
 
+#if defined(STAGING_CSMT)
+    /* FIXME: There is a race condition with the same code in
+     * buffer_internal_preload and buffer_get_memory.
+     *
+     * This deals with a race condition concering buffer creation and buffer maps.
+     * If a VBO is created by the worker thread while the buffer is mapped, outdated
+     * data may be uploaded, and the BO range is not properly invaliated. Keep in
+     * mind that a broken application might draw from a buffer before mapping it.
+     *
+     * Don't try to solve this by going back to always invalidating changed areas.
+     * This won't work if we ever want to support glMapBufferRange mapping with
+     * GL_ARB_buffer_storage in the CS.
+     *
+     * Also keep in mind that UnLoad can destroy the VBO, so simply creating it
+     * on buffer creation won't work either. */
+    if (!buffer->buffer_object && buffer->flags & WINED3D_BUFFER_USE_BO)
+    {
+        wined3d_cs_emit_create_vbo(device->cs, buffer);
+    }
+
+#endif /* STAGING_CSMT */
     flags = wined3d_resource_sanitize_map_flags(&buffer->resource, flags);
     /* Filter redundant WINED3D_MAP_DISCARD maps. The 3DMark2001 multitexture
      * fill rate test seems to depend on this. When we map a buffer with
@@ -961,7 +1060,11 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
      * previous contents of the buffer. The r600g driver only does this when
      * the buffer is currently in use, while the proprietary NVIDIA driver
      * appears to do this unconditionally. */
+#if !defined(STAGING_CSMT)
     if (buffer->flags & WINED3D_BUFFER_DISCARD)
+#else  /* STAGING_CSMT */
+    if (buffer->ignore_discard)
+#endif /* STAGING_CSMT */
         flags &= ~WINED3D_MAP_DISCARD;
     count = ++buffer->resource.map_count;
 
@@ -972,17 +1075,34 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
          * being uploaded in that case. Two such applications are Port Royale
          * and Darkstar One. */
         if (flags & WINED3D_MAP_DISCARD)
+#if !defined(STAGING_CSMT)
             buffer_invalidate_bo_range(buffer, 0, 0);
         else if (!(flags & WINED3D_MAP_READONLY))
             buffer_invalidate_bo_range(buffer, offset, size);
+#else  /* STAGING_CSMT */
+            wined3d_cs_emit_buffer_invalidate_bo_range(device->cs, buffer, 0, 0);
+        else if (!(flags & WINED3D_MAP_READONLY))
+            wined3d_cs_emit_buffer_invalidate_bo_range(device->cs, buffer, offset, size);
+#endif /* STAGING_CSMT */
 
         if (!(buffer->flags & WINED3D_BUFFER_DOUBLEBUFFER))
         {
             if (count == 1)
             {
                 struct wined3d_device *device = buffer->resource.device;
+#if !defined(STAGING_CSMT)
                 struct wined3d_context *context;
                 const struct wined3d_gl_info *gl_info;
+#else  /* STAGING_CSMT */
+                const struct wined3d_gl_info *gl_info;
+
+                if (wined3d_settings.cs_multithreaded)
+                {
+                    FIXME("waiting for cs\n");
+                    wined3d_cs_emit_glfinish(device->cs);
+                    device->cs->ops->finish(device->cs);
+                }
+#endif /* STAGING_CSMT */
 
                 context = context_acquire(device, NULL);
                 gl_info = context->gl_info;
@@ -1028,11 +1148,14 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
                         buffer_get_sysmem(buffer, context);
                     }
                     TRACE("New pointer is %p.\n", buffer->resource.heap_memory);
+#if !defined(STAGING_CSMT)
                     buffer->map_ptr = NULL;
+#endif /* STAGING_CSMT */
                 }
                 context_release(context);
             }
         }
+#if !defined(STAGING_CSMT)
 
         if (flags & WINED3D_MAP_DISCARD)
             buffer->flags |= WINED3D_BUFFER_DISCARD;
@@ -1041,6 +1164,43 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
     }
 
     base = buffer->map_ptr ? buffer->map_ptr : buffer->resource.heap_memory;
+#else  /* STAGING_CSMT */
+        else if(!wined3d_settings.cs_multithreaded)
+        {
+            if (flags & WINED3D_MAP_DISCARD)
+            {
+                buffer->flags |= WINED3D_BUFFER_DISCARD;
+                buffer->ignore_discard = TRUE;
+            }
+            else if (!(flags & WINED3D_MAP_NOOVERWRITE))
+                buffer->flags |= WINED3D_BUFFER_SYNC;
+        }
+    }
+
+    if (wined3d_settings.cs_multithreaded && count == 1)
+    {
+        BOOL swvp = device->create_parms.flags & WINED3DCREATE_SOFTWARE_VERTEXPROCESSING;
+        if (flags & WINED3D_MAP_DISCARD && !swvp)
+        {
+            if (buffer->resource.access_count)
+            {
+                buffer->ignore_discard = TRUE;
+                wined3d_resource_allocate_sysmem(&buffer->resource);
+                wined3d_cs_emit_buffer_swap_mem(device->cs, buffer, buffer->resource.map_heap_memory);
+            }
+        }
+        else if(!(flags & (WINED3D_MAP_NOOVERWRITE | WINED3D_MAP_READONLY)) && !buffer->ignore_discard)
+        {
+            wined3d_resource_wait_idle(&buffer->resource);
+            /* Writing to the (otherwise worker thread controlled)
+             * flags field is OK here since the wait_fence call made
+             * sure the buffer is idle. */
+            buffer->flags |= WINED3D_BUFFER_SYNC;
+        }
+    }
+
+    base = buffer->map_ptr ? buffer->map_ptr : buffer->resource.map_heap_memory;
+#endif /* STAGING_CSMT */
     *data = base + offset;
 
     TRACE("Returning memory at %p (base %p, offset %u).\n", *data, base, offset);
@@ -1103,17 +1263,25 @@ void CDECL wined3d_buffer_unmap(struct wined3d_buffer *buffer)
         }
 
         GL_EXTCALL(glUnmapBuffer(buffer->buffer_type_hint));
+#if !defined(STAGING_CSMT)
         if (wined3d_settings.strict_draw_ordering)
+#else  /* STAGING_CSMT */
+        if (wined3d_settings.cs_multithreaded)
+            gl_info->gl_ops.gl.p_glFinish();
+        else if (wined3d_settings.strict_draw_ordering)
+#endif /* STAGING_CSMT */
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
         context_release(context);
 
         buffer_clear_dirty_areas(buffer);
         buffer->map_ptr = NULL;
     }
+#if !defined(STAGING_CSMT)
     else if (buffer->flags & WINED3D_BUFFER_HASDESC)
     {
         wined3d_buffer_preload(buffer);
     }
+#endif /* STAGING_CSMT */
 }
 
 HRESULT wined3d_buffer_copy(struct wined3d_buffer *dst_buffer, unsigned int dst_offset,
@@ -1305,6 +1473,9 @@ static HRESULT buffer_init(struct wined3d_buffer *buffer, struct wined3d_device
         return hr;
     }
     buffer->buffer_type_hint = bind_hint;
+#if defined(STAGING_CSMT)
+    buffer->ignore_discard = TRUE;
+#endif /* STAGING_CSMT */
 
     TRACE("size %#x, usage %#x, format %s, memory @ %p, iface @ %p.\n", buffer->resource.size, buffer->resource.usage,
             debug_d3dformat(buffer->resource.format->id), buffer->resource.heap_memory, buffer);
@@ -1340,6 +1511,11 @@ static HRESULT buffer_init(struct wined3d_buffer *buffer, struct wined3d_device
         buffer->flags |= WINED3D_BUFFER_USE_BO;
     }
 
+#if defined(STAGING_CSMT)
+    if (wined3d_settings.cs_multithreaded)
+        buffer->flags |= WINED3D_BUFFER_DOUBLEBUFFER;
+
+#endif /* STAGING_CSMT */
     if (!(buffer->maps = HeapAlloc(GetProcessHeap(), 0, sizeof(*buffer->maps))))
     {
         ERR("Out of memory.\n");
@@ -1467,3 +1643,12 @@ HRESULT CDECL wined3d_buffer_create_ib(struct wined3d_device *device, UINT size,
 
     return WINED3D_OK;
 }
+#if defined(STAGING_CSMT)
+
+void buffer_swap_mem(struct wined3d_buffer *buffer, BYTE *mem)
+{
+    wined3d_resource_free_sysmem(&buffer->resource);
+    buffer->resource.heap_memory = mem;
+    buffer->flags |= WINED3D_BUFFER_DISCARD;
+}
+#endif /* STAGING_CSMT */
diff --git a/dlls/wined3d/context.c b/dlls/wined3d/context.c
--- a/dlls/wined3d/context.c
+++ b/dlls/wined3d/context.c
@@ -1699,6 +1699,13 @@ struct wined3d_context *context_create(struct wined3d_swapchain *swapchain,
         goto out;
     }
 
+#if defined(STAGING_CSMT)
+    ret->current_fb.rt_size = gl_info->limits.buffers;
+    if (!(ret->current_fb.render_targets = wined3d_calloc(ret->current_fb.rt_size,
+            sizeof(*ret->current_fb.render_targets))))
+        goto out;
+
+#endif /* STAGING_CSMT */
     /* Initialize the texture unit mapping to a 1:1 mapping */
     for (s = 0; s < MAX_COMBINED_SAMPLERS; ++s)
     {
@@ -2004,6 +2011,9 @@ out:
     if (hdc) wined3d_release_dc(swapchain->win_handle, hdc);
     device->shader_backend->shader_free_context_data(ret);
     device->adapter->fragment_pipe->free_context_data(ret);
+#if defined(STAGING_CSMT)
+    HeapFree(GetProcessHeap(), 0, ret->current_fb.render_targets);
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, ret->free_event_queries);
     HeapFree(GetProcessHeap(), 0, ret->free_occlusion_queries);
     HeapFree(GetProcessHeap(), 0, ret->free_timestamp_queries);
@@ -2040,6 +2050,9 @@ void context_destroy(struct wined3d_device *device, struct wined3d_context *cont
     device->shader_backend->shader_free_context_data(context);
     device->adapter->fragment_pipe->free_context_data(context);
     HeapFree(GetProcessHeap(), 0, context->fbo_key);
+#if defined(STAGING_CSMT)
+    HeapFree(GetProcessHeap(), 0, context->current_fb.render_targets);
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, context->draw_buffers);
     HeapFree(GetProcessHeap(), 0, context->blit_targets);
     device_context_remove(device, context);
@@ -2455,7 +2468,9 @@ static void context_validate_onscreen_formats(struct wined3d_context *context,
 {
     /* Onscreen surfaces are always in a swapchain */
     struct wined3d_swapchain *swapchain = context->current_rt.texture->swapchain;
+#if !defined(STAGING_CSMT)
     struct wined3d_surface *surface;
+#endif /* STAGING_CSMT */
 
     if (context->render_offscreen || !depth_stencil) return;
     if (match_depth_stencil_format(swapchain->ds_format, depth_stencil->format)) return;
@@ -2466,8 +2481,13 @@ static void context_validate_onscreen_formats(struct wined3d_context *context,
     WARN("Depth stencil format is not supported by WGL, rendering the backbuffer in an FBO\n");
 
     /* The currently active context is the necessary context to access the swapchain's onscreen buffers */
+#if !defined(STAGING_CSMT)
     surface = context->current_rt.texture->sub_resources[context->current_rt.sub_resource_idx].u.surface;
     surface_load_location(surface, context, WINED3D_LOCATION_TEXTURE_RGB);
+#else  /* STAGING_CSMT */
+    wined3d_texture_load_location(context->current_rt.texture, context->current_rt.sub_resource_idx,
+            context, WINED3D_LOCATION_TEXTURE_RGB);
+#endif /* STAGING_CSMT */
     swapchain->render_to_fbo = TRUE;
     swapchain_update_draw_bindings(swapchain);
     context_set_render_offscreen(context, TRUE);
@@ -2568,7 +2588,11 @@ static BOOL context_validate_rt_config(UINT rt_count, struct wined3d_rendertarge
 }
 
 /* Context activation is done by the caller. */
+#if !defined(STAGING_CSMT)
 BOOL context_apply_clear_state(struct wined3d_context *context, const struct wined3d_state *state,
+#else  /* STAGING_CSMT */
+BOOL context_apply_clear_state(struct wined3d_context *context,
+#endif /* STAGING_CSMT */
         UINT rt_count, const struct wined3d_fb_state *fb)
 {
     struct wined3d_rendertarget_view **rts = fb->render_targets;
@@ -2577,7 +2601,11 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
     DWORD rt_mask = 0, *cur_mask;
     UINT i;
 
+#if !defined(STAGING_CSMT)
     if (isStateDirty(context, STATE_FRAMEBUFFER) || fb != state->fb
+#else  /* STAGING_CSMT */
+    if (isStateDirty(context, STATE_FRAMEBUFFER) || wined3d_fb_equal(fb, &context->current_fb)
+#endif /* STAGING_CSMT */
             || rt_count != gl_info->limits.buffers)
     {
         if (!context_validate_rt_config(rt_count, rts, dsv))
@@ -2622,6 +2650,10 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
             rt_mask = context_generate_rt_mask_no_fbo(context,
                     rt_count ? wined3d_rendertarget_view_get_surface(rts[0])->container : NULL);
         }
+#if defined(STAGING_CSMT)
+
+        wined3d_fb_copy(&context->current_fb, fb);
+#endif /* STAGING_CSMT */
     }
     else if (wined3d_settings.offscreen_rendering_mode == ORM_FBO
             && (!rt_count || wined3d_resource_is_offscreen(rts[0]->resource)))
@@ -2662,7 +2694,12 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
     gl_info->gl_ops.gl.p_glEnable(GL_SCISSOR_TEST);
     if (rt_count && gl_info->supported[ARB_FRAMEBUFFER_SRGB])
     {
+#if !defined(STAGING_CSMT)
         if (needs_srgb_write(context, state, fb))
+#else  /* STAGING_CSMT */
+        /* FIXME: The way to access the state is ugly. */
+        if (needs_srgb_write(context, &rts[0]->resource->device->cs->state, fb))
+#endif /* STAGING_CSMT */
             gl_info->gl_ops.gl.p_glEnable(GL_FRAMEBUFFER_SRGB);
         else
             gl_info->gl_ops.gl.p_glDisable(GL_FRAMEBUFFER_SRGB);
@@ -2679,7 +2716,11 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
 
 static DWORD find_draw_buffers_mask(const struct wined3d_context *context, const struct wined3d_state *state)
 {
+#if !defined(STAGING_CSMT)
     struct wined3d_rendertarget_view **rts = state->fb->render_targets;
+#else  /* STAGING_CSMT */
+    struct wined3d_rendertarget_view **rts = state->fb.render_targets;
+#endif /* STAGING_CSMT */
     struct wined3d_shader *ps = state->shader[WINED3D_SHADER_TYPE_PIXEL];
     DWORD rt_mask, rt_mask_bits;
     unsigned int i;
@@ -2709,7 +2750,11 @@ static DWORD find_draw_buffers_mask(const struct wined3d_context *context, const
 void context_state_fb(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
     DWORD rt_mask = find_draw_buffers_mask(context, state);
+#if !defined(STAGING_CSMT)
     const struct wined3d_fb_state *fb = state->fb;
+#else  /* STAGING_CSMT */
+    const struct wined3d_fb_state *fb = &state->fb;
+#endif /* STAGING_CSMT */
     DWORD *cur_mask;
 
     if (wined3d_settings.offscreen_rendering_mode == ORM_FBO)
@@ -2740,6 +2785,10 @@ void context_state_fb(struct wined3d_context *context, const struct wined3d_stat
         context_apply_draw_buffers(context, rt_mask);
         *cur_mask = rt_mask;
     }
+#if defined(STAGING_CSMT)
+
+    wined3d_fb_copy(&context->current_fb, &state->fb);
+#endif /* STAGING_CSMT */
 }
 
 static void context_map_stage(struct wined3d_context *context, DWORD stage, DWORD unit)
@@ -3371,7 +3420,11 @@ BOOL context_apply_draw_state(struct wined3d_context *context,
         const struct wined3d_device *device, const struct wined3d_state *state)
 {
     const struct StateEntry *state_table = context->state_table;
+#if !defined(STAGING_CSMT)
     const struct wined3d_fb_state *fb = state->fb;
+#else  /* STAGING_CSMT */
+    const struct wined3d_fb_state *fb = &state->fb;
+#endif /* STAGING_CSMT */
     unsigned int i;
     WORD map;
 
@@ -3404,8 +3457,17 @@ BOOL context_apply_draw_state(struct wined3d_context *context,
         for (i = 0, map = context->stream_info.use_map; map; map >>= 1, ++i)
         {
             if (map & 1)
+#if !defined(STAGING_CSMT)
                 buffer_mark_used(state->streams[context->stream_info.elements[i].stream_idx].buffer);
         }
+#else  /* STAGING_CSMT */
+                buffer_internal_preload(state->streams[context->stream_info.elements[i].stream_idx].buffer,
+                        context, state);
+        }
+        /* PreLoad may kick buffers out of vram. */
+        if (isStateDirty(context, STATE_STREAMSRC))
+            context_update_stream_info(context, state);
+#endif /* STAGING_CSMT */
     }
     if (state->index_buffer)
     {
@@ -3524,6 +3586,11 @@ struct wined3d_context *context_acquire(const struct wined3d_device *device, str
 
     TRACE("device %p, target %p.\n", device, target);
 
+#if defined(STAGING_CSMT)
+    if (wined3d_settings.cs_multithreaded && device->cs->thread_id != GetCurrentThreadId())
+        FIXME("Acquiring a GL context from outside the CS thread.\n");
+
+#endif /* STAGING_CSMT */
     if (current_context && current_context->destroyed)
         current_context = NULL;
 
diff --git a/dlls/wined3d/cs.c b/dlls/wined3d/cs.c
--- a/dlls/wined3d/cs.c
+++ b/dlls/wined3d/cs.c
@@ -22,10 +22,18 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(d3d);
 
+#if !defined(STAGING_CSMT)
 #define WINED3D_INITIAL_CS_SIZE 4096
 
 enum wined3d_cs_op
 {
+#else  /* STAGING_CSMT */
+enum wined3d_cs_op
+{
+    WINED3D_CS_OP_NOP,
+    WINED3D_CS_OP_SKIP,
+    WINED3D_CS_OP_FENCE,
+#endif /* STAGING_CSMT */
     WINED3D_CS_OP_PRESENT,
     WINED3D_CS_OP_CLEAR,
     WINED3D_CS_OP_DRAW,
@@ -53,6 +61,52 @@ enum wined3d_cs_op
     WINED3D_CS_OP_SET_MATERIAL,
     WINED3D_CS_OP_RESET_STATE,
     WINED3D_CS_OP_DESTROY_OBJECT,
+#if defined(STAGING_CSMT)
+    WINED3D_CS_OP_SET_VS_CONSTS_F,
+    WINED3D_CS_OP_SET_VS_CONSTS_B,
+    WINED3D_CS_OP_SET_VS_CONSTS_I,
+    WINED3D_CS_OP_SET_PS_CONSTS_F,
+    WINED3D_CS_OP_SET_PS_CONSTS_B,
+    WINED3D_CS_OP_SET_PS_CONSTS_I,
+    WINED3D_CS_OP_GLFINISH,
+    WINED3D_CS_OP_SET_BASE_VERTEX_INDEX,
+    WINED3D_CS_OP_SET_PRIMITIVE_TYPE,
+    WINED3D_CS_OP_SET_LIGHT,
+    WINED3D_CS_OP_SET_LIGHT_ENABLE,
+    WINED3D_CS_OP_BLT,
+    WINED3D_CS_OP_CLEAR_RTV,
+    WINED3D_CS_OP_TEXTURE_CHANGED,
+    WINED3D_CS_OP_TEXTURE_MAP,
+    WINED3D_CS_OP_TEXTURE_UNMAP,
+    WINED3D_CS_OP_BUFFER_SWAP_MEM,
+    WINED3D_CS_OP_BUFFER_INVALIDATE_RANGE,
+    WINED3D_CS_OP_BUFFER_PRELOAD,
+    WINED3D_CS_OP_QUERY_ISSUE,
+    WINED3D_CS_OP_TEXTURE_PRELOAD,
+    WINED3D_CS_OP_UPDATE_TEXTURE,
+    WINED3D_CS_OP_EVICT_RESOURCE,
+    WINED3D_CS_OP_UPDATE_SUB_RESOURCE,
+    WINED3D_CS_OP_CREATE_VBO,
+    WINED3D_CS_OP_SAMPLER_INIT,
+    WINED3D_CS_OP_GET_DC,
+    WINED3D_CS_OP_RELEASE_DC,
+    WINED3D_CS_OP_CREATE_DUMMY_TEXTURES,
+    WINED3D_CS_OP_CREATE_SWAPCHAIN_CONTEXT,
+    WINED3D_CS_OP_DELETE_GL_CONTEXTS,
+    WINED3D_CS_OP_UPDATE_SWAP_INTERVAL,
+    WINED3D_CS_OP_STOP,
+};
+
+struct wined3d_cs_stop
+{
+    enum wined3d_cs_op opcode;
+};
+
+struct wined3d_cs_fence
+{
+    enum wined3d_cs_op opcode;
+    BOOL *signalled;
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_cs_present
@@ -260,7 +314,284 @@ struct wined3d_cs_destroy_object
     void *object;
 };
 
+#if !defined(STAGING_CSMT)
 static void wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+struct wined3d_cs_set_consts_f
+{
+    enum wined3d_cs_op opcode;
+    unsigned int start_idx;
+    unsigned int count;
+    struct wined3d_vec4 constants[1];
+};
+
+struct wined3d_cs_set_consts_b
+{
+    enum wined3d_cs_op opcode;
+    unsigned int start_idx;
+    unsigned int count;
+    BOOL constants[1];
+};
+
+struct wined3d_cs_set_consts_i
+{
+    enum wined3d_cs_op opcode;
+    unsigned int start_idx;
+    unsigned int count;
+    struct wined3d_ivec4 constants[1];
+};
+
+struct wined3d_cs_finish
+{
+    enum wined3d_cs_op opcode;
+};
+
+struct wined3d_cs_set_base_vertex_index
+{
+    enum wined3d_cs_op opcode;
+    UINT base_vertex_index;
+};
+
+struct wined3d_cs_set_primitive_type
+{
+    enum wined3d_cs_op opcode;
+    GLenum gl_primitive_type;
+};
+
+struct wined3d_cs_set_light
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_light_info light;
+};
+
+struct wined3d_cs_set_light_enable
+{
+    enum wined3d_cs_op opcode;
+    UINT idx;
+    BOOL enable;
+};
+
+struct wined3d_cs_blt
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *dst_surface;
+    RECT dst_rect;
+    struct wined3d_surface *src_surface;
+    RECT src_rect;
+    DWORD flags;
+    struct wined3d_blt_fx fx;
+    enum wined3d_texture_filter_type filter;
+};
+
+struct wined3d_cs_clear_rtv
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_rendertarget_view *view;
+    RECT rect;
+    DWORD flags;
+    struct wined3d_color color;
+    float depth;
+    DWORD stencil;
+    const struct blit_shader *blitter;
+};
+
+struct wined3d_cs_texture_map
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *texture;
+    unsigned int sub_resource_idx;
+    DWORD flags;
+    void **mem;
+};
+
+struct wined3d_cs_texture_unmap
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *texture;
+    unsigned int sub_resource_idx;
+};
+
+struct wined3d_cs_texture_changed
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *texture;
+    unsigned int sub_resource_idx;
+    struct wined3d_gl_bo *swap_buffer;
+    void *swap_heap_memory;
+};
+
+struct wined3d_cs_buffer_swap_mem
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+    BYTE *mem;
+};
+
+struct wined3d_cs_buffer_invalidate_bo_range
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+    unsigned int offset, size;
+};
+
+struct wined3d_cs_skip
+{
+    enum wined3d_cs_op opcode;
+    DWORD size;
+};
+
+struct wined3d_cs_query_issue
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_query *query;
+    DWORD flags;
+};
+
+struct wined3d_cs_texture_preload
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *texture;
+};
+
+struct wined3d_cs_update_texture
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *src, *dst;
+};
+
+struct wined3d_cs_evict_resource
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+};
+
+struct wined3d_cs_update_sub_resource
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+    unsigned int sub_resource_idx, row_pitch, depth_pitch;
+    const struct wined3d_box *box;
+    const void *data;
+};
+
+struct wined3d_cs_buffer_preload
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+};
+
+struct wined3d_cs_create_vbo
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+};
+
+struct wined3d_cs_sampler_init
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_sampler *sampler;
+};
+
+struct wined3d_cs_get_release_dc
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *texture;
+    unsigned int sub_resource_idx;
+};
+
+struct wined3d_cs_create_dummy_textures
+{
+    enum wined3d_cs_op opcode;
+};
+
+struct wined3d_cs_create_swapchain_context
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_swapchain *swapchain;
+    HRESULT *ret;
+};
+
+struct wined3d_cs_delete_gl_contexts
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_swapchain *swapchain;
+};
+
+struct wined3d_cs_update_swap_interval
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_swapchain *swapchain;
+};
+
+static void wined3d_cs_mt_submit(struct wined3d_cs *cs, size_t size)
+{
+    LONG new_val = (cs->queue.head + size) & (WINED3D_CS_QUEUE_SIZE - 1);
+    /* There is only one thread writing to queue.head, InterlockedExchange
+     * is used for the memory barrier. */
+    InterlockedExchange(&cs->queue.head, new_val);
+
+    if (InterlockedCompareExchange(&cs->waiting_for_event, FALSE, TRUE))
+        SetEvent(cs->event);
+}
+
+static void wined3d_cs_mt_submit_prio(struct wined3d_cs *cs, size_t size)
+{
+    LONG new_val = (cs->prio_queue.head + size) & (WINED3D_CS_QUEUE_SIZE - 1);
+    /* There is only one thread writing to queue.head, InterlockedExchange
+     * is used for the memory barrier. */
+    InterlockedExchange(&cs->prio_queue.head, new_val);
+
+    if (InterlockedCompareExchange(&cs->waiting_for_event, FALSE, TRUE))
+        SetEvent(cs->event);
+}
+
+static UINT wined3d_cs_exec_nop(struct wined3d_cs *cs, const void *data)
+{
+    return sizeof(enum wined3d_cs_op);
+}
+
+static UINT wined3d_cs_exec_skip(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_skip *op = data;
+
+    return op->size;
+}
+
+static UINT wined3d_cs_exec_fence(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_fence *op = data;
+
+    InterlockedExchange(op->signalled, TRUE);
+
+    return sizeof(*op);
+}
+
+static void wined3d_cs_emit_fence(struct wined3d_cs *cs, BOOL *signalled)
+{
+    struct wined3d_cs_fence *op;
+
+    *signalled = FALSE;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_FENCE;
+    op->signalled = signalled;
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static void wined3d_cs_emit_fence_prio(struct wined3d_cs *cs, BOOL *signalled)
+{
+    struct wined3d_cs_fence *op;
+
+    *signalled = FALSE;
+
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_FENCE;
+    op->signalled = signalled;
+    cs->ops->submit_prio(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_present *op = data;
     struct wined3d_swapchain *swapchain;
@@ -269,13 +600,24 @@ static void wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
     swapchain = op->swapchain;
     wined3d_swapchain_set_window(swapchain, op->dst_window_override);
 
+#if !defined(STAGING_CSMT)
     swapchain->swapchain_ops->swapchain_present(swapchain, &op->src_rect, &op->dst_rect, op->flags);
+#else  /* STAGING_CSMT */
+    swapchain->swapchain_ops->swapchain_present(swapchain, &op->src_rect, &op->dst_rect, op->flags,
+            cs->state.fb.depth_stencil);
+
+    InterlockedDecrement(&cs->pending_presents);
+#endif /* STAGING_CSMT */
 
     wined3d_resource_release(&swapchain->front_buffer->resource);
     for (i = 0; i < swapchain->desc.backbuffer_count; ++i)
     {
         wined3d_resource_release(&swapchain->back_buffers[i]->resource);
     }
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain,
@@ -283,6 +625,9 @@ void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *sw
 {
     struct wined3d_cs_present *op;
     unsigned int i;
+#if defined(STAGING_CSMT)
+    LONG pending;
+#endif /* STAGING_CSMT */
 
     op = cs->ops->require_space(cs, sizeof(*op));
     op->opcode = WINED3D_CS_OP_PRESENT;
@@ -298,34 +643,75 @@ void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *sw
         wined3d_resource_acquire(&swapchain->back_buffers[i]->resource);
     }
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_clear(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    pending = InterlockedIncrement(&cs->pending_presents);
+
+    cs->ops->submit(cs, sizeof(*op));
+
+    /* D3D10 documentation suggests that Windows allows the game to run
+     * 3 frames ahead of the GPU. Increasing this above 1 causes uneven
+     * animation in some games, most notably StarCraft II. The framerates
+     * don't show this problem. The issue is more noticable with vsync
+     * on, but also happens with vsync off.
+     *
+     * In Counter-Strike: Source a frame difference of 3 causes noticable
+     * input delay that makes the game unplayable. */
+    while (pending > 1)
+        pending = InterlockedCompareExchange(&cs->pending_presents, 0, 0);
+}
+
+static UINT wined3d_cs_exec_clear(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_clear *op = data;
     const struct wined3d_state *state;
     struct wined3d_device *device;
     unsigned int i;
     RECT draw_rect;
+#if !defined(STAGING_CSMT)
 
     device = cs->device;
     state = &device->state;
     wined3d_get_draw_rect(state, &draw_rect);
     device_clear_render_targets(device, device->adapter->gl_info.limits.buffers,
             &device->fb, op->rect_count, op->rects, &draw_rect, op->flags,
+#else  /* STAGING_CSMT */
+    size_t size = FIELD_OFFSET(struct wined3d_cs_clear, rects[op->rect_count]);
+
+    device = cs->device;
+    state = &cs->state;
+    wined3d_get_draw_rect(state, &draw_rect);
+    device_clear_render_targets(device, device->adapter->gl_info.limits.buffers,
+            &cs->state.fb, op->rect_count, op->rects, &draw_rect, op->flags,
+#endif /* STAGING_CSMT */
             &op->color, op->depth, op->stencil);
 
     if (op->flags & WINED3DCLEAR_TARGET)
     {
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
+#if !defined(STAGING_CSMT)
             if (state->fb->render_targets[i])
                 wined3d_resource_release(state->fb->render_targets[i]->resource);
+#else  /* STAGING_CSMT */
+            if (state->fb.render_targets[i])
+                wined3d_resource_release(state->fb.render_targets[i]->resource);
+#endif /* STAGING_CSMT */
         }
     }
     if (op->flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
+#if !defined(STAGING_CSMT)
         wined3d_resource_release(state->fb->depth_stencil->resource);
+#else  /* STAGING_CSMT */
+        wined3d_resource_release(state->fb.depth_stencil->resource);
+
+    return size;
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
@@ -334,8 +720,13 @@ void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *
     const struct wined3d_state *state = &cs->device->state;
     struct wined3d_cs_clear *op;
     unsigned int i;
+#if !defined(STAGING_CSMT)
 
     op = cs->ops->require_space(cs, FIELD_OFFSET(struct wined3d_cs_clear, rects[rect_count]));
+#else  /* STAGING_CSMT */
+    size_t size = FIELD_OFFSET(struct wined3d_cs_clear, rects[rect_count]);
+    op = cs->ops->require_space(cs, size);
+#endif /* STAGING_CSMT */
     op->opcode = WINED3D_CS_OP_CLEAR;
     op->flags = flags;
     op->color = *color;
@@ -348,11 +739,17 @@ void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *
     {
         for (i = 0; i < cs->device->adapter->gl_info.limits.buffers; ++i)
         {
+#if !defined(STAGING_CSMT)
             if (state->fb->render_targets[i])
                 wined3d_resource_acquire(state->fb->render_targets[i]->resource);
+#else  /* STAGING_CSMT */
+            if (state->fb.render_targets[i])
+                wined3d_resource_acquire(state->fb.render_targets[i]->resource);
+#endif /* STAGING_CSMT */
         }
     }
     if (flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
+#if !defined(STAGING_CSMT)
         wined3d_resource_acquire(state->fb->depth_stencil->resource);
 
     cs->ops->submit(cs);
@@ -361,12 +758,65 @@ void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *
 static void wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
 {
     struct wined3d_state *state = &cs->device->state;
+#else  /* STAGING_CSMT */
+        wined3d_resource_acquire(state->fb.depth_stencil->resource);
+
+    cs->ops->submit(cs, size);
+}
+
+static inline BOOL wined3d_cs_colorwrite_enabled(const struct wined3d_state *state, unsigned int i)
+{
+    switch (i)
+    {
+        case 0:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE];
+        case 1:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE1];
+        case 2:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE2];
+        case 3:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE3];
+        default:
+            ERR("Unexpected color target %u.\n", i);
+            return TRUE;
+    }
+}
+
+static inline BOOL wined3d_cs_depth_stencil_enabled(const struct wined3d_state *state)
+{
+    return state->render_states[WINED3D_RS_ZENABLE]
+            || state->render_states[WINED3D_RS_STENCILENABLE];
+}
+
+static UINT wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
+{
+    struct wined3d_state *state = &cs->state;
+#endif /* STAGING_CSMT */
     struct wined3d_shader_sampler_map_entry *entry;
     struct wined3d_shader_resource_view *view;
     const struct wined3d_cs_draw *op = data;
+#if defined(STAGING_CSMT)
+    const struct wined3d_gl_info *gl_info = &cs->device->adapter->gl_info;
+#endif /* STAGING_CSMT */
     struct wined3d_shader *shader;
     unsigned int i, j;
 
+#if defined(STAGING_CSMT)
+    if (op->indexed && !gl_info->supported[ARB_DRAW_ELEMENTS_BASE_VERTEX])
+    {
+        if (cs->state.load_base_vertex_index != cs->state.base_vertex_index)
+        {
+            cs->state.load_base_vertex_index = cs->state.base_vertex_index;
+            device_invalidate_state(cs->device, STATE_BASEVERTEXINDEX);
+        }
+    }
+    else if (cs->state.load_base_vertex_index)
+    {
+        cs->state.load_base_vertex_index = 0;
+        device_invalidate_state(cs->device, STATE_BASEVERTEXINDEX);
+    }
+
+#endif /* STAGING_CSMT */
     if (!cs->device->adapter->gl_info.supported[ARB_DRAW_ELEMENTS_BASE_VERTEX]
             && state->load_base_vertex_index != op->base_vertex_idx)
     {
@@ -391,11 +841,19 @@ static void wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
     }
     for (i = 0; i < cs->device->adapter->gl_info.limits.buffers; ++i)
     {
+#if !defined(STAGING_CSMT)
         if (state->fb->render_targets[i])
             wined3d_resource_release(state->fb->render_targets[i]->resource);
     }
     if (state->fb->depth_stencil)
         wined3d_resource_release(state->fb->depth_stencil->resource);
+#else  /* STAGING_CSMT */
+        if (state->fb.render_targets[i] && wined3d_cs_colorwrite_enabled(state, i))
+            wined3d_resource_release(state->fb.render_targets[i]->resource);
+    }
+    if (state->fb.depth_stencil && wined3d_cs_depth_stencil_enabled(state))
+        wined3d_resource_release(state->fb.depth_stencil->resource);
+#endif /* STAGING_CSMT */
     for (i = 0; i < WINED3D_SHADER_TYPE_COUNT; ++i)
     {
         if (!(shader = state->shader[i]))
@@ -417,6 +875,10 @@ static void wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
             wined3d_resource_release(view->resource);
         }
     }
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_draw(struct wined3d_cs *cs, int base_vertex_idx, unsigned int start_idx,
@@ -439,11 +901,25 @@ void wined3d_cs_emit_draw(struct wined3d_cs *cs, int base_vertex_idx, unsigned i
     op->indexed = indexed;
 
     if (indexed)
+#if !defined(STAGING_CSMT)
         wined3d_resource_acquire(&state->index_buffer->resource);
+#else  /* STAGING_CSMT */
+    {
+        wined3d_resource_acquire(&state->index_buffer->resource);
+        state->index_buffer->ignore_discard = FALSE;
+    }
+#endif /* STAGING_CSMT */
     for (i = 0; i < ARRAY_SIZE(state->streams); ++i)
     {
         if (state->streams[i].buffer)
+#if !defined(STAGING_CSMT)
+            wined3d_resource_acquire(&state->streams[i].buffer->resource);
+#else  /* STAGING_CSMT */
+        {
             wined3d_resource_acquire(&state->streams[i].buffer->resource);
+            state->streams[i].buffer->ignore_discard = FALSE;
+        }
+#endif /* STAGING_CSMT */
     }
     for (i = 0; i < ARRAY_SIZE(state->textures); ++i)
     {
@@ -452,11 +928,19 @@ void wined3d_cs_emit_draw(struct wined3d_cs *cs, int base_vertex_idx, unsigned i
     }
     for (i = 0; i < cs->device->adapter->gl_info.limits.buffers; ++i)
     {
+#if !defined(STAGING_CSMT)
         if (state->fb->render_targets[i])
             wined3d_resource_acquire(state->fb->render_targets[i]->resource);
     }
     if (state->fb->depth_stencil)
         wined3d_resource_acquire(state->fb->depth_stencil->resource);
+#else  /* STAGING_CSMT */
+        if (state->fb.render_targets[i] && wined3d_cs_colorwrite_enabled(state, i))
+            wined3d_resource_acquire(state->fb.render_targets[i]->resource);
+    }
+    if (state->fb.depth_stencil && wined3d_cs_depth_stencil_enabled(state))
+        wined3d_resource_acquire(state->fb.depth_stencil->resource);
+#endif /* STAGING_CSMT */
     for (i = 0; i < WINED3D_SHADER_TYPE_COUNT; ++i)
     {
         if (!(shader = state->shader[i]))
@@ -479,15 +963,26 @@ void wined3d_cs_emit_draw(struct wined3d_cs *cs, int base_vertex_idx, unsigned i
         }
     }
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_predication(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_predication(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_predication *op = data;
 
     cs->state.predicate = op->predicate;
     cs->state.predicate_value = op->value;
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_predication(struct wined3d_cs *cs, struct wined3d_query *predicate, BOOL value)
@@ -499,15 +994,26 @@ void wined3d_cs_emit_set_predication(struct wined3d_cs *cs, struct wined3d_query
     op->predicate = predicate;
     op->value = value;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_viewport(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_viewport(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_viewport *op = data;
 
     cs->state.viewport = op->viewport;
     device_invalidate_state(cs->device, STATE_VIEWPORT);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport)
@@ -518,15 +1024,26 @@ void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_vi
     op->opcode = WINED3D_CS_OP_SET_VIEWPORT;
     op->viewport = *viewport;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_scissor_rect(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_scissor_rect(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_scissor_rect *op = data;
 
     cs->state.scissor_rect = op->rect;
     device_invalidate_state(cs->device, STATE_SCISSORRECT);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_scissor_rect(struct wined3d_cs *cs, const RECT *rect)
@@ -537,15 +1054,29 @@ void wined3d_cs_emit_set_scissor_rect(struct wined3d_cs *cs, const RECT *rect)
     op->opcode = WINED3D_CS_OP_SET_SCISSOR_RECT;
     op->rect = *rect;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_rendertarget_view(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_rendertarget_view(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_rendertarget_view *op = data;
 
+#if !defined(STAGING_CSMT)
     cs->state.fb->render_targets[op->view_idx] = op->view;
     device_invalidate_state(cs->device, STATE_FRAMEBUFFER);
+#else  /* STAGING_CSMT */
+    cs->state.fb.render_targets[op->view_idx] = op->view;
+    device_invalidate_state(cs->device, STATE_FRAMEBUFFER);
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_rendertarget_view(struct wined3d_cs *cs, unsigned int view_idx,
@@ -558,16 +1089,27 @@ void wined3d_cs_emit_set_rendertarget_view(struct wined3d_cs *cs, unsigned int v
     op->view_idx = view_idx;
     op->view = view;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_depth_stencil_view(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_depth_stencil_view(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_depth_stencil_view *op = data;
     struct wined3d_device *device = cs->device;
     struct wined3d_rendertarget_view *prev;
 
+#if !defined(STAGING_CSMT)
     if ((prev = cs->state.fb->depth_stencil))
+#else  /* STAGING_CSMT */
+    if ((prev = cs->state.fb.depth_stencil))
+#endif /* STAGING_CSMT */
     {
         struct wined3d_surface *prev_surface = wined3d_rendertarget_view_get_surface(prev);
 
@@ -575,15 +1117,26 @@ static void wined3d_cs_exec_set_depth_stencil_view(struct wined3d_cs *cs, const
                 || prev_surface->container->flags & WINED3D_TEXTURE_DISCARD))
         {
             surface_modify_ds_location(prev_surface, WINED3D_LOCATION_DISCARDED, prev->width, prev->height);
+#if !defined(STAGING_CSMT)
             if (prev_surface == device->onscreen_depth_stencil)
             {
                 wined3d_texture_decref(device->onscreen_depth_stencil->container);
                 device->onscreen_depth_stencil = NULL;
+#else  /* STAGING_CSMT */
+            if (prev_surface == cs->onscreen_depth_stencil)
+            {
+                wined3d_texture_decref(cs->onscreen_depth_stencil->container);
+                cs->onscreen_depth_stencil = NULL;
+#endif /* STAGING_CSMT */
             }
         }
     }
 
+#if !defined(STAGING_CSMT)
     cs->fb.depth_stencil = op->view;
+#else  /* STAGING_CSMT */
+    cs->state.fb.depth_stencil = op->view;
+#endif /* STAGING_CSMT */
 
     if (!prev != !op->view)
     {
@@ -600,6 +1153,10 @@ static void wined3d_cs_exec_set_depth_stencil_view(struct wined3d_cs *cs, const
     }
 
     device_invalidate_state(device, STATE_FRAMEBUFFER);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_depth_stencil_view(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view)
@@ -610,15 +1167,26 @@ void wined3d_cs_emit_set_depth_stencil_view(struct wined3d_cs *cs, struct wined3
     op->opcode = WINED3D_CS_OP_SET_DEPTH_STENCIL_VIEW;
     op->view = view;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_vertex_declaration(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_vertex_declaration(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_vertex_declaration *op = data;
 
     cs->state.vertex_declaration = op->declaration;
     device_invalidate_state(cs->device, STATE_VDECL);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs, struct wined3d_vertex_declaration *declaration)
@@ -629,10 +1197,17 @@ void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs, struct wined3
     op->opcode = WINED3D_CS_OP_SET_VERTEX_DECLARATION;
     op->declaration = declaration;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_stream_source(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_stream_source(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_stream_source *op = data;
     struct wined3d_stream_state *stream;
@@ -650,6 +1225,10 @@ static void wined3d_cs_exec_set_stream_source(struct wined3d_cs *cs, const void
         InterlockedDecrement(&prev->resource.bind_count);
 
     device_invalidate_state(cs->device, STATE_STREAMSRC);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_stream_source(struct wined3d_cs *cs, UINT stream_idx,
@@ -664,10 +1243,17 @@ void wined3d_cs_emit_set_stream_source(struct wined3d_cs *cs, UINT stream_idx,
     op->offset = offset;
     op->stride = stride;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_stream_source_freq(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_stream_source_freq(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_stream_source_freq *op = data;
     struct wined3d_stream_state *stream;
@@ -677,6 +1263,10 @@ static void wined3d_cs_exec_set_stream_source_freq(struct wined3d_cs *cs, const
     stream->flags = op->flags;
 
     device_invalidate_state(cs->device, STATE_STREAMSRC);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_stream_source_freq(struct wined3d_cs *cs, UINT stream_idx, UINT frequency, UINT flags)
@@ -689,10 +1279,17 @@ void wined3d_cs_emit_set_stream_source_freq(struct wined3d_cs *cs, UINT stream_i
     op->frequency = frequency;
     op->flags = flags;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_stream_output(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_stream_output(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_stream_output *op = data;
     struct wined3d_stream_output *stream;
@@ -707,6 +1304,10 @@ static void wined3d_cs_exec_set_stream_output(struct wined3d_cs *cs, const void
         InterlockedIncrement(&op->buffer->resource.bind_count);
     if (prev)
         InterlockedDecrement(&prev->resource.bind_count);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_stream_output(struct wined3d_cs *cs, UINT stream_idx,
@@ -720,10 +1321,17 @@ void wined3d_cs_emit_set_stream_output(struct wined3d_cs *cs, UINT stream_idx,
     op->buffer = buffer;
     op->offset = offset;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_index_buffer(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_index_buffer(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_index_buffer *op = data;
     struct wined3d_buffer *prev;
@@ -739,6 +1347,10 @@ static void wined3d_cs_exec_set_index_buffer(struct wined3d_cs *cs, const void *
         InterlockedDecrement(&prev->resource.bind_count);
 
     device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_index_buffer(struct wined3d_cs *cs, struct wined3d_buffer *buffer,
@@ -752,11 +1364,18 @@ void wined3d_cs_emit_set_index_buffer(struct wined3d_cs *cs, struct wined3d_buff
     op->format_id = format_id;
     op->offset = offset;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_constant_buffer(struct wined3d_cs *cs, const void *data)
-{
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_constant_buffer(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
+{
     const struct wined3d_cs_set_constant_buffer *op = data;
     struct wined3d_buffer *prev;
 
@@ -769,6 +1388,9 @@ static void wined3d_cs_exec_set_constant_buffer(struct wined3d_cs *cs, const voi
         InterlockedDecrement(&prev->resource.bind_count);
 
     device_invalidate_state(cs->device, STATE_CONSTANT_BUFFER(op->type));
+#if defined(STAGING_CSMT)
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_constant_buffer(struct wined3d_cs *cs, enum wined3d_shader_type type,
@@ -782,10 +1404,17 @@ void wined3d_cs_emit_set_constant_buffer(struct wined3d_cs *cs, enum wined3d_sha
     op->cb_idx = cb_idx;
     op->buffer = buffer;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_texture(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_texture(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_gl_info *gl_info = &cs->device->adapter->gl_info;
     const struct wined3d_d3d_info *d3d_info = &cs->device->adapter->d3d_info;
@@ -862,6 +1491,10 @@ static void wined3d_cs_exec_set_texture(struct wined3d_cs *cs, const void *data)
 
     if (new_use_color_key)
         device_invalidate_state(cs->device, STATE_COLOR_KEY);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_texture(struct wined3d_cs *cs, UINT stage, struct wined3d_texture *texture)
@@ -872,16 +1505,27 @@ void wined3d_cs_emit_set_texture(struct wined3d_cs *cs, UINT stage, struct wined
     op->opcode = WINED3D_CS_OP_SET_TEXTURE;
     op->stage = stage;
     op->texture = texture;
+#if !defined(STAGING_CSMT)
 
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_shader_resource_view(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_shader_resource_view(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_shader_resource_view *op = data;
 
     cs->state.shader_resource_view[op->type][op->view_idx] = op->view;
     device_invalidate_state(cs->device, STATE_SHADER_RESOURCE_BINDING);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_shader_resource_view(struct wined3d_cs *cs, enum wined3d_shader_type type,
@@ -895,15 +1539,26 @@ void wined3d_cs_emit_set_shader_resource_view(struct wined3d_cs *cs, enum wined3
     op->view_idx = view_idx;
     op->view = view;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_sampler(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_sampler(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_sampler *op = data;
 
     cs->state.sampler[op->type][op->sampler_idx] = op->sampler;
     device_invalidate_state(cs->device, STATE_SHADER_RESOURCE_BINDING);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_sampler(struct wined3d_cs *cs, enum wined3d_shader_type type,
@@ -917,16 +1572,27 @@ void wined3d_cs_emit_set_sampler(struct wined3d_cs *cs, enum wined3d_shader_type
     op->sampler_idx = sampler_idx;
     op->sampler = sampler;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_shader(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_shader(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_shader *op = data;
 
     cs->state.shader[op->type] = op->shader;
     device_invalidate_state(cs->device, STATE_SHADER(op->type));
     device_invalidate_state(cs->device, STATE_SHADER_RESOURCE_BINDING);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_shader(struct wined3d_cs *cs, enum wined3d_shader_type type, struct wined3d_shader *shader)
@@ -938,15 +1604,86 @@ void wined3d_cs_emit_set_shader(struct wined3d_cs *cs, enum wined3d_shader_type
     op->type = type;
     op->shader = shader;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_render_state(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_vs_consts_f(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_f *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.vs_consts_f[op->start_idx], op->constants, sizeof(op->constants[0]) * op->count);
+
+    device->shader_backend->shader_update_float_vertex_constants(device,
+            op->start_idx, op->count);
+
+    return sizeof(*op) + sizeof(op->constants[0]) * (op->count - 1);
+}
+
+static UINT wined3d_cs_exec_set_ps_consts_f(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_f *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.ps_consts_f[op->start_idx], op->constants, sizeof(op->constants[0]) * op->count);
+
+    device->shader_backend->shader_update_float_pixel_constants(device,
+            op->start_idx, op->count);
+
+    return sizeof(*op) + sizeof(op->constants[0]) * (op->count - 1);
+}
+
+void wined3d_cs_emit_set_consts_f(struct wined3d_cs *cs, unsigned int start_idx, unsigned int count,
+        const struct wined3d_vec4 *constants, enum wined3d_shader_type type)
+{
+    struct wined3d_cs_set_consts_f *op;
+    size_t size = sizeof(*op) + sizeof(op->constants[0]) * (count - 1);
+
+    op = cs->ops->require_space(cs, size);
+    switch (type)
+    {
+        case WINED3D_SHADER_TYPE_PIXEL:
+            op->opcode = WINED3D_CS_OP_SET_PS_CONSTS_F;
+            break;
+
+        case WINED3D_SHADER_TYPE_VERTEX:
+            op->opcode = WINED3D_CS_OP_SET_VS_CONSTS_F;
+            break;
+
+        case WINED3D_SHADER_TYPE_GEOMETRY:
+        case WINED3D_SHADER_TYPE_HULL:
+        case WINED3D_SHADER_TYPE_DOMAIN:
+        case WINED3D_SHADER_TYPE_COMPUTE:
+            FIXME("Invalid for geometry/compute shaders\n");
+            return;
+
+        case WINED3D_SHADER_TYPE_COUNT:
+            break;
+    }
+    op->start_idx = start_idx;
+    op->count = count;
+    memcpy(op->constants, constants, sizeof(op->constants[0]) * count);
+
+    cs->ops->submit(cs, size);
+}
+
+static UINT wined3d_cs_exec_set_render_state(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_render_state *op = data;
 
     cs->state.render_states[op->state] = op->value;
     device_invalidate_state(cs->device, STATE_RENDER(op->state));
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_render_state(struct wined3d_cs *cs, enum wined3d_render_state state, DWORD value)
@@ -958,6 +1695,7 @@ void wined3d_cs_emit_set_render_state(struct wined3d_cs *cs, enum wined3d_render
     op->state = state;
     op->value = value;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
@@ -967,6 +1705,135 @@ static void wined3d_cs_exec_set_texture_state(struct wined3d_cs *cs, const void
 
     cs->state.texture_states[op->stage][op->state] = op->value;
     device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, op->state));
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_vs_consts_b(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_b *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.vs_consts_b[op->start_idx], op->constants, sizeof(op->constants[0]) * op->count);
+
+    device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_VS_B);
+
+    return sizeof(*op) + sizeof(op->constants[0]) * (op->count - 1);
+}
+
+static UINT wined3d_cs_exec_set_ps_consts_b(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_b *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.ps_consts_b[op->start_idx], op->constants, sizeof(op->constants[0]) * op->count);
+
+    device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_PS_B);
+
+    return sizeof(*op) + sizeof(op->constants[0]) * (op->count - 1);
+}
+
+void wined3d_cs_emit_set_consts_b(struct wined3d_cs *cs, unsigned int start_idx,
+        unsigned int count, const BOOL *constants, enum wined3d_shader_type type)
+{
+    struct wined3d_cs_set_consts_b *op;
+    size_t size = sizeof(*op) + sizeof(op->constants[0]) * (count - 1);
+
+    op = cs->ops->require_space(cs, size);
+    switch (type)
+    {
+        case WINED3D_SHADER_TYPE_PIXEL:
+            op->opcode = WINED3D_CS_OP_SET_PS_CONSTS_B;
+            break;
+
+        case WINED3D_SHADER_TYPE_VERTEX:
+            op->opcode = WINED3D_CS_OP_SET_VS_CONSTS_B;
+            break;
+
+        case WINED3D_SHADER_TYPE_GEOMETRY:
+        case WINED3D_SHADER_TYPE_DOMAIN:
+        case WINED3D_SHADER_TYPE_HULL:
+        case WINED3D_SHADER_TYPE_COMPUTE:
+            FIXME("Invalid for geometry/compute shaders\n");
+            return;
+
+        case WINED3D_SHADER_TYPE_COUNT:
+            break;
+    }
+    op->start_idx = start_idx;
+    op->count = count;
+    memcpy(op->constants, constants, sizeof(op->constants[0]) * count);
+
+    cs->ops->submit(cs, size);
+}
+
+static UINT wined3d_cs_exec_set_vs_consts_i(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_i *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.vs_consts_i[op->start_idx], op->constants, sizeof(op->constants[0]) * op->count);
+
+    device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_VS_I);
+
+    return sizeof(*op) + sizeof(op->constants[0]) * (op->count - 1);
+}
+
+static UINT wined3d_cs_exec_set_ps_consts_i(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_i *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.ps_consts_i[op->start_idx], op->constants, sizeof(op->constants[0]) * op->count);
+
+    device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_PS_I);
+
+    return sizeof(*op) + sizeof(op->constants[0]) * (op->count - 1);
+}
+
+void wined3d_cs_emit_set_consts_i(struct wined3d_cs *cs, unsigned int start_idx, unsigned int count,
+        const struct wined3d_ivec4 *constants, enum wined3d_shader_type type)
+{
+    struct wined3d_cs_set_consts_i *op;
+    size_t size = sizeof(*op) + sizeof(op->constants[0]) * (count - 1);
+
+    op = cs->ops->require_space(cs, size);
+    switch (type)
+    {
+        case WINED3D_SHADER_TYPE_PIXEL:
+            op->opcode = WINED3D_CS_OP_SET_PS_CONSTS_I;
+            break;
+
+        case WINED3D_SHADER_TYPE_VERTEX:
+            op->opcode = WINED3D_CS_OP_SET_VS_CONSTS_I;
+            break;
+
+        case WINED3D_SHADER_TYPE_GEOMETRY:
+        case WINED3D_SHADER_TYPE_DOMAIN:
+        case WINED3D_SHADER_TYPE_HULL:
+        case WINED3D_SHADER_TYPE_COMPUTE:
+            FIXME("Invalid for geometry/compute shaders\n");
+            return;
+
+        case WINED3D_SHADER_TYPE_COUNT:
+            break;
+    }
+    op->start_idx = start_idx;
+    op->count = count;
+    memcpy(op->constants, constants, sizeof(op->constants[0]) * count);
+
+    cs->ops->submit(cs, size);
+}
+
+static UINT wined3d_cs_exec_set_texture_state(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_texture_state *op = data;
+
+    cs->state.texture_states[op->stage][op->state] = op->value;
+    device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, op->state));
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_texture_state(struct wined3d_cs *cs, UINT stage,
@@ -980,15 +1847,26 @@ void wined3d_cs_emit_set_texture_state(struct wined3d_cs *cs, UINT stage,
     op->state = state;
     op->value = value;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_sampler_state(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_sampler_state(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_sampler_state *op = data;
 
     cs->state.sampler_states[op->sampler_idx][op->state] = op->value;
     device_invalidate_state(cs->device, STATE_SAMPLER(op->sampler_idx));
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_sampler_state(struct wined3d_cs *cs, UINT sampler_idx,
@@ -1002,16 +1880,27 @@ void wined3d_cs_emit_set_sampler_state(struct wined3d_cs *cs, UINT sampler_idx,
     op->state = state;
     op->value = value;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_transform(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_transform(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_transform *op = data;
 
     cs->state.transforms[op->state] = op->matrix;
     if (op->state < WINED3D_TS_WORLD_MATRIX(cs->device->adapter->d3d_info.limits.ffp_vertex_blend_matrices))
         device_invalidate_state(cs->device, STATE_TRANSFORM(op->state));
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform_state state,
@@ -1024,15 +1913,26 @@ void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform
     op->state = state;
     op->matrix = *matrix;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_clip_plane(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_clip_plane(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_clip_plane *op = data;
 
     cs->state.clip_planes[op->plane_idx] = op->plane;
     device_invalidate_state(cs->device, STATE_CLIPPLANE(op->plane_idx));
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_clip_plane(struct wined3d_cs *cs, UINT plane_idx, const struct wined3d_vec4 *plane)
@@ -1044,10 +1944,17 @@ void wined3d_cs_emit_set_clip_plane(struct wined3d_cs *cs, UINT plane_idx, const
     op->plane_idx = plane_idx;
     op->plane = *plane;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_color_key(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_color_key(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_color_key *op = data;
     struct wined3d_texture *texture = op->texture;
@@ -1108,6 +2015,10 @@ static void wined3d_cs_exec_set_color_key(struct wined3d_cs *cs, const void *dat
                 break;
         }
     }
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_color_key(struct wined3d_cs *cs, struct wined3d_texture *texture,
@@ -1127,15 +2038,26 @@ void wined3d_cs_emit_set_color_key(struct wined3d_cs *cs, struct wined3d_texture
     else
         op->set = 0;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_set_material(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_material(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_set_material *op = data;
 
     cs->state.material = op->material;
     device_invalidate_state(cs->device, STATE_MATERIAL);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_set_material(struct wined3d_cs *cs, const struct wined3d_material *material)
@@ -1146,17 +2068,35 @@ void wined3d_cs_emit_set_material(struct wined3d_cs *cs, const struct wined3d_ma
     op->opcode = WINED3D_CS_OP_SET_MATERIAL;
     op->material = *material;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_reset_state(struct wined3d_cs *cs, const void *data)
 {
     struct wined3d_adapter *adapter = cs->device->adapter;
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_reset_state(struct wined3d_cs *cs, const void *data)
+{
+    struct wined3d_adapter *adapter = cs->device->adapter;
+    HRESULT hr;
+#endif /* STAGING_CSMT */
 
     state_cleanup(&cs->state);
     memset(&cs->state, 0, sizeof(cs->state));
+#if !defined(STAGING_CSMT)
     state_init(&cs->state, &cs->fb, &adapter->gl_info, &adapter->d3d_info,
             WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT);
+#else  /* STAGING_CSMT */
+    if (FAILED(hr = state_init(&cs->state, &adapter->gl_info, &adapter->d3d_info,
+            WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT)))
+        ERR("Failed to initialize CS state, hr %#x.\n", hr);
+
+    return sizeof(struct wined3d_cs_reset_state);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_reset_state(struct wined3d_cs *cs)
@@ -1166,14 +2106,25 @@ void wined3d_cs_emit_reset_state(struct wined3d_cs *cs)
     op = cs->ops->require_space(cs, sizeof(*op));
     op->opcode = WINED3D_CS_OP_RESET_STATE;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
 static void wined3d_cs_exec_destroy_object(struct wined3d_cs *cs, const void *data)
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_destroy_object(struct wined3d_cs *cs, const void *data)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_cs_destroy_object *op = data;
 
     op->callback(op->object);
+#if defined(STAGING_CSMT)
+
+    return sizeof(*op);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_cs_emit_destroy_object(struct wined3d_cs *cs, void (*callback)(void *object), void *object)
@@ -1185,6 +2136,7 @@ void wined3d_cs_emit_destroy_object(struct wined3d_cs *cs, void (*callback)(void
     op->callback = callback;
     op->object = object;
 
+#if !defined(STAGING_CSMT)
     cs->ops->submit(cs);
 }
 
@@ -1330,5 +2282,1263 @@ void wined3d_cs_destroy(struct wined3d_cs *cs)
     state_cleanup(&cs->state);
     HeapFree(GetProcessHeap(), 0, cs->fb.render_targets);
     HeapFree(GetProcessHeap(), 0, cs->data);
+#else  /* STAGING_CSMT */
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_glfinish(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_finish *op = data;
+    struct wined3d_device *device = cs->device;
+    struct wined3d_context *context;
+
+    if (!device->d3d_initialized)
+        return sizeof(*op);
+
+    context = context_acquire(device, NULL);
+    context->gl_info->gl_ops.gl.p_glFinish();
+    context_release(context);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_glfinish(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_finish *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_GLFINISH;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_base_vertex_index(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_base_vertex_index *op = data;
+
+    cs->state.base_vertex_index = op->base_vertex_index;
+    device_invalidate_state(cs->device, STATE_BASEVERTEXINDEX);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_base_vertex_index(struct wined3d_cs *cs,
+        UINT base_vertex_index)
+{
+    struct wined3d_cs_set_base_vertex_index *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_BASE_VERTEX_INDEX;
+    op->base_vertex_index = base_vertex_index;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_primitive_type(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_primitive_type *op = data;
+    GLenum prev;
+
+    prev = cs->state.gl_primitive_type;
+
+    if (op->gl_primitive_type == GL_POINTS || prev == GL_POINTS)
+        device_invalidate_state(cs->device, STATE_POINT_ENABLE);
+
+    cs->state.gl_primitive_type = op->gl_primitive_type;
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_primitive_type(struct wined3d_cs *cs, GLenum primitive_type)
+{
+    struct wined3d_cs_set_primitive_type *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_PRIMITIVE_TYPE;
+    op->gl_primitive_type = primitive_type;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_light(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_light *op = data;
+
+    UINT light_idx = op->light.OriginalIndex;
+    UINT hash_idx = LIGHTMAP_HASHFUNC(op->light.OriginalIndex);
+    struct wined3d_light_info *object = NULL;
+    struct list *e;
+
+    LIST_FOR_EACH(e, &cs->state.light_map[hash_idx])
+    {
+        object = LIST_ENTRY(e, struct wined3d_light_info, entry);
+        if (object->OriginalIndex == light_idx)
+            break;
+        object = NULL;
+    }
+
+    if (!object)
+    {
+        TRACE("Adding new light\n");
+        object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object));
+        if (!object)
+            return E_OUTOFMEMORY;
+
+        list_add_head(&cs->state.light_map[hash_idx], &object->entry);
+        object->glIndex = -1;
+        object->OriginalIndex = light_idx;
+    }
+
+    /* Update the live definitions if the light is currently assigned a glIndex. */
+    if (object->glIndex != -1)
+    {
+        if (object->OriginalParms.type != op->light.OriginalParms.type)
+            device_invalidate_state(cs->device, STATE_LIGHT_TYPE);
+        device_invalidate_state(cs->device, STATE_ACTIVELIGHT(object->glIndex));
+    }
+
+    object->OriginalParms = op->light.OriginalParms;
+    object->position = op->light.position;
+    object->direction = op->light.direction;
+    object->exponent = op->light.exponent;
+    object->cutoff = op->light.cutoff;
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_light(struct wined3d_cs *cs, const struct wined3d_light_info *light)
+{
+    struct wined3d_cs_set_light *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_LIGHT;
+    op->light = *light;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_light_enable(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_light_enable *op = data;
+    UINT hash_idx = LIGHTMAP_HASHFUNC(op->idx);
+    struct wined3d_light_info *light_info = NULL;
+    struct list *e;
+    struct wined3d_device *device = cs->device;
+
+    LIST_FOR_EACH(e, &cs->state.light_map[hash_idx])
+    {
+        light_info = LIST_ENTRY(e, struct wined3d_light_info, entry);
+        if (light_info->OriginalIndex == op->idx)
+            break;
+        light_info = NULL;
+    }
+    TRACE("Found light %p.\n", light_info);
+
+    /* Should be handled by the device by emitting a set_light op */
+    if (!light_info)
+    {
+        ERR("Light enabled requested but light not defined in cs state!\n");
+        return sizeof(*op);
+    }
+
+    if (!op->enable)
+    {
+        if (light_info->glIndex != -1)
+        {
+            device_invalidate_state(device, STATE_LIGHT_TYPE);
+            device_invalidate_state(device, STATE_ACTIVELIGHT(light_info->glIndex));
+            cs->state.lights[light_info->glIndex] = NULL;
+            light_info->glIndex = -1;
+        }
+        else
+        {
+            TRACE("Light already disabled, nothing to do\n");
+        }
+        light_info->enabled = FALSE;
+    }
+    else
+    {
+        light_info->enabled = TRUE;
+        if (light_info->glIndex != -1)
+        {
+            TRACE("Nothing to do as light was enabled\n");
+        }
+        else
+        {
+            unsigned int i;
+            const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+            /* Find a free GL light. */
+            for (i = 0; i < gl_info->limits.lights; ++i)
+            {
+                if (!cs->state.lights[i])
+                {
+                    cs->state.lights[i] = light_info;
+                    light_info->glIndex = i;
+                    break;
+                }
+            }
+            if (light_info->glIndex == -1)
+            {
+                /* Should be caught by the device before emitting
+                 * the light_enable op */
+                ERR("Too many concurrently active lights in cs\n");
+                return sizeof(*op);
+            }
+
+            /* i == light_info->glIndex */
+            device_invalidate_state(device, STATE_LIGHT_TYPE);
+            device_invalidate_state(device, STATE_ACTIVELIGHT(i));
+        }
+    }
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_light_enable(struct wined3d_cs *cs, UINT idx, BOOL enable)
+{
+    struct wined3d_cs_set_light_enable *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_LIGHT_ENABLE;
+    op->idx = idx;
+    op->enable = enable;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_blt(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_blt *op = data;
+
+    surface_blt_ugly(op->dst_surface, &op->dst_rect,
+            op->src_surface, &op->src_rect,
+            op->flags, &op->fx, op->filter);
+
+    wined3d_resource_release(&op->dst_surface->container->resource);
+    if (op->src_surface && op->src_surface != op->dst_surface)
+        wined3d_resource_release(&op->src_surface->container->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_blt(struct wined3d_cs *cs, struct wined3d_surface *dst_surface,
+        const RECT *dst_rect, struct wined3d_surface *src_surface,
+        const RECT *src_rect, DWORD flags, const struct wined3d_blt_fx *fx,
+        enum wined3d_texture_filter_type filter)
+{
+    struct wined3d_cs_blt *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_BLT;
+    op->dst_surface = dst_surface;
+    op->dst_rect = *dst_rect;
+    op->src_surface = src_surface;
+    op->src_rect = *src_rect;
+    op->flags = flags;
+    op->filter = filter;
+    if (fx)
+        op->fx = *fx;
+
+    wined3d_resource_acquire(&dst_surface->container->resource);
+    if (src_surface && src_surface != dst_surface)
+        wined3d_resource_acquire(&src_surface->container->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_clear_rtv(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_clear_rtv *op = data;
+    struct wined3d_device *device = cs->device;
+
+    if (op->flags & WINED3DCLEAR_TARGET)
+        op->blitter->color_fill(device, op->view, &op->rect, &op->color);
+    else
+        op->blitter->depth_fill(device, op->view, &op->rect, op->flags, op->depth, op->stencil);
+
+    wined3d_resource_release(op->view->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_clear_rtv(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view,
+        const RECT *rect, DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil,
+        const struct blit_shader *blitter)
+{
+    struct wined3d_cs_clear_rtv *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_CLEAR_RTV;
+    op->view = view;
+    op->rect = *rect;
+    op->flags = flags;
+    if (flags & WINED3DCLEAR_TARGET)
+        op->color = *color;
+    op->depth = depth;
+    op->stencil = stencil;
+    op->blitter = blitter;
+
+    wined3d_resource_acquire(view->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_texture_changed(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_texture_changed *op = data;
+
+    wined3d_texture_changed(op->texture, op->sub_resource_idx, op->swap_buffer, op->swap_heap_memory);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_texture_changed(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx, struct wined3d_gl_bo *swap_buffer, void *swap_heap_memory)
+{
+    struct wined3d_cs_texture_changed *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_TEXTURE_CHANGED;
+    op->texture = texture;
+    op->sub_resource_idx = sub_resource_idx;
+    op->swap_buffer = swap_buffer;
+    op->swap_heap_memory = swap_heap_memory;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_texture_map(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_texture_map *op = data;
+
+    *op->mem = wined3d_texture_map_internal(op->texture, op->sub_resource_idx, op->flags);
+
+    return sizeof(*op);
+}
+
+void *wined3d_cs_emit_texture_map(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx, DWORD flags)
+{
+    struct wined3d_cs_texture_map *op;
+    void *ret;
+
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_TEXTURE_MAP;
+    op->texture = texture;
+    op->sub_resource_idx = sub_resource_idx;
+    op->flags = flags;
+    op->mem = &ret;
+
+    cs->ops->submit_prio(cs, sizeof(*op));
+
+    cs->ops->finish_prio(cs);
+
+    return ret;
+}
+
+static UINT wined3d_cs_exec_texture_unmap(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_texture_unmap *op = data;
+
+    wined3d_texture_unmap_internal(op->texture, op->sub_resource_idx);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_texture_unmap(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx)
+{
+    struct wined3d_cs_texture_unmap *op;
+
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_TEXTURE_UNMAP;
+    op->texture = texture;
+    op->sub_resource_idx = sub_resource_idx;
+
+    cs->ops->submit_prio(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_query_issue(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_query_issue *op = data;
+    struct wined3d_query *query = op->query;
+    BOOL poll;
+
+    poll = query->query_ops->query_issue(query, op->flags);
+
+    if (wined3d_settings.cs_multithreaded)
+    {
+        if (poll && list_empty(&query->poll_list_entry))
+        {
+            list_add_tail(&cs->query_poll_list, &query->poll_list_entry);
+        }
+        else if (!poll && !list_empty(&query->poll_list_entry))
+        {
+            /* Can happen if occlusion queries are restarted. This discards the old
+             * result, polling it could result in a GL error */
+            list_remove(&query->poll_list_entry);
+            list_init(&query->poll_list_entry);
+        }
+        else if (op->flags & WINED3DISSUE_END)
+        {
+            /* Can happen when an occlusion query is ended without being started,
+             * in which case we don't want to poll, but still have to counter-balance
+             * the increment of the main counter (!poll && list_empty).
+             *
+             * This can also happen if an event query is re-issued before the first
+             * fence was reached (poll && !list_empty). In this case the query is
+             * already in the list and the poll function will check the new fence.
+             * We have to counter-balance the discarded increment. */
+            InterlockedIncrement(&query->counter_retrieved);
+        }
+    }
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_query_issue(struct wined3d_cs *cs, struct wined3d_query *query, DWORD flags)
+{
+    struct wined3d_cs_query_issue *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_QUERY_ISSUE;
+    op->query = query;
+    op->flags = flags;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_texture_preload(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_texture_preload *op = data;
+    struct wined3d_context *context;
+    struct wined3d_texture *texture = op->texture;
+
+    context = context_acquire(cs->device, NULL);
+    wined3d_texture_load(texture, context, texture->flags & WINED3D_TEXTURE_IS_SRGB);
+    context_release(context);
+
+    wined3d_resource_release(&texture->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_texture_preload(struct wined3d_cs *cs, struct wined3d_texture *texture)
+{
+    struct wined3d_cs_texture_preload *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_TEXTURE_PRELOAD;
+    op->texture = texture;
+
+    wined3d_resource_acquire(&texture->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_update_texture(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_update_texture *op = data;
+    struct wined3d_context *context;
+
+    context = context_acquire(cs->device, NULL);
+    device_exec_update_texture(context, op->src, op->dst);
+    context_release(context);
+
+    wined3d_resource_release(&op->src->resource);
+    wined3d_resource_release(&op->dst->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_update_texture(struct wined3d_cs *cs, struct wined3d_texture *src,
+        struct wined3d_texture *dst)
+{
+    struct wined3d_cs_update_texture *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_UPDATE_TEXTURE;
+    op->src = src;
+    op->dst = dst;
+
+    wined3d_resource_acquire(&op->src->resource);
+    wined3d_resource_acquire(&op->dst->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_evict_resource(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_evict_resource *op = data;
+    struct wined3d_resource *resource = op->resource;
+
+    resource->resource_ops->resource_unload(resource);
+
+    /* FIXME: Is this necessary? Bound buffers are preloaded anyway, and in theory
+     * PreLoad should take care of invalidating the state if the VBO changes */
+    if (resource->bind_count && resource->type == WINED3D_RTYPE_BUFFER)
+    {
+        device_invalidate_state(cs->device, STATE_STREAMSRC);
+        device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+    }
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_evict_resource(struct wined3d_cs *cs, struct wined3d_resource *resource)
+{
+    struct wined3d_cs_evict_resource *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_EVICT_RESOURCE;
+    op->resource = resource;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_update_sub_resource(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_update_sub_resource *op = data;
+
+    struct wined3d_texture_sub_resource *sub_resource;
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_const_bo_address addr;
+    struct wined3d_context *context;
+    struct wined3d_texture *texture;
+    struct wined3d_surface *surface;
+    POINT dst_point;
+    RECT src_rect;
+    unsigned int width, height, level;
+
+    texture = wined3d_texture_from_resource(op->resource);
+    sub_resource = wined3d_texture_get_sub_resource(texture, op->sub_resource_idx);
+    surface = sub_resource->u.surface;
+
+    level = op->sub_resource_idx % texture->level_count;
+    width = wined3d_texture_get_level_width(texture, level);
+    height = wined3d_texture_get_level_height(texture, level);
+
+    src_rect.left = 0;
+    src_rect.top = 0;
+    if (op->box)
+    {
+        src_rect.right = op->box->right - op->box->left;
+        src_rect.bottom = op->box->bottom - op->box->top;
+        dst_point.x = op->box->left;
+        dst_point.y = op->box->top;
+    }
+    else
+    {
+        src_rect.right = width;
+        src_rect.bottom = height;
+        dst_point.x = 0;
+        dst_point.y = 0;
+    }
+
+    addr.buffer_object = 0;
+    addr.addr = op->data;
+
+    context = context_acquire(texture->resource.device, NULL);
+    gl_info = context->gl_info;
+
+    /* Only load the surface for partial updates. */
+    if (!dst_point.x && !dst_point.y && src_rect.right == width && src_rect.bottom == height)
+        wined3d_texture_prepare_texture(texture, context, FALSE);
+    else
+        wined3d_texture_load_location(texture, op->sub_resource_idx, context, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_texture_bind_and_dirtify(texture, context, FALSE);
+
+    wined3d_surface_upload_data(surface, gl_info, texture->resource.format,
+            &src_rect, op->row_pitch, &dst_point, FALSE, &addr);
+
+    context_release(context);
+
+    wined3d_texture_validate_location(texture, op->sub_resource_idx, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_texture_invalidate_location(texture, op->sub_resource_idx, ~WINED3D_LOCATION_TEXTURE_RGB);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_update_sub_resource(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        unsigned int sub_resource_idx, const struct wined3d_box *box, const void *data, unsigned int row_pitch,
+        unsigned int depth_pitch)
+{
+    struct wined3d_cs_update_sub_resource *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_UPDATE_SUB_RESOURCE;
+    op->resource = resource;
+    op->sub_resource_idx = sub_resource_idx;
+    op->box = box;
+    op->data = data;
+    op->row_pitch = row_pitch;
+    op->depth_pitch = depth_pitch;
+
+    cs->ops->submit(cs, sizeof(*op));
+    /* The data pointer may go away, need to wait until the data is read. Copying the data may be faster.
+     * Don't forget to copy box as well in this case. */
+    cs->ops->finish(cs);
+}
+
+static UINT wined3d_cs_exec_buffer_swap_mem(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_buffer_swap_mem *op = data;
+    struct wined3d_buffer *buffer = op->buffer;
+
+    buffer_swap_mem(buffer, op->mem);
+
+    if (!buffer->buffer_object && buffer->resource.bind_count)
+    {
+        device_invalidate_state(cs->device, STATE_STREAMSRC);
+        device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+    }
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_buffer_swap_mem(struct wined3d_cs *cs, struct wined3d_buffer *buffer, BYTE *mem)
+{
+    struct wined3d_cs_buffer_swap_mem *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_BUFFER_SWAP_MEM;
+    op->buffer = buffer;
+    op->mem = mem;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_buffer_invalidate_bo_range(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_buffer_invalidate_bo_range *op = data;
+
+    buffer_invalidate_bo_range(op->buffer, op->offset, op->size);
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_buffer_invalidate_bo_range(struct wined3d_cs *cs,
+        struct wined3d_buffer *buffer, unsigned int offset, unsigned int size)
+{
+    struct wined3d_cs_buffer_invalidate_bo_range *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_BUFFER_INVALIDATE_RANGE;
+    op->buffer = buffer;
+    op->offset = offset;
+    op->size = size;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_buffer_preload(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_buffer_preload *op = data;
+    struct wined3d_context *context;
+
+    context = context_acquire(cs->device, NULL);
+    buffer_internal_preload(op->buffer, context, NULL);
+    context_release(context);
+
+    wined3d_resource_release(&op->buffer->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_buffer_preload(struct wined3d_cs *cs, struct wined3d_buffer *buffer)
+{
+    struct wined3d_cs_buffer_preload *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_BUFFER_PRELOAD;
+    op->buffer = buffer;
+
+    wined3d_resource_acquire(&buffer->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_create_vbo(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_create_vbo *op = data;
+    struct wined3d_context *context = context_acquire(cs->device, NULL);
+
+    buffer_create_buffer_object(op->buffer, context);
+
+    context_release(context);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_create_vbo(struct wined3d_cs *cs, struct wined3d_buffer *buffer)
+{
+    struct wined3d_cs_create_vbo *op;
+
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_CREATE_VBO;
+    op->buffer = buffer;
+
+    cs->ops->submit_prio(cs, sizeof(*op));
+    cs->ops->finish_prio(cs);
+}
+
+static UINT wined3d_cs_exec_sampler_init(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_sampler_init *op = data;
+
+    wined3d_sampler_init(op->sampler);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_sampler_init(struct wined3d_cs *cs, struct wined3d_sampler *sampler)
+{
+    struct wined3d_cs_sampler_init *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SAMPLER_INIT;
+    op->sampler = sampler;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_get_dc(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_get_release_dc *op = data;
+
+    wined3d_texture_get_dc_cs(op->texture, op->sub_resource_idx);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_get_dc(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx)
+{
+    struct wined3d_cs_get_release_dc *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_GET_DC;
+    op->texture = texture;
+    op->sub_resource_idx = sub_resource_idx;
+
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
+}
+
+static UINT wined3d_cs_exec_release_dc(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_get_release_dc *op = data;
+
+    wined3d_texture_release_dc_cs(op->texture, op->sub_resource_idx);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_release_dc(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx)
+{
+    struct wined3d_cs_get_release_dc *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_RELEASE_DC;
+    op->texture = texture;
+    op->sub_resource_idx = sub_resource_idx;
+
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
+}
+
+static UINT wined3d_cs_exec_create_dummy_textures(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_create_dummy_textures *op = data;
+    struct wined3d_context *context = context_acquire(cs->device, NULL);
+
+    device_create_dummy_textures(cs->device, context);
+
+    context_release(context);
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_create_dummy_textures(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_create_dummy_textures *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_CREATE_DUMMY_TEXTURES;
+
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
+}
+
+static UINT wined3d_cs_exec_create_swapchain_context(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_create_swapchain_context *op = data;
+
+    *op->ret = swapchain_create_context_cs(cs->device, op->swapchain);
+
+    return sizeof(*op);
+}
+
+HRESULT wined3d_cs_emit_create_swapchain_context(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain)
+{
+    HRESULT ret;
+    struct wined3d_cs_create_swapchain_context *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_CREATE_SWAPCHAIN_CONTEXT;
+    op->swapchain = swapchain;
+    op->ret = &ret;
+
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
+
+    return ret;
+}
+
+static UINT wined3d_cs_exec_delete_gl_contexts(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_delete_gl_contexts *op = data;
+
+    device_delete_opengl_contexts_cs(cs->device, op->swapchain);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_delete_opengl_contexts(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain)
+{
+    struct wined3d_cs_delete_gl_contexts *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_DELETE_GL_CONTEXTS;
+    op->swapchain = swapchain;
+
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
+}
+
+static UINT wined3d_cs_exec_update_swap_interval(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_update_swap_interval *op = data;
+
+    swapchain_update_swap_interval(op->swapchain);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_update_swap_interval(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain)
+{
+    struct wined3d_cs_update_swap_interval *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_UPDATE_SWAP_INTERVAL;
+    op->swapchain = swapchain;
+
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
+}
+
+static UINT (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void *data) =
+{
+    /* WINED3D_CS_OP_NOP                        */ wined3d_cs_exec_nop,
+    /* WINED3D_CS_OP_SKIP                       */ wined3d_cs_exec_skip,
+    /* WINED3D_CS_OP_FENCE                      */ wined3d_cs_exec_fence,
+    /* WINED3D_CS_OP_PRESENT                    */ wined3d_cs_exec_present,
+    /* WINED3D_CS_OP_CLEAR                      */ wined3d_cs_exec_clear,
+    /* WINED3D_CS_OP_DRAW                       */ wined3d_cs_exec_draw,
+    /* WINED3D_CS_OP_SET_PREDICATION            */ wined3d_cs_exec_set_predication,
+    /* WINED3D_CS_OP_SET_VIEWPORT               */ wined3d_cs_exec_set_viewport,
+    /* WINED3D_CS_OP_SET_SCISSOR_RECT           */ wined3d_cs_exec_set_scissor_rect,
+    /* WINED3D_CS_OP_SET_RENDERTARGET_VIEW      */ wined3d_cs_exec_set_rendertarget_view,
+    /* WINED3D_CS_OP_SET_DEPTH_STENCIL_VIEW     */ wined3d_cs_exec_set_depth_stencil_view,
+    /* WINED3D_CS_OP_SET_VERTEX_DECLARATION     */ wined3d_cs_exec_set_vertex_declaration,
+    /* WINED3D_CS_OP_SET_STREAM_SOURCE          */ wined3d_cs_exec_set_stream_source,
+    /* WINED3D_CS_OP_SET_STREAM_SOURCE_FREQ     */ wined3d_cs_exec_set_stream_source_freq,
+    /* WINED3D_CS_OP_SET_STREAM_OUTPUT          */ wined3d_cs_exec_set_stream_output,
+    /* WINED3D_CS_OP_SET_INDEX_BUFFER           */ wined3d_cs_exec_set_index_buffer,
+    /* WINED3D_CS_OP_SET_CONSTANT_BUFFER        */ wined3d_cs_exec_set_constant_buffer,
+    /* WINED3D_CS_OP_SET_TEXTURE                */ wined3d_cs_exec_set_texture,
+    /* WINED3D_CS_OP_SET_SHADER_RESOURCE_VIEW   */ wined3d_cs_exec_set_shader_resource_view,
+    /* WINED3D_CS_OP_SET_SAMPLER                */ wined3d_cs_exec_set_sampler,
+    /* WINED3D_CS_OP_SET_SHADER                 */ wined3d_cs_exec_set_shader,
+    /* WINED3D_CS_OP_SET_RENDER_STATE           */ wined3d_cs_exec_set_render_state,
+    /* WINED3D_CS_OP_SET_TEXTURE_STATE          */ wined3d_cs_exec_set_texture_state,
+    /* WINED3D_CS_OP_SET_SAMPLER_STATE          */ wined3d_cs_exec_set_sampler_state,
+    /* WINED3D_CS_OP_SET_TRANSFORM              */ wined3d_cs_exec_set_transform,
+    /* WINED3D_CS_OP_SET_CLIP_PLANE             */ wined3d_cs_exec_set_clip_plane,
+    /* WINED3D_CS_OP_SET_COLOR_KEY              */ wined3d_cs_exec_set_color_key,
+    /* WINED3D_CS_OP_SET_MATERIAL               */ wined3d_cs_exec_set_material,
+    /* WINED3D_CS_OP_RESET_STATE                */ wined3d_cs_exec_reset_state,
+    /* WINED3D_CS_OP_DESTROY_OBJECT             */ wined3d_cs_exec_destroy_object,
+    /* WINED3D_CS_OP_SET_VS_CONSTS_F            */ wined3d_cs_exec_set_vs_consts_f,
+    /* WINED3D_CS_OP_SET_VS_CONSTS_B            */ wined3d_cs_exec_set_vs_consts_b,
+    /* WINED3D_CS_OP_SET_VS_CONSTS_I            */ wined3d_cs_exec_set_vs_consts_i,
+    /* WINED3D_CS_OP_SET_PS_CONSTS_F            */ wined3d_cs_exec_set_ps_consts_f,
+    /* WINED3D_CS_OP_SET_PS_CONSTS_B            */ wined3d_cs_exec_set_ps_consts_b,
+    /* WINED3D_CS_OP_SET_PS_CONSTS_I            */ wined3d_cs_exec_set_ps_consts_i,
+    /* WINED3D_CS_OP_GLFINISH                   */ wined3d_cs_exec_glfinish,
+    /* WINED3D_CS_OP_SET_BASE_VERTEX_INDEX      */ wined3d_cs_exec_set_base_vertex_index,
+    /* WINED3D_CS_OP_SET_PRIMITIVE_TYPE         */ wined3d_cs_exec_set_primitive_type,
+    /* WINED3D_CS_OP_SET_LIGHT                  */ wined3d_cs_exec_set_light,
+    /* WINED3D_CS_OP_SET_LIGHT_ENABLE           */ wined3d_cs_exec_set_light_enable,
+    /* WINED3D_CS_OP_BLT                        */ wined3d_cs_exec_blt,
+    /* WINED3D_CS_OP_CLEAR_RTV                  */ wined3d_cs_exec_clear_rtv,
+    /* WINED3D_CS_OP_TEXTURE_CHANGED            */ wined3d_cs_exec_texture_changed,
+    /* WINED3D_CS_OP_TEXTURE_MAP                */ wined3d_cs_exec_texture_map,
+    /* WINED3D_CS_OP_TEXTURE_UNMAP              */ wined3d_cs_exec_texture_unmap,
+    /* WINED3D_CS_OP_BUFFER_SWAP_MEM            */ wined3d_cs_exec_buffer_swap_mem,
+    /* WINED3D_CS_OP_BUFFER_INVALIDATE_RANGE    */ wined3d_cs_exec_buffer_invalidate_bo_range,
+    /* WINED3D_CS_OP_BUFFER_PRELOAD             */ wined3d_cs_exec_buffer_preload,
+    /* WINED3D_CS_OP_QUERY_ISSUE                */ wined3d_cs_exec_query_issue,
+    /* WINED3D_CS_OP_TEXTURE_PRELOAD            */ wined3d_cs_exec_texture_preload,
+    /* WINED3D_CS_OP_UPDATE_TEXTURE             */ wined3d_cs_exec_update_texture,
+    /* WINED3D_CS_OP_EVICT_RESOURCE             */ wined3d_cs_exec_evict_resource,
+    /* WINED3D_CS_OP_UPDATE_SUB_RESOURCE        */ wined3d_cs_exec_update_sub_resource,
+    /* WINED3D_CS_OP_CREATE_VBO                 */ wined3d_cs_exec_create_vbo,
+    /* WINED3D_CS_OP_SAMPLER_INIT               */ wined3d_cs_exec_sampler_init,
+    /* WINED3D_CS_OP_GET_DC                     */ wined3d_cs_exec_get_dc,
+    /* WINED3D_CS_OP_RELEASE_DC                 */ wined3d_cs_exec_release_dc,
+    /* WINED3D_CS_OP_CREATE_DUMMY_TEXTURES      */ wined3d_cs_exec_create_dummy_textures,
+    /* WINED3D_CS_OP_CREATE_SWAPCHAIN_CONTEXT   */ wined3d_cs_exec_create_swapchain_context,
+    /* WINED3D_CS_OP_DELETE_GL_CONTEXTS         */ wined3d_cs_exec_delete_gl_contexts,
+    /* WINED3D_CS_OP_UPDATE_SWAP_INTERVAL       */ wined3d_cs_exec_update_swap_interval,
+};
+
+static inline void *_wined3d_cs_mt_require_space(struct wined3d_cs *cs, size_t size, BOOL prio)
+{
+    struct wined3d_cs_queue *queue = prio ? &cs->prio_queue : &cs->queue;
+    size_t queue_size = sizeof(queue->data) / sizeof(*queue->data);
+
+    if (cs->thread_id == GetCurrentThreadId())
+        ERR("Attempting to queue a command from the CS thread.\n");
+
+    if (queue_size - size < queue->head)
+    {
+        struct wined3d_cs_skip *skip;
+        size_t nop_size = queue_size - queue->head;
+
+        skip = _wined3d_cs_mt_require_space(cs, nop_size, prio);
+        if (nop_size < sizeof(*skip))
+        {
+            skip->opcode = WINED3D_CS_OP_NOP;
+        }
+        else
+        {
+            skip->opcode = WINED3D_CS_OP_SKIP;
+            skip->size = nop_size;
+        }
+
+        if (prio)
+            cs->ops->submit_prio(cs, nop_size);
+        else
+            cs->ops->submit(cs, nop_size);
+
+        assert(!queue->head);
+    }
+
+    while(1)
+    {
+        LONG head = queue->head;
+        LONG tail = *((volatile LONG *)&queue->tail);
+        LONG new_pos;
+        /* Empty */
+        if (head == tail)
+            break;
+        /* Head ahead of tail, take care of wrap-around */
+        new_pos = (head + size) & (WINED3D_CS_QUEUE_SIZE - 1);
+        if (head > tail && (new_pos || tail))
+            break;
+        /* Tail ahead of head, but still enough space */
+        if (new_pos < tail && new_pos)
+            break;
+
+        TRACE("Waiting for free space. Head %u, tail %u, want %u\n", head, tail,
+                (unsigned int) size);
+    }
+
+    return &queue->data[queue->head];
+}
+
+static inline void *wined3d_cs_mt_require_space(struct wined3d_cs *cs, size_t size)
+{
+    return _wined3d_cs_mt_require_space(cs, size, FALSE);
+}
+
+static inline void *wined3d_cs_mt_require_space_prio(struct wined3d_cs *cs, size_t size)
+{
+    return _wined3d_cs_mt_require_space(cs, size, TRUE);
+}
+
+/* FIXME: wined3d_device_uninit_3d() should either flush and wait, or be an
+ * OP itself. */
+static void wined3d_cs_emit_stop(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_stop *op;
+
+    op = wined3d_cs_mt_require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_STOP;
+
+    wined3d_cs_mt_submit(cs, sizeof(*op));
+}
+
+static void wined3d_cs_mt_finish(struct wined3d_cs *cs)
+{
+    BOOL fence;
+    wined3d_cs_emit_fence(cs, &fence);
+
+    /* A busy wait should be fine, we're not supposed to have to wait very
+     * long. */
+    while (!InterlockedCompareExchange(&fence, TRUE, TRUE));
+}
+
+static void wined3d_cs_mt_finish_prio(struct wined3d_cs *cs)
+{
+    BOOL fence;
+
+    if (cs->thread_id == GetCurrentThreadId())
+    {
+        static BOOL once;
+        if (!once)
+        {
+            FIXME("flush_and_wait called from cs thread\n");
+            once = TRUE;
+        }
+        return;
+    }
+
+    wined3d_cs_emit_fence_prio(cs, &fence);
+
+    /* A busy wait should be fine, we're not supposed to have to wait very
+     * long. */
+    while (!InterlockedCompareExchange(&fence, TRUE, TRUE));
+}
+
+static const struct wined3d_cs_ops wined3d_cs_mt_ops =
+{
+    wined3d_cs_mt_require_space,
+    wined3d_cs_mt_require_space_prio,
+    wined3d_cs_mt_submit,
+    wined3d_cs_mt_submit_prio,
+    wined3d_cs_mt_finish,
+    wined3d_cs_mt_finish_prio,
+};
+
+static void wined3d_cs_st_submit(struct wined3d_cs *cs, size_t size)
+{
+    enum wined3d_cs_op opcode = *(const enum wined3d_cs_op *)&cs->queue.data;
+
+    if (opcode >= WINED3D_CS_OP_STOP)
+    {
+        ERR("Invalid opcode %#x.\n", opcode);
+        return;
+    }
+
+    wined3d_cs_op_handlers[opcode](cs, &cs->queue.data);
+}
+
+static void wined3d_cs_st_finish(struct wined3d_cs *cs)
+{
+}
+
+static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size)
+{
+    return cs->queue.data;
+}
+
+static const struct wined3d_cs_ops wined3d_cs_st_ops =
+{
+    wined3d_cs_st_require_space,
+    wined3d_cs_st_require_space,
+    wined3d_cs_st_submit,
+    wined3d_cs_st_submit,
+    wined3d_cs_st_finish,
+    wined3d_cs_st_finish,
+};
+
+void wined3d_cs_switch_onscreen_ds(struct wined3d_cs *cs,
+        struct wined3d_context *context, struct wined3d_surface *depth_stencil)
+{
+    if (cs->onscreen_depth_stencil)
+    {
+        struct wined3d_texture *texture = cs->onscreen_depth_stencil->container;
+
+        wined3d_texture_load_location(texture,
+                surface_get_sub_resource_idx(cs->onscreen_depth_stencil),
+                context, WINED3D_LOCATION_TEXTURE_RGB);
+
+        surface_modify_ds_location(cs->onscreen_depth_stencil, WINED3D_LOCATION_TEXTURE_RGB,
+                cs->onscreen_depth_stencil->ds_current_size.cx,
+                cs->onscreen_depth_stencil->ds_current_size.cy);
+        wined3d_texture_decref(texture);
+    }
+    cs->onscreen_depth_stencil = depth_stencil;
+    wined3d_texture_incref(cs->onscreen_depth_stencil->container);
+}
+
+static inline void poll_queries(struct wined3d_cs *cs)
+{
+    struct wined3d_query *query, *cursor;
+
+    LIST_FOR_EACH_ENTRY_SAFE(query, cursor, &cs->query_poll_list, struct wined3d_query, poll_list_entry)
+    {
+        BOOL ret;
+
+        ret = query->query_ops->query_poll(query);
+        if (ret)
+        {
+            list_remove(&query->poll_list_entry);
+            list_init(&query->poll_list_entry);
+            InterlockedIncrement(&query->counter_retrieved);
+        }
+    }
+}
+
+static inline BOOL queue_is_empty(const struct wined3d_cs_queue *queue)
+{
+    return *((volatile LONG *)&queue->head) == queue->tail;
+}
+
+static void wined3d_cs_wait_event(struct wined3d_cs *cs)
+{
+    InterlockedExchange(&cs->waiting_for_event, TRUE);
+
+    /* The main thread might enqueue a finish command and block on it
+     * after the worker thread decided to enter wined3d_cs_wait_event
+     * and before waiting_for_event was set to TRUE. Check again if
+     * the queues are empty */
+    if (!queue_is_empty(&cs->prio_queue) || !queue_is_empty(&cs->queue))
+    {
+        /* The main thread might have signalled the event, or be in the process
+         * of doing so. Wait for the event to reset it. ResetEvent is not good
+         * because the main thread might be beween the waiting_for_event reset
+         * and SignalEvent call. */
+        if (!InterlockedCompareExchange(&cs->waiting_for_event, FALSE, FALSE))
+            WaitForSingleObject(cs->event, INFINITE);
+    }
+    else
+    {
+        WaitForSingleObject(cs->event, INFINITE);
+    }
+}
+
+static DWORD WINAPI wined3d_cs_run(void *thread_param)
+{
+    struct wined3d_cs *cs = thread_param;
+    enum wined3d_cs_op opcode;
+    LONG tail;
+    char poll = 0;
+    struct wined3d_cs_queue *queue;
+    unsigned int spin_count = 0;
+
+    TRACE("Started.\n");
+
+    list_init(&cs->query_poll_list);
+    cs->thread_id = GetCurrentThreadId();
+    for (;;)
+    {
+        if (poll == 10)
+        {
+            poll = 0;
+            poll_queries(cs);
+        }
+        else
+            poll++;
+
+        if (!queue_is_empty(&cs->prio_queue))
+        {
+            queue = &cs->prio_queue;
+        }
+        else if (!queue_is_empty(&cs->queue))
+        {
+            queue = &cs->queue;
+            if (!queue_is_empty(&cs->prio_queue))
+                queue = &cs->prio_queue;
+        }
+        else
+        {
+            spin_count++;
+            if (spin_count >= WINED3D_CS_SPIN_COUNT && list_empty(&cs->query_poll_list))
+                wined3d_cs_wait_event(cs);
+
+            continue;
+        }
+
+        spin_count = 0;
+
+        tail = queue->tail;
+        opcode = *(const enum wined3d_cs_op *)&queue->data[tail];
+
+        if (opcode >= WINED3D_CS_OP_STOP)
+        {
+            if (opcode > WINED3D_CS_OP_STOP)
+                ERR("Invalid opcode %#x.\n", opcode);
+            goto done;
+        }
+
+        tail += wined3d_cs_op_handlers[opcode](cs, &queue->data[tail]);
+        tail &= (WINED3D_CS_QUEUE_SIZE - 1);
+        InterlockedExchange(&queue->tail, tail);
+    }
+
+done:
+    TRACE("Stopped.\n");
+    return 0;
+}
+
+struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device)
+{
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    struct wined3d_cs *cs = NULL;
+
+    if (!(cs = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*cs))))
+        return NULL;
+
+    if (FAILED(state_init(&cs->state, gl_info, &device->adapter->d3d_info,
+            WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT)))
+    {
+        goto err;
+    }
+
+    cs->ops = &wined3d_cs_st_ops;
+    cs->device = device;
+
+    if (wined3d_settings.cs_multithreaded)
+    {
+        cs->ops = &wined3d_cs_mt_ops;
+
+        cs->event = CreateEventW(NULL, FALSE, FALSE, NULL);
+
+        if (!(cs->thread = CreateThread(NULL, 0, wined3d_cs_run, cs, 0, NULL)))
+        {
+            ERR("Failed to create wined3d command stream thread.\n");
+            goto err;
+        }
+    }
+
+    return cs;
+
+err:
+    if (cs)
+        state_cleanup(&cs->state);
+    HeapFree(GetProcessHeap(), 0, cs);
+    return NULL;
+}
+
+void wined3d_cs_destroy(struct wined3d_cs *cs)
+{
+    DWORD ret;
+
+    state_cleanup(&cs->state);
+
+    if (wined3d_settings.cs_multithreaded)
+    {
+        wined3d_cs_emit_stop(cs);
+
+        ret = WaitForSingleObject(cs->thread, INFINITE);
+        CloseHandle(cs->thread);
+        if (ret != WAIT_OBJECT_0)
+            ERR("Wait failed (%#x).\n", ret);
+        if (!CloseHandle(cs->event))
+            ERR("Closing event failed.\n");
+    }
+
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, cs);
 }
diff --git a/dlls/wined3d/device.c b/dlls/wined3d/device.c
--- a/dlls/wined3d/device.c
+++ b/dlls/wined3d/device.c
@@ -198,6 +198,7 @@ void device_context_remove(struct wined3d_device *device, struct wined3d_context
     device->contexts = new_array;
 }
 
+#if !defined(STAGING_CSMT)
 void device_switch_onscreen_ds(struct wined3d_device *device,
         struct wined3d_context *context, struct wined3d_surface *depth_stencil)
 {
@@ -214,6 +215,7 @@ void device_switch_onscreen_ds(struct wined3d_device *device,
     wined3d_texture_incref(device->onscreen_depth_stencil->container);
 }
 
+#endif /* STAGING_CSMT */
 static BOOL is_full_clear(const struct wined3d_surface *target, const RECT *draw_rect, const RECT *clear_rect)
 {
     unsigned int height = wined3d_texture_get_level_height(target->container, target->texture_level);
@@ -283,7 +285,11 @@ static void prepare_ds_clear(struct wined3d_surface *ds, struct wined3d_context
     }
 
     /* Full load. */
+#if !defined(STAGING_CSMT)
     surface_load_location(ds, context, location);
+#else  /* STAGING_CSMT */
+    wined3d_texture_load_location(ds->container, surface_get_sub_resource_idx(ds), context, location);
+#endif /* STAGING_CSMT */
     SetRect(out_rect, 0, 0, ds->ds_current_size.cx, ds->ds_current_size.cy);
 }
 
@@ -294,7 +300,9 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
     struct wined3d_surface *target = rt_count ? wined3d_rendertarget_view_get_surface(fb->render_targets[0]) : NULL;
     struct wined3d_rendertarget_view *dsv = fb->depth_stencil;
     struct wined3d_surface *depth_stencil = dsv ? wined3d_rendertarget_view_get_surface(dsv) : NULL;
+#if !defined(STAGING_CSMT)
     const struct wined3d_state *state = &device->state;
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info;
     UINT drawable_width, drawable_height;
     struct wined3d_color corrected_color;
@@ -324,6 +332,7 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
     for (i = 0; i < rt_count; ++i)
     {
         struct wined3d_rendertarget_view *rtv = fb->render_targets[i];
+#if !defined(STAGING_CSMT)
         struct wined3d_surface *rt = wined3d_rendertarget_view_get_surface(rtv);
 
         if (rt && rtv->format->id != WINED3DFMT_NULL)
@@ -332,6 +341,17 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
                 surface_load_location(rt, context, rtv->resource->draw_binding);
             else
                 wined3d_texture_prepare_location(rt->container, rtv->sub_resource_idx,
+#else  /* STAGING_CSMT */
+
+        if (rtv && rtv->format->id != WINED3DFMT_NULL)
+        {
+            struct wined3d_texture *rt = wined3d_texture_from_resource(fb->render_targets[i]->resource);
+
+            if (flags & WINED3DCLEAR_TARGET && !is_full_clear(target, draw_rect, rect_count ? clear_rect : NULL))
+                wined3d_texture_load_location(rt, rtv->sub_resource_idx, context, rtv->resource->draw_binding);
+            else
+                wined3d_texture_prepare_location(rt, rtv->sub_resource_idx,
+#endif /* STAGING_CSMT */
                         context, rtv->resource->draw_binding);
         }
     }
@@ -358,13 +378,22 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
     {
         DWORD location = render_offscreen ? dsv->resource->draw_binding : WINED3D_LOCATION_DRAWABLE;
 
+#if !defined(STAGING_CSMT)
         if (!render_offscreen && depth_stencil != device->onscreen_depth_stencil)
             device_switch_onscreen_ds(device, context, depth_stencil);
+#else  /* STAGING_CSMT */
+        if (!render_offscreen && depth_stencil != device->cs->onscreen_depth_stencil)
+            wined3d_cs_switch_onscreen_ds(device->cs, context, depth_stencil);
+#endif /* STAGING_CSMT */
         prepare_ds_clear(depth_stencil, context, location,
                 draw_rect, rect_count, clear_rect, &ds_rect);
     }
 
+#if !defined(STAGING_CSMT)
     if (!context_apply_clear_state(context, state, rt_count, fb))
+#else  /* STAGING_CSMT */
+    if (!context_apply_clear_state(context, rt_count, fb))
+#endif /* STAGING_CSMT */
     {
         context_release(context);
         WARN("Failed to apply clear state, skipping clear.\n");
@@ -420,7 +449,11 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
             wined3d_texture_invalidate_location(texture, rtv->sub_resource_idx, ~rtv->resource->draw_binding);
         }
 
+#if !defined(STAGING_CSMT)
         if (!gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, state, fb))
+#else  /* STAGING_CSMT */
+        if (!gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, &device->cs->state, fb))
+#endif /* STAGING_CSMT */
         {
             if (rt_count > 1)
                 WARN("Clearing multiple sRGB render targets with no GL_ARB_framebuffer_sRGB "
@@ -680,7 +713,44 @@ out:
 }
 
 /* Context activation is done by the caller. */
+#if !defined(STAGING_CSMT)
 static void create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context)
+#else  /* STAGING_CSMT */
+static void create_default_samplers(struct wined3d_device *device)
+{
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+
+    if (gl_info->supported[ARB_SAMPLER_OBJECTS])
+    {
+        /* In SM4+ shaders there is a separation between resources and samplers. Some shader
+         * instructions allow access to resources without using samplers.
+         * In GLSL, resources are always accessed through sampler or image variables. The default
+         * sampler object is used to emulate the direct resource access when there is no sampler state
+         * to use.
+         */
+        GL_EXTCALL(glGenSamplers(1, &device->default_sampler));
+        GL_EXTCALL(glSamplerParameteri(device->default_sampler, GL_TEXTURE_MAG_FILTER, GL_NEAREST));
+        GL_EXTCALL(glSamplerParameteri(device->default_sampler, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST));
+        checkGLcall("Create default sampler");
+
+        /* In D3D10+, a NULL sampler maps to the default sampler state. */
+        GL_EXTCALL(glGenSamplers(1, &device->null_sampler));
+        GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR));
+        GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE));
+        GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE));
+        GL_EXTCALL(glSamplerParameteri(device->null_sampler, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE));
+        checkGLcall("Create null sampler");
+    }
+    else
+    {
+        device->default_sampler = 0;
+        device->null_sampler = 0;
+    }
+}
+
+/* Context activation is done by the caller. */
+void device_create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_d3d_info *d3d_info = &device->adapter->d3d_info;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
@@ -772,6 +842,10 @@ static void create_dummy_textures(struct wined3d_device *device, struct wined3d_
             checkGLcall("glTexImage3D");
         }
     }
+#if defined(STAGING_CSMT)
+
+    create_default_samplers(device);
+#endif /* STAGING_CSMT */
 }
 
 /* Context activation is done by the caller. */
@@ -814,6 +888,7 @@ static void destroy_dummy_textures(struct wined3d_device *device, const struct w
 }
 
 /* Context activation is done by the caller. */
+#if !defined(STAGING_CSMT)
 static void create_default_samplers(struct wined3d_device *device)
 {
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
@@ -847,6 +922,7 @@ static void create_default_samplers(struct wined3d_device *device)
 }
 
 /* Context activation is done by the caller. */
+#endif /* STAGING_CSMT */
 static void destroy_default_samplers(struct wined3d_device *device)
 {
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
@@ -983,7 +1059,11 @@ static void device_init_swapchain_state(struct wined3d_device *device, struct wi
     BOOL ds_enable = !!swapchain->desc.enable_auto_depth_stencil;
     unsigned int i;
 
+#if !defined(STAGING_CSMT)
     if (device->fb.render_targets)
+#else  /* STAGING_CSMT */
+    if (device->state.fb.render_targets)
+#endif /* STAGING_CSMT */
     {
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
@@ -1001,9 +1081,13 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
         struct wined3d_swapchain_desc *swapchain_desc)
 {
     static const struct wined3d_color black = {0.0f, 0.0f, 0.0f, 0.0f};
+#if !defined(STAGING_CSMT)
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     struct wined3d_swapchain *swapchain = NULL;
     struct wined3d_context *context;
+#else  /* STAGING_CSMT */
+    struct wined3d_swapchain *swapchain = NULL;
+#endif /* STAGING_CSMT */
     DWORD clear_flags = 0;
     HRESULT hr;
 
@@ -1014,9 +1098,11 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
     if (device->wined3d->flags & WINED3D_NO3D)
         return WINED3DERR_INVALIDCALL;
 
+#if !defined(STAGING_CSMT)
     if (!(device->fb.render_targets = wined3d_calloc(gl_info->limits.buffers, sizeof(*device->fb.render_targets))))
         return E_OUTOFMEMORY;
 
+#endif /* STAGING_CSMT */
     if (FAILED(hr = device->shader_backend->shader_alloc_private(device,
             device->adapter->vertex_pipe, device->adapter->fragment_pipe)))
     {
@@ -1065,17 +1151,23 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
     device->swapchains[0] = swapchain;
     device_init_swapchain_state(device, swapchain);
 
+#if !defined(STAGING_CSMT)
     context = context_acquire(device, swapchain->front_buffer->sub_resources[0].u.surface);
 
     create_dummy_textures(device, context);
     create_default_samplers(device);
+#else  /* STAGING_CSMT */
+    wined3d_cs_emit_create_dummy_textures(device->cs);
+#endif /* STAGING_CSMT */
 
     device->contexts[0]->last_was_rhw = 0;
 
     TRACE("All defaults now set up, leaving 3D init.\n");
 
+#if !defined(STAGING_CSMT)
     context_release(context);
 
+#endif /* STAGING_CSMT */
     /* Clear the screen */
     if (swapchain->back_buffers && swapchain->back_buffers[0])
         clear_flags |= WINED3DCLEAR_TARGET;
@@ -1091,7 +1183,9 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
     return WINED3D_OK;
 
 err_out:
+#if !defined(STAGING_CSMT)
     HeapFree(GetProcessHeap(), 0, device->fb.render_targets);
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, device->swapchains);
     device->swapchain_count = 0;
     if (device->back_buffer_view)
@@ -1148,8 +1242,10 @@ static void device_free_sampler(struct wine_rb_entry *entry, void *context)
 HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
 {
     struct wined3d_resource *resource, *cursor;
+#if !defined(STAGING_CSMT)
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
+#endif /* STAGING_CSMT */
     struct wined3d_surface *surface;
     UINT i;
 
@@ -1158,17 +1254,23 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     if (!device->d3d_initialized)
         return WINED3DERR_INVALIDCALL;
 
+#if !defined(STAGING_CSMT)
     /* I don't think that the interface guarantees that the device is destroyed from the same thread
      * it was created. Thus make sure a context is active for the glDelete* calls
      */
     context = context_acquire(device, NULL);
     gl_info = context->gl_info;
+#else  /* STAGING_CSMT */
+    if (wined3d_settings.cs_multithreaded)
+        device->cs->ops->finish(device->cs);
+#endif /* STAGING_CSMT */
 
     if (device->logo_texture)
         wined3d_texture_decref(device->logo_texture);
     if (device->cursor_texture)
         wined3d_texture_decref(device->cursor_texture);
 
+#if !defined(STAGING_CSMT)
     state_unbind_resources(&device->state);
 
     /* Unload resources */
@@ -1206,9 +1308,21 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     {
         surface = device->onscreen_depth_stencil;
         device->onscreen_depth_stencil = NULL;
+#else  /* STAGING_CSMT */
+    /* Release the buffers (with sanity checks).
+     * FIXME: Move this move into a separate patch. I think the idea
+     * behind this is that those surfaces should be freed before unloading
+     * remaining resources below.
+     * FIXME 2: Shouldn't the cs take care of onscreen_depth_stencil? */
+    if (device->cs->onscreen_depth_stencil)
+    {
+        surface = device->cs->onscreen_depth_stencil;
+        device->cs->onscreen_depth_stencil = NULL;
+#endif /* STAGING_CSMT */
         wined3d_texture_decref(surface->container);
     }
 
+#if !defined(STAGING_CSMT)
     if (device->fb.depth_stencil)
     {
         struct wined3d_rendertarget_view *view = device->fb.depth_stencil;
@@ -1218,9 +1332,13 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
         device->fb.depth_stencil = NULL;
         wined3d_rendertarget_view_decref(view);
     }
+#else  /* STAGING_CSMT */
+    state_unbind_resources(&device->state);
+#endif /* STAGING_CSMT */
 
     if (device->auto_depth_stencil_view)
     {
+#if !defined(STAGING_CSMT)
         struct wined3d_rendertarget_view *view = device->auto_depth_stencil_view;
 
         device->auto_depth_stencil_view = NULL;
@@ -1232,6 +1350,24 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     {
         wined3d_device_set_rendertarget_view(device, i, NULL, FALSE);
     }
+#else  /* STAGING_CSMT */
+        wined3d_rendertarget_view_decref(device->auto_depth_stencil_view);
+        device->auto_depth_stencil_view = NULL;
+    }
+
+    /* Unload resources */
+    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
+    {
+        TRACE("Unloading resource %p.\n", resource);
+        wined3d_cs_emit_evict_resource(device->cs, resource);
+    }
+
+    wine_rb_clear(&device->samplers, device_free_sampler, NULL);
+
+    /* FIXME: Is this in the right place??? */
+    wined3d_cs_emit_delete_opengl_contexts(device->cs, device->swapchains[0]);
+
+#endif /* STAGING_CSMT */
     if (device->back_buffer_view)
     {
         wined3d_rendertarget_view_decref(device->back_buffer_view);
@@ -1249,9 +1385,11 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     device->swapchains = NULL;
     device->swapchain_count = 0;
 
+#if !defined(STAGING_CSMT)
     HeapFree(GetProcessHeap(), 0, device->fb.render_targets);
     device->fb.render_targets = NULL;
 
+#endif /* STAGING_CSMT */
     device->d3d_initialized = FALSE;
 
     return WINED3D_OK;
@@ -1296,7 +1434,11 @@ UINT CDECL wined3d_device_get_available_texture_mem(const struct wined3d_device
 
     /* We can not acquire the context unless there is a swapchain. */
     if (device->swapchains && gl_info->supported[NVX_GPU_MEMORY_INFO] &&
+#if !defined(STAGING_CSMT)
             !wined3d_settings.emulated_textureram)
+#else  /* STAGING_CSMT */
+            !wined3d_settings.emulated_textureram && !wined3d_settings.cs_multithreaded)
+#endif /* STAGING_CSMT */
     {
         GLint vram_free_kb;
         UINT64 vram_free;
@@ -1637,6 +1779,7 @@ HRESULT CDECL wined3d_device_set_light(struct wined3d_device *device,
             light->direction.x, light->direction.y, light->direction.z,
             light->range, light->falloff, light->theta, light->phi);
 
+#if !defined(STAGING_CSMT)
     /* Update the live definitions if the light is currently assigned a glIndex. */
     if (object->glIndex != -1 && !device->recording)
     {
@@ -1645,6 +1788,7 @@ HRESULT CDECL wined3d_device_set_light(struct wined3d_device *device,
         device_invalidate_state(device, STATE_ACTIVELIGHT(object->glIndex));
     }
 
+#endif /* STAGING_CSMT */
     /* Save away the information. */
     object->OriginalParms = *light;
 
@@ -1724,6 +1868,11 @@ HRESULT CDECL wined3d_device_set_light(struct wined3d_device *device,
             FIXME("Unrecognized light type %#x.\n", light->type);
     }
 
+#if defined(STAGING_CSMT)
+    if (!device->recording)
+        wined3d_cs_emit_set_light(device->cs, object);
+
+#endif /* STAGING_CSMT */
     return WINED3D_OK;
 }
 
@@ -1796,12 +1945,14 @@ HRESULT CDECL wined3d_device_set_light_enable(struct wined3d_device *device, UIN
     {
         if (light_info->glIndex != -1)
         {
+#if !defined(STAGING_CSMT)
             if (!device->recording)
             {
                 device_invalidate_state(device, STATE_LIGHT_TYPE);
                 device_invalidate_state(device, STATE_ACTIVELIGHT(light_info->glIndex));
             }
 
+#endif /* STAGING_CSMT */
             device->update_state->lights[light_info->glIndex] = NULL;
             light_info->glIndex = -1;
         }
@@ -1843,6 +1994,7 @@ HRESULT CDECL wined3d_device_set_light_enable(struct wined3d_device *device, UIN
                 WARN("Too many concurrently active lights\n");
                 return WINED3D_OK;
             }
+#if !defined(STAGING_CSMT)
 
             /* i == light_info->glIndex */
             if (!device->recording)
@@ -1850,9 +2002,15 @@ HRESULT CDECL wined3d_device_set_light_enable(struct wined3d_device *device, UIN
                 device_invalidate_state(device, STATE_LIGHT_TYPE);
                 device_invalidate_state(device, STATE_ACTIVELIGHT(i));
             }
+#endif /* STAGING_CSMT */
         }
     }
 
+#if defined(STAGING_CSMT)
+    if (!device->recording)
+        wined3d_cs_emit_set_light_enable(device->cs, light_idx, enable);
+
+#endif /* STAGING_CSMT */
     return WINED3D_OK;
 }
 
@@ -2023,6 +2181,11 @@ void CDECL wined3d_device_set_base_vertex_index(struct wined3d_device *device, I
     TRACE("device %p, base_index %d.\n", device, base_index);
 
     device->update_state->base_vertex_index = base_index;
+#if defined(STAGING_CSMT)
+
+    if (!device->recording)
+        wined3d_cs_emit_set_base_vertex_index(device->cs, base_index);
+#endif /* STAGING_CSMT */
 }
 
 INT CDECL wined3d_device_get_base_vertex_index(const struct wined3d_device *device)
@@ -2068,7 +2231,11 @@ static void resolve_depth_buffer(struct wined3d_state *state)
             || !(dst_texture->resource.format_flags & WINED3DFMT_FLAG_DEPTH))
         return;
 
+#if !defined(STAGING_CSMT)
     if (!(src_view = state->fb->depth_stencil))
+#else  /* STAGING_CSMT */
+    if (!(src_view = state->fb.depth_stencil))
+#endif /* STAGING_CSMT */
         return;
     if (src_view->resource->type == WINED3D_RTYPE_BUFFER)
     {
@@ -2403,6 +2570,18 @@ struct wined3d_sampler * CDECL wined3d_device_get_vs_sampler(const struct wined3
     return device->state.sampler[WINED3D_SHADER_TYPE_VERTEX][idx];
 }
 
+#if defined(STAGING_CSMT)
+void device_invalidate_shader_constants(const struct wined3d_device *device, DWORD mask)
+{
+    UINT i;
+
+    for (i = 0; i < device->context_count; ++i)
+    {
+        device->contexts[i]->constant_update_mask |= mask;
+    }
+}
+
+#endif /* STAGING_CSMT */
 HRESULT CDECL wined3d_device_set_vs_consts_b(struct wined3d_device *device,
         unsigned int start_idx, unsigned int count, const BOOL *constants)
 {
@@ -2430,7 +2609,12 @@ HRESULT CDECL wined3d_device_set_vs_consts_b(struct wined3d_device *device,
     }
     else
     {
+#if !defined(STAGING_CSMT)
         wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_VS_B, start_idx, count, constants);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_set_consts_b(device->cs, start_idx, count,
+                constants, WINED3D_SHADER_TYPE_VERTEX);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2479,7 +2663,12 @@ HRESULT CDECL wined3d_device_set_vs_consts_i(struct wined3d_device *device,
     }
     else
     {
+#if !defined(STAGING_CSMT)
         wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_VS_I, start_idx, count, constants);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_set_consts_i(device->cs, start_idx, count,
+                constants, WINED3D_SHADER_TYPE_VERTEX);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2524,7 +2713,12 @@ HRESULT CDECL wined3d_device_set_vs_consts_f(struct wined3d_device *device,
         memset(&device->recording->changed.vs_consts_f[start_idx], 1,
                 count * sizeof(*device->recording->changed.vs_consts_f));
     else
+#if !defined(STAGING_CSMT)
         wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_VS_F, start_idx, count, constants);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_set_consts_f(device->cs, start_idx, count, constants,
+                WINED3D_SHADER_TYPE_VERTEX);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -2663,7 +2857,12 @@ HRESULT CDECL wined3d_device_set_ps_consts_b(struct wined3d_device *device,
     }
     else
     {
+#if !defined(STAGING_CSMT)
         wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_PS_B, start_idx, count, constants);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_set_consts_b(device->cs, start_idx, count,
+                constants, WINED3D_SHADER_TYPE_PIXEL);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2712,7 +2911,12 @@ HRESULT CDECL wined3d_device_set_ps_consts_i(struct wined3d_device *device,
     }
     else
     {
+#if !defined(STAGING_CSMT)
         wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_PS_I, start_idx, count, constants);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_set_consts_i(device->cs, start_idx, count,
+                constants, WINED3D_SHADER_TYPE_PIXEL);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2758,7 +2962,12 @@ HRESULT CDECL wined3d_device_set_ps_consts_f(struct wined3d_device *device,
         memset(&device->recording->changed.ps_consts_f[start_idx], 1,
                 count * sizeof(*device->recording->changed.ps_consts_f));
     else
+#if !defined(STAGING_CSMT)
         wined3d_cs_push_constants(device->cs, WINED3D_PUSH_CONSTANTS_PS_F, start_idx, count, constants);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_set_consts_f(device->cs, start_idx, count, constants,
+                WINED3D_SHADER_TYPE_PIXEL);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -2918,6 +3127,15 @@ static HRESULT process_vertices_strided(const struct wined3d_device *device, DWO
         return hr;
     }
 
+#if defined(STAGING_CSMT)
+    if (wined3d_settings.cs_multithreaded)
+    {
+        FIXME("Waiting for cs.\n");
+        wined3d_cs_emit_glfinish(device->cs);
+        device->cs->ops->finish(device->cs);
+    }
+
+#endif /* STAGING_CSMT */
     wined3d_device_get_transform(device, WINED3D_TS_VIEW, &view_mat);
     wined3d_device_get_transform(device, WINED3D_TS_PROJECTION, &proj_mat);
     wined3d_device_get_transform(device, WINED3D_TS_WORLD_MATRIX(0), &world_mat);
@@ -3403,8 +3621,10 @@ HRESULT CDECL wined3d_device_begin_scene(struct wined3d_device *device)
 
 HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
 {
+#if !defined(STAGING_CSMT)
     struct wined3d_context *context;
 
+#endif /* STAGING_CSMT */
     TRACE("device %p.\n", device);
 
     if (!device->inScene)
@@ -3413,6 +3633,7 @@ HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     context = context_acquire(device, NULL);
     /* We only have to do this if we need to read the, swapbuffers performs a flush for us */
     context->gl_info->gl_ops.gl.p_glFlush();
@@ -3420,6 +3641,7 @@ HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
      * fails. */
     context_release(context);
 
+#endif /* STAGING_CSMT */
     device->inScene = FALSE;
     return WINED3D_OK;
 }
@@ -3427,6 +3649,10 @@ HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
 HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_count,
         const RECT *rects, DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil)
 {
+#if defined(STAGING_CSMT)
+    const struct wined3d_fb_state *fb = &device->state.fb;
+
+#endif /* STAGING_CSMT */
     TRACE("device %p, rect_count %u, rects %p, flags %#x, color %s, depth %.8e, stencil %u.\n",
             device, rect_count, rects, flags, debug_color(color), depth, stencil);
 
@@ -3438,7 +3664,11 @@ HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_cou
 
     if (flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
     {
+#if !defined(STAGING_CSMT)
         struct wined3d_rendertarget_view *ds = device->fb.depth_stencil;
+#else  /* STAGING_CSMT */
+        struct wined3d_rendertarget_view *ds = fb->depth_stencil;
+#endif /* STAGING_CSMT */
         if (!ds)
         {
             WARN("Clearing depth and/or stencil without a depth stencil buffer attached, returning WINED3DERR_INVALIDCALL\n");
@@ -3447,8 +3677,13 @@ HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_cou
         }
         else if (flags & WINED3DCLEAR_TARGET)
         {
+#if !defined(STAGING_CSMT)
             if (ds->width < device->fb.render_targets[0]->width
                     || ds->height < device->fb.render_targets[0]->height)
+#else  /* STAGING_CSMT */
+            if (ds->width < fb->render_targets[0]->width
+                    || ds->height < fb->render_targets[0]->height)
+#endif /* STAGING_CSMT */
             {
                 WARN("Silently ignoring depth and target clear with mismatching sizes\n");
                 return WINED3D_OK;
@@ -3494,7 +3729,9 @@ void CDECL wined3d_device_set_primitive_type(struct wined3d_device *device,
         enum wined3d_primitive_type primitive_type)
 {
     GLenum gl_primitive_type, prev;
+#if !defined(STAGING_CSMT)
 
+#endif /* STAGING_CSMT */
     TRACE("device %p, primitive_type %s\n", device, debug_d3dprimitivetype(primitive_type));
 
     gl_primitive_type = gl_primitive_type_from_d3d(primitive_type);
@@ -3502,8 +3739,13 @@ void CDECL wined3d_device_set_primitive_type(struct wined3d_device *device,
     device->update_state->gl_primitive_type = gl_primitive_type;
     if (device->recording)
         device->recording->changed.primitive_type = TRUE;
+#if !defined(STAGING_CSMT)
     else if (gl_primitive_type != prev && (gl_primitive_type == GL_POINTS || prev == GL_POINTS))
         device_invalidate_state(device, STATE_POINT_ENABLE);
+#else  /* STAGING_CSMT */
+    else if (gl_primitive_type != prev)
+        wined3d_cs_emit_set_primitive_type(device->cs, gl_primitive_type);
+#endif /* STAGING_CSMT */
 }
 
 void CDECL wined3d_device_get_primitive_type(const struct wined3d_device *device,
@@ -3563,10 +3805,16 @@ void CDECL wined3d_device_draw_indexed_primitive_instanced(struct wined3d_device
             start_idx, index_count, start_instance, instance_count, TRUE);
 }
 
+#if !defined(STAGING_CSMT)
 static HRESULT wined3d_device_update_texture_3d(struct wined3d_device *device,
+#else  /* STAGING_CSMT */
+/* Context activation is done by the caller. */
+static void wined3d_device_update_texture_3d(struct wined3d_context *context,
+#endif /* STAGING_CSMT */
         struct wined3d_texture *src_texture, unsigned int src_level,
         struct wined3d_texture *dst_texture, unsigned int level_count)
 {
+#if !defined(STAGING_CSMT)
     struct wined3d_const_bo_address data;
     struct wined3d_context *context;
     struct wined3d_map_desc src;
@@ -3591,6 +3839,13 @@ static HRESULT wined3d_device_update_texture_3d(struct wined3d_device *device,
     }
 
     context = context_acquire(device, NULL);
+#else  /* STAGING_CSMT */
+    struct wined3d_bo_address data;
+    unsigned int i;
+
+    TRACE("context %p, src_texture %p, src_level %u, dst_texture %p, level_count %u.\n",
+            context, src_texture, src_level, dst_texture, level_count);
+#endif /* STAGING_CSMT */
 
     /* Only a prepare, since we're uploading entire volumes. */
     wined3d_texture_prepare_texture(dst_texture, context, FALSE);
@@ -3598,6 +3853,7 @@ static HRESULT wined3d_device_update_texture_3d(struct wined3d_device *device,
 
     for (i = 0; i < level_count; ++i)
     {
+#if !defined(STAGING_CSMT)
         if (FAILED(hr = wined3d_resource_map(&src_texture->resource,
                 src_level + i, &src, NULL, WINED3D_MAP_READONLY)))
             goto done;
@@ -3614,16 +3870,92 @@ static HRESULT wined3d_device_update_texture_3d(struct wined3d_device *device,
 done:
     context_release(context);
     return hr;
+#else  /* STAGING_CSMT */
+        wined3d_texture_get_memory(src_texture, src_level + i, &data,
+                src_texture->resource.map_binding, FALSE);
+
+        wined3d_volume_upload_data(dst_texture, i, context, wined3d_const_bo_address(&data));
+        wined3d_texture_invalidate_location(dst_texture, i, ~WINED3D_LOCATION_TEXTURE_RGB);
+    }
+}
+
+/* Context activation is done by the caller */
+void device_exec_update_texture(struct wined3d_context *context, struct wined3d_texture *src_texture,
+        struct wined3d_texture *dst_texture)
+{
+    unsigned int src_size, dst_size, src_skip_levels = 0;
+    unsigned int level_count, i, j;
+
+    level_count = min(wined3d_texture_get_level_count(src_texture),
+            wined3d_texture_get_level_count(dst_texture));
+
+    src_size = max(src_texture->resource.width, src_texture->resource.height);
+    dst_size = max(dst_texture->resource.width, dst_texture->resource.height);
+    if (dst_texture->resource.type == WINED3D_RTYPE_TEXTURE_3D)
+    {
+        src_size = max(src_size, src_texture->resource.depth);
+        dst_size = max(dst_size, dst_texture->resource.depth);
+    }
+    while (src_size > dst_size)
+    {
+        src_size >>= 1;
+        ++src_skip_levels;
+    }
+
+    /* Make sure that the destination texture is loaded. */
+    wined3d_texture_load(dst_texture, context, FALSE);
+
+    /* Update every surface level of the texture. */
+    switch (dst_texture->resource.type)
+    {
+        case WINED3D_RTYPE_TEXTURE_2D:
+        {
+            unsigned int src_levels = src_texture->level_count;
+            unsigned int dst_levels = dst_texture->level_count;
+            struct wined3d_surface *src_surface;
+            struct wined3d_surface *dst_surface;
+
+            for (i = 0; i < src_texture->layer_count; ++i)
+            {
+                for (j = 0; j < level_count; ++j)
+                {
+                    HRESULT hr;
+                    src_surface = src_texture->sub_resources[i * src_levels + j + src_skip_levels].u.surface;
+                    dst_surface = dst_texture->sub_resources[i * dst_levels + j].u.surface;
+                    if (FAILED(hr = surface_upload_from_surface(dst_surface, NULL, src_surface, NULL)))
+                    {
+                        WARN("Failed to update surface, hr %#x.\n", hr);
+                        return;
+                    }
+                }
+            }
+            break;
+        }
+
+        case WINED3D_RTYPE_TEXTURE_3D:
+            wined3d_device_update_texture_3d(context,
+                    src_texture, src_skip_levels, dst_texture, level_count);
+            break;
+
+        default:
+            FIXME("Unsupported texture type %#x.\n", dst_texture->resource.type);
+    }
+#endif /* STAGING_CSMT */
 }
 
 HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
         struct wined3d_texture *src_texture, struct wined3d_texture *dst_texture)
 {
     unsigned int src_size, dst_size, src_skip_levels = 0;
+#if !defined(STAGING_CSMT)
     unsigned int layer_count, level_count, i, j;
     enum wined3d_resource_type type;
     HRESULT hr;
     struct wined3d_context *context;
+#else  /* STAGING_CSMT */
+    unsigned int layer_count;
+    enum wined3d_resource_type type;
+#endif /* STAGING_CSMT */
 
     TRACE("device %p, src_texture %p, dst_texture %p.\n", device, src_texture, dst_texture);
 
@@ -3660,6 +3992,7 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     level_count = min(wined3d_texture_get_level_count(src_texture),
             wined3d_texture_get_level_count(dst_texture));
 
@@ -3682,9 +4015,21 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
     context_release(context);
 
     /* Update every surface level of the texture. */
+#else  /* STAGING_CSMT */
+    /* FIXME: This isn't necessary for 2D textures, but currently surface_upload_from_surface
+     * rejects mismatching formats, and we can't report the error back after dispatching the
+     * call. */
+    if (src_texture->resource.format != dst_texture->resource.format)
+    {
+        WARN("Source and destination formats do not match.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+#endif /* STAGING_CSMT */
     switch (type)
     {
         case WINED3D_RTYPE_TEXTURE_2D:
+#if !defined(STAGING_CSMT)
         {
             unsigned int src_levels = src_texture->level_count;
             unsigned int dst_levels = dst_texture->level_count;
@@ -3717,6 +4062,38 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
             FIXME("Unsupported texture type %#x.\n", type);
             return WINED3DERR_INVALIDCALL;
     }
+#else  /* STAGING_CSMT */
+            break;
+
+        case WINED3D_RTYPE_TEXTURE_3D:
+            src_size = max(src_texture->resource.width, src_texture->resource.height);
+            src_size = max(src_size, src_texture->resource.depth);
+            dst_size = max(dst_texture->resource.width, dst_texture->resource.height);
+            dst_size = max(dst_size, dst_texture->resource.depth);
+
+            while (src_size > dst_size)
+            {
+                src_size >>= 1;
+                ++src_skip_levels;
+            }
+
+            if (wined3d_texture_get_level_width(src_texture, src_skip_levels) != dst_texture->resource.width
+                    || wined3d_texture_get_level_height(src_texture, src_skip_levels) != dst_texture->resource.height
+                    || wined3d_texture_get_level_depth(src_texture, src_skip_levels) != dst_texture->resource.depth)
+            {
+                WARN("Source and destination dimensions do not match.\n");
+                return WINED3DERR_INVALIDCALL;
+            }
+            break;
+
+        default:
+            break;
+    }
+
+    wined3d_cs_emit_update_texture(device->cs, src_texture, dst_texture);
+
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
 
 HRESULT CDECL wined3d_device_validate_device(const struct wined3d_device *device, DWORD *num_passes)
@@ -3764,8 +4141,13 @@ HRESULT CDECL wined3d_device_validate_device(const struct wined3d_device *device
     if (state->render_states[WINED3D_RS_ZENABLE] || state->render_states[WINED3D_RS_ZWRITEENABLE]
             || state->render_states[WINED3D_RS_STENCILENABLE])
     {
+#if !defined(STAGING_CSMT)
         struct wined3d_rendertarget_view *rt = device->fb.render_targets[0];
         struct wined3d_rendertarget_view *ds = device->fb.depth_stencil;
+#else  /* STAGING_CSMT */
+        struct wined3d_rendertarget_view *rt = state->fb.render_targets[0];
+        struct wined3d_rendertarget_view *ds = state->fb.depth_stencil;
+#endif /* STAGING_CSMT */
 
         if (ds && rt && (ds->width < rt->width || ds->height < rt->height))
         {
@@ -3954,6 +4336,9 @@ HRESULT CDECL wined3d_device_copy_sub_resource_region(struct wined3d_device *dev
     struct wined3d_texture *dst_texture, *src_texture;
     RECT dst_rect, src_rect;
     HRESULT hr;
+#if defined(STAGING_CSMT)
+    struct wined3d_box dst_box;
+#endif /* STAGING_CSMT */
 
     TRACE("device %p, dst_resource %p, dst_sub_resource_idx %u, dst_x %u, dst_y %u, dst_z %u, "
             "src_resource %p, src_sub_resource_idx %u, src_box %s.\n",
@@ -4041,6 +4426,16 @@ HRESULT CDECL wined3d_device_copy_sub_resource_region(struct wined3d_device *dev
 
     if (src_box)
     {
+#if defined(STAGING_CSMT)
+        if ((src_texture->resource.format_flags & WINED3DFMT_FLAG_BLOCKS)
+                && !wined3d_texture_check_block_align(src_texture,
+                src_sub_resource_idx % src_texture->level_count, src_box))
+        {
+            WARN("Source box not block-aligned.\n");
+            return WINED3DERR_INVALIDCALL;
+        }
+
+#endif /* STAGING_CSMT */
         SetRect(&src_rect, src_box->left, src_box->top, src_box->right, src_box->bottom);
     }
     else
@@ -4054,6 +4449,25 @@ HRESULT CDECL wined3d_device_copy_sub_resource_region(struct wined3d_device *dev
     SetRect(&dst_rect, dst_x, dst_y, dst_x + (src_rect.right - src_rect.left),
             dst_y + (src_rect.bottom - src_rect.top));
 
+#if defined(STAGING_CSMT)
+    if (dst_texture->resource.format_flags & WINED3DFMT_FLAG_BLOCKS)
+    {
+        dst_box.left = dst_rect.left;
+        dst_box.top = dst_rect.top;
+        dst_box.front = 0;
+        dst_box.right = dst_rect.right;
+        dst_box.bottom = dst_rect.bottom;
+        dst_box.back = 1;
+
+        if(!wined3d_texture_check_block_align(dst_texture,
+                dst_sub_resource_idx % dst_texture->level_count, &dst_box))
+        {
+            WARN("Destination box not block-aligned.\n");
+            return WINED3DERR_INVALIDCALL;
+        }
+    }
+
+#endif /* STAGING_CSMT */
     if (FAILED(hr = wined3d_texture_blt(dst_texture, dst_sub_resource_idx, &dst_rect,
             src_texture, src_sub_resource_idx, &src_rect, 0, NULL, WINED3D_TEXF_POINT)))
         WARN("Failed to blit, hr %#x.\n", hr);
@@ -4066,6 +4480,7 @@ void CDECL wined3d_device_update_sub_resource(struct wined3d_device *device, str
         unsigned int depth_pitch)
 {
     struct wined3d_texture_sub_resource *sub_resource;
+#if !defined(STAGING_CSMT)
     const struct wined3d_gl_info *gl_info;
     struct wined3d_const_bo_address addr;
     unsigned int width, height, level;
@@ -4074,6 +4489,9 @@ void CDECL wined3d_device_update_sub_resource(struct wined3d_device *device, str
     struct wined3d_surface *surface;
     POINT dst_point;
     RECT src_rect;
+#else  /* STAGING_CSMT */
+    struct wined3d_texture *texture;
+#endif /* STAGING_CSMT */
 
     TRACE("device %p, resource %p, sub_resource_idx %u, box %s, data %p, row_pitch %u, depth_pitch %u.\n",
             device, resource, sub_resource_idx, debug_box(box), data, row_pitch, depth_pitch);
@@ -4107,6 +4525,7 @@ void CDECL wined3d_device_update_sub_resource(struct wined3d_device *device, str
         WARN("Invalid sub_resource_idx %u.\n", sub_resource_idx);
         return;
     }
+#if !defined(STAGING_CSMT)
     surface = sub_resource->u.surface;
 
     level = sub_resource_idx % texture->level_count;
@@ -4117,6 +4536,17 @@ void CDECL wined3d_device_update_sub_resource(struct wined3d_device *device, str
     src_rect.top = 0;
     if (box)
     {
+#else  /* STAGING_CSMT */
+
+    if (box)
+    {
+        unsigned int width, height, level;
+
+        level = sub_resource_idx % texture->level_count;
+        width = wined3d_texture_get_level_width(texture, level);
+        height = wined3d_texture_get_level_height(texture, level);
+
+#endif /* STAGING_CSMT */
         if (box->left >= box->right || box->right > width
                 || box->top >= box->bottom || box->bottom > height
                 || box->front >= box->back)
@@ -4124,6 +4554,7 @@ void CDECL wined3d_device_update_sub_resource(struct wined3d_device *device, str
             WARN("Invalid box %s specified.\n", debug_box(box));
             return;
         }
+#if !defined(STAGING_CSMT)
 
         src_rect.right = box->right - box->left;
         src_rect.bottom = box->bottom - box->top;
@@ -4158,6 +4589,11 @@ void CDECL wined3d_device_update_sub_resource(struct wined3d_device *device, str
 
     wined3d_texture_validate_location(texture, sub_resource_idx, WINED3D_LOCATION_TEXTURE_RGB);
     wined3d_texture_invalidate_location(texture, sub_resource_idx, ~WINED3D_LOCATION_TEXTURE_RGB);
+#else  /* STAGING_CSMT */
+    }
+
+    wined3d_cs_emit_update_sub_resource(device->cs, resource, sub_resource_idx, box, data, row_pitch, depth_pitch);
+#endif /* STAGING_CSMT */
 }
 
 HRESULT CDECL wined3d_device_clear_rendertarget_view(struct wined3d_device *device,
@@ -4166,8 +4602,13 @@ HRESULT CDECL wined3d_device_clear_rendertarget_view(struct wined3d_device *devi
 {
     const struct blit_shader *blitter;
     struct wined3d_resource *resource;
+#if !defined(STAGING_CSMT)
     enum wined3d_blit_op blit_op;
     RECT r;
+#else  /* STAGING_CSMT */
+    RECT r;
+    enum wined3d_blit_op blit_op;
+#endif /* STAGING_CSMT */
 
     TRACE("device %p, view %p, rect %s, flags %#x, color %s, depth %.8e, stencil %u.\n",
             device, view, wine_dbgstr_rect(rect), flags, debug_color(color), depth, stencil);
@@ -4206,10 +4647,15 @@ HRESULT CDECL wined3d_device_clear_rendertarget_view(struct wined3d_device *devi
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     if (blit_op == WINED3D_BLIT_OP_COLOR_FILL)
         return blitter->color_fill(device, view, rect, color);
     else
         return blitter->depth_fill(device, view, rect, flags, depth, stencil);
+#else  /* STAGING_CSMT */
+    wined3d_cs_emit_clear_rtv(device->cs, view, rect, flags, color, depth, stencil, blitter);
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
 
 struct wined3d_rendertarget_view * CDECL wined3d_device_get_rendertarget_view(const struct wined3d_device *device,
@@ -4223,20 +4669,31 @@ struct wined3d_rendertarget_view * CDECL wined3d_device_get_rendertarget_view(co
         return NULL;
     }
 
+#if !defined(STAGING_CSMT)
     return device->fb.render_targets[view_idx];
+#else  /* STAGING_CSMT */
+    return device->state.fb.render_targets[view_idx];
+#endif /* STAGING_CSMT */
 }
 
 struct wined3d_rendertarget_view * CDECL wined3d_device_get_depth_stencil_view(const struct wined3d_device *device)
 {
     TRACE("device %p.\n", device);
 
+#if !defined(STAGING_CSMT)
     return device->fb.depth_stencil;
+#else  /* STAGING_CSMT */
+    return device->state.fb.depth_stencil;
+#endif /* STAGING_CSMT */
 }
 
 HRESULT CDECL wined3d_device_set_rendertarget_view(struct wined3d_device *device,
         unsigned int view_idx, struct wined3d_rendertarget_view *view, BOOL set_viewport)
 {
     struct wined3d_rendertarget_view *prev;
+#if defined(STAGING_CSMT)
+    struct wined3d_fb_state *fb = &device->state.fb;
+#endif /* STAGING_CSMT */
 
     TRACE("device %p, view_idx %u, view %p, set_viewport %#x.\n",
             device, view_idx, view, set_viewport);
@@ -4276,13 +4733,21 @@ HRESULT CDECL wined3d_device_set_rendertarget_view(struct wined3d_device *device
     }
 
 
+#if !defined(STAGING_CSMT)
     prev = device->fb.render_targets[view_idx];
+#else  /* STAGING_CSMT */
+    prev = fb->render_targets[view_idx];
+#endif /* STAGING_CSMT */
     if (view == prev)
         return WINED3D_OK;
 
     if (view)
         wined3d_rendertarget_view_incref(view);
+#if !defined(STAGING_CSMT)
     device->fb.render_targets[view_idx] = view;
+#else  /* STAGING_CSMT */
+    fb->render_targets[view_idx] = view;
+#endif /* STAGING_CSMT */
     wined3d_cs_emit_set_rendertarget_view(device->cs, view_idx, view);
     /* Release after the assignment, to prevent device_resource_released()
      * from seeing the surface as still in use. */
@@ -4294,18 +4759,29 @@ HRESULT CDECL wined3d_device_set_rendertarget_view(struct wined3d_device *device
 
 void CDECL wined3d_device_set_depth_stencil_view(struct wined3d_device *device, struct wined3d_rendertarget_view *view)
 {
+#if defined(STAGING_CSMT)
+    struct wined3d_fb_state *fb = &device->state.fb;
+#endif /* STAGING_CSMT */
     struct wined3d_rendertarget_view *prev;
 
     TRACE("device %p, view %p.\n", device, view);
 
+#if !defined(STAGING_CSMT)
     prev = device->fb.depth_stencil;
+#else  /* STAGING_CSMT */
+    prev = fb->depth_stencil;
+#endif /* STAGING_CSMT */
     if (prev == view)
     {
         TRACE("Trying to do a NOP SetRenderTarget operation.\n");
         return;
     }
 
+#if !defined(STAGING_CSMT)
     if ((device->fb.depth_stencil = view))
+#else  /* STAGING_CSMT */
+    if ((fb->depth_stencil = view))
+#endif /* STAGING_CSMT */
         wined3d_rendertarget_view_incref(view);
     wined3d_cs_emit_set_depth_stencil_view(device->cs, view);
     if (prev)
@@ -4527,6 +5003,10 @@ void CDECL wined3d_device_evict_managed_resources(struct wined3d_device *device)
 
     TRACE("device %p.\n", device);
 
+#if defined(STAGING_CSMT)
+    /* The resource list is manged by the main thread, iterate here and emit commands for
+     * each resource */
+#endif /* STAGING_CSMT */
     LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
     {
         TRACE("Checking resource %p for eviction.\n", resource);
@@ -4534,6 +5014,7 @@ void CDECL wined3d_device_evict_managed_resources(struct wined3d_device *device)
         if (resource->pool == WINED3D_POOL_MANAGED && !resource->map_count)
         {
             TRACE("Evicting %p.\n", resource);
+#if !defined(STAGING_CSMT)
             resource->resource_ops->resource_unload(resource);
         }
     }
@@ -4545,10 +5026,20 @@ void CDECL wined3d_device_evict_managed_resources(struct wined3d_device *device)
 static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
 {
     struct wined3d_resource *resource, *cursor;
+#else  /* STAGING_CSMT */
+            wined3d_cs_emit_evict_resource(device->cs, resource);
+        }
+    }
+}
+
+void device_delete_opengl_contexts_cs(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
     struct wined3d_shader *shader;
 
+#if !defined(STAGING_CSMT)
     context = context_acquire(device, NULL);
     gl_info = context->gl_info;
 
@@ -4558,11 +5049,17 @@ static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d
         resource->resource_ops->resource_unload(resource);
     }
 
+#endif /* STAGING_CSMT */
     LIST_FOR_EACH_ENTRY(shader, &device->shaders, struct wined3d_shader, shader_list_entry)
     {
         device->shader_backend->shader_destroy(shader);
     }
 
+#if defined(STAGING_CSMT)
+    context = context_acquire(device, NULL);
+    gl_info = context->gl_info;
+
+#endif /* STAGING_CSMT */
     if (device->depth_blt_texture)
     {
         gl_info->gl_ops.gl.p_glDeleteTextures(1, &device->depth_blt_texture);
@@ -4583,12 +5080,30 @@ static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d
 
     HeapFree(GetProcessHeap(), 0, swapchain->context);
     swapchain->context = NULL;
+#if defined(STAGING_CSMT)
+    swapchain->num_contexts = 0;
+}
+
+static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+    struct wined3d_resource *resource, *cursor;
+
+    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
+    {
+        TRACE("Unloading resource %p.\n", resource);
+        wined3d_cs_emit_evict_resource(device->cs, resource);
+    }
+
+    wined3d_cs_emit_delete_opengl_contexts(device->cs, swapchain);
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT create_primary_opengl_context(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
 {
+#if !defined(STAGING_CSMT)
     struct wined3d_context *context;
     struct wined3d_texture *target;
+#endif /* STAGING_CSMT */
     HRESULT hr;
 
     if (FAILED(hr = device->shader_backend->shader_alloc_private(device,
@@ -4605,6 +5120,7 @@ static HRESULT create_primary_opengl_context(struct wined3d_device *device, stru
         return hr;
     }
 
+#if !defined(STAGING_CSMT)
     /* Recreate the primary swapchain's context */
     swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
     if (!swapchain->context)
@@ -4617,10 +5133,15 @@ static HRESULT create_primary_opengl_context(struct wined3d_device *device, stru
 
     target = swapchain->back_buffers ? swapchain->back_buffers[0] : swapchain->front_buffer;
     if (!(context = context_create(swapchain, target, swapchain->ds_format)))
+#else  /* STAGING_CSMT */
+    hr = wined3d_cs_emit_create_swapchain_context(device->cs, swapchain);
+    if (FAILED(hr))
+#endif /* STAGING_CSMT */
     {
         WARN("Failed to create context.\n");
         device->blitter->free_private(device);
         device->shader_backend->shader_free_private(device);
+#if !defined(STAGING_CSMT)
         HeapFree(GetProcessHeap(), 0, swapchain->context);
         return E_FAIL;
     }
@@ -4630,6 +5151,12 @@ static HRESULT create_primary_opengl_context(struct wined3d_device *device, stru
     create_dummy_textures(device, context);
     create_default_samplers(device);
     context_release(context);
+#else  /* STAGING_CSMT */
+        return hr;
+    }
+
+    wined3d_cs_emit_create_dummy_textures(device->cs);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -4649,6 +5176,14 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
     TRACE("device %p, swapchain_desc %p, mode %p, callback %p, reset_state %#x.\n",
             device, swapchain_desc, mode, callback, reset_state);
 
+#if defined(STAGING_CSMT)
+    if (wined3d_settings.cs_multithreaded)
+    {
+        wined3d_cs_emit_glfinish(device->cs);
+        device->cs->ops->finish(device->cs);
+    }
+
+#endif /* STAGING_CSMT */
     if (!(swapchain = wined3d_device_get_swapchain(device, 0)))
     {
         ERR("Failed to get the first implicit swapchain.\n");
@@ -4668,10 +5203,16 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
             wined3d_texture_decref(device->cursor_texture);
             device->cursor_texture = NULL;
         }
+#if !defined(STAGING_CSMT)
         state_unbind_resources(&device->state);
     }
 
     if (device->fb.render_targets)
+#else  /* STAGING_CSMT */
+    }
+
+    if (device->state.fb.render_targets)
+#endif /* STAGING_CSMT */
     {
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
@@ -4680,10 +5221,22 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
     }
     wined3d_device_set_depth_stencil_view(device, NULL);
 
+#if !defined(STAGING_CSMT)
     if (device->onscreen_depth_stencil)
     {
         wined3d_texture_decref(device->onscreen_depth_stencil->container);
         device->onscreen_depth_stencil = NULL;
+#else  /* STAGING_CSMT */
+    if (reset_state)
+    {
+        state_unbind_resources(&device->state);
+    }
+
+    if (device->cs->onscreen_depth_stencil)
+    {
+        wined3d_texture_decref(device->cs->onscreen_depth_stencil->container);
+        device->cs->onscreen_depth_stencil = NULL;
+#endif /* STAGING_CSMT */
     }
 
     if (reset_state)
@@ -4905,30 +5458,52 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
         if (device->d3d_initialized)
             delete_opengl_contexts(device, swapchain);
 
+#if !defined(STAGING_CSMT)
         state_init(&device->state, &device->fb, &device->adapter->gl_info,
                 &device->adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT);
+#else  /* STAGING_CSMT */
+        if (FAILED(hr = state_init(&device->state, &device->adapter->gl_info,
+                &device->adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT)))
+            ERR("Failed to initialize device state, hr %#x.\n", hr);
+#endif /* STAGING_CSMT */
         device->update_state = &device->state;
 
         device_init_swapchain_state(device, swapchain);
     }
     else if (device->back_buffer_view)
     {
+#if !defined(STAGING_CSMT)
         struct wined3d_rendertarget_view *view = device->back_buffer_view;
         struct wined3d_state *state = &device->state;
 
         wined3d_device_set_rendertarget_view(device, 0, view, FALSE);
+#else  /* STAGING_CSMT */
+        struct wined3d_state *state = &device->state;
+
+        wined3d_device_set_rendertarget_view(device, 0, device->back_buffer_view, FALSE);
+#endif /* STAGING_CSMT */
 
         /* Note the min_z / max_z is not reset. */
         state->viewport.x = 0;
         state->viewport.y = 0;
+#if !defined(STAGING_CSMT)
         state->viewport.width = view->width;
         state->viewport.height = view->height;
+#else  /* STAGING_CSMT */
+        state->viewport.width = swapchain->desc.backbuffer_width;
+        state->viewport.height = swapchain->desc.backbuffer_height;
+#endif /* STAGING_CSMT */
         wined3d_cs_emit_set_viewport(device->cs, &state->viewport);
 
         state->scissor_rect.top = 0;
         state->scissor_rect.left = 0;
+#if !defined(STAGING_CSMT)
         state->scissor_rect.right = view->width;
         state->scissor_rect.bottom = view->height;
+#else  /* STAGING_CSMT */
+        state->scissor_rect.right = swapchain->desc.backbuffer_width;
+        state->scissor_rect.bottom = swapchain->desc.backbuffer_height;
+#endif /* STAGING_CSMT */
         wined3d_cs_emit_set_scissor_rect(device->cs, &state->scissor_rect);
     }
 
@@ -4936,7 +5511,11 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
     {
         if (reset_state)
             hr = create_primary_opengl_context(device, swapchain);
+#if !defined(STAGING_CSMT)
         swapchain_update_swap_interval(swapchain);
+#else  /* STAGING_CSMT */
+        wined3d_cs_emit_update_swap_interval(device->cs, swapchain);
+#endif /* STAGING_CSMT */
     }
 
     /* All done. There is no need to reload resources or shaders, this will happen automatically on the
@@ -5018,11 +5597,19 @@ void device_resource_released(struct wined3d_device *device, struct wined3d_reso
 
     for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
     {
+#if !defined(STAGING_CSMT)
         if ((rtv = device->fb.render_targets[i]) && rtv->resource == resource)
+#else  /* STAGING_CSMT */
+        if ((rtv = device->state.fb.render_targets[i]) && rtv->resource == resource)
+#endif /* STAGING_CSMT */
             ERR("Resource %p is still in use as render target %u.\n", resource, i);
     }
 
+#if !defined(STAGING_CSMT)
     if ((rtv = device->fb.depth_stencil) && rtv->resource == resource)
+#else  /* STAGING_CSMT */
+    if ((rtv = device->state.fb.depth_stencil) && rtv->resource == resource)
+#endif /* STAGING_CSMT */
         ERR("Resource %p is still in use as depth/stencil buffer.\n", resource);
 
     switch (type)
@@ -5158,8 +5745,17 @@ HRESULT device_init(struct wined3d_device *device, struct wined3d *wined3d,
 
     device->blitter = adapter->blitter;
 
+#if !defined(STAGING_CSMT)
     state_init(&device->state, &device->fb, &adapter->gl_info,
             &adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT);
+#else  /* STAGING_CSMT */
+    if (FAILED(hr = state_init(&device->state, &adapter->gl_info,
+            &adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT)))
+    {
+        ERR("Failed to initialize device state, hr %#x.\n", hr);
+        goto err;
+    }
+#endif /* STAGING_CSMT */
     device->update_state = &device->state;
 
     if (!(device->cs = wined3d_cs_create(device)))
@@ -5253,3 +5849,58 @@ LRESULT device_process_message(struct wined3d_device *device, HWND window, BOOL
     else
         return CallWindowProcA(proc, window, message, wparam, lparam);
 }
+#if defined(STAGING_CSMT)
+
+/* Context activation is done by the caller */
+struct wined3d_gl_bo *wined3d_device_get_bo(struct wined3d_device *device, UINT size, GLenum gl_usage,
+        GLenum type_hint, struct wined3d_context *context)
+{
+    struct wined3d_gl_bo *ret;
+    const struct wined3d_gl_info *gl_info;
+
+    TRACE("device %p, size %u, gl_usage %u, type_hint %u\n", device, size, gl_usage,
+            type_hint);
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*ret));
+    if(!ret)
+        return NULL;
+    ret->type_hint = type_hint;
+    ret->size = size;
+    ret->usage = gl_usage;
+
+    gl_info = context->gl_info;
+
+    GL_EXTCALL(glGenBuffers(1, &ret->name));
+    if (type_hint == GL_ELEMENT_ARRAY_BUFFER)
+        context_invalidate_state(context, STATE_INDEXBUFFER);
+    GL_EXTCALL(glBindBuffer(type_hint, ret->name));
+    GL_EXTCALL(glBufferData(type_hint, size, NULL, gl_usage));
+    GL_EXTCALL(glBindBuffer(type_hint, 0));
+    checkGLcall("Create buffer object");
+
+    TRACE("Successfully created and set up buffer %u\n", ret->name);
+    return ret;
+}
+
+/* Context activation is done by the caller */
+static void wined3d_device_destroy_bo(struct wined3d_device *device, const struct wined3d_context *context,
+        struct wined3d_gl_bo *bo)
+{
+    const struct wined3d_gl_info *gl_info = context->gl_info;
+    TRACE("device %p, bo %p, GL bo %u\n", device, bo, bo->name);
+
+    GL_EXTCALL(glDeleteBuffers(1, &bo->name));
+    checkGLcall("glDeleteBuffers");
+
+    HeapFree(GetProcessHeap(), 0, bo);
+}
+
+/* Context activation is done by the caller */
+void wined3d_device_release_bo(struct wined3d_device *device, struct wined3d_gl_bo *bo,
+        const struct wined3d_context *context)
+{
+    TRACE("device %p, bo %p, GL bo %u\n", device, bo, bo->name);
+
+    wined3d_device_destroy_bo(device, context, bo);
+}
+#endif /* STAGING_CSMT */
diff --git a/dlls/wined3d/drawprim.c b/dlls/wined3d/drawprim.c
--- a/dlls/wined3d/drawprim.c
+++ b/dlls/wined3d/drawprim.c
@@ -412,7 +412,11 @@ void draw_primitive(struct wined3d_device *device, const struct wined3d_state *s
         int base_vertex_idx, unsigned int start_idx, unsigned int index_count,
         unsigned int start_instance, unsigned int instance_count, BOOL indexed)
 {
+#if !defined(STAGING_CSMT)
     const struct wined3d_fb_state *fb = state->fb;
+#else  /* STAGING_CSMT */
+    const struct wined3d_fb_state *fb = &state->fb;
+#endif /* STAGING_CSMT */
     const struct wined3d_stream_info *stream_info;
     struct wined3d_event_query *ib_query = NULL;
     struct wined3d_stream_info si_emulated;
@@ -438,6 +442,7 @@ void draw_primitive(struct wined3d_device *device, const struct wined3d_state *s
     for (i = 0; i < gl_info->limits.buffers; ++i)
     {
         struct wined3d_rendertarget_view *rtv = fb->render_targets[i];
+#if !defined(STAGING_CSMT)
         struct wined3d_surface *target = wined3d_rendertarget_view_get_surface(rtv);
 
         if (target && rtv->format->id != WINED3DFMT_NULL)
@@ -446,11 +451,25 @@ void draw_primitive(struct wined3d_device *device, const struct wined3d_state *s
             {
                 surface_load_location(target, context, rtv->resource->draw_binding);
                 wined3d_texture_invalidate_location(target->container,
+#else  /* STAGING_CSMT */
+
+        if (rtv && rtv->format->id != WINED3DFMT_NULL)
+        {
+            struct wined3d_texture *target = wined3d_texture_from_resource(rtv->resource);
+            if (state->render_states[WINED3D_RS_COLORWRITEENABLE])
+            {
+                wined3d_texture_load_location(target, rtv->sub_resource_idx, context, rtv->resource->draw_binding);
+                wined3d_texture_invalidate_location(target,
+#endif /* STAGING_CSMT */
                         rtv->sub_resource_idx, ~rtv->resource->draw_binding);
             }
             else
             {
+#if !defined(STAGING_CSMT)
                 wined3d_texture_prepare_location(target->container, rtv->sub_resource_idx,
+#else  /* STAGING_CSMT */
+                wined3d_texture_prepare_location(target, rtv->sub_resource_idx,
+#endif /* STAGING_CSMT */
                         context, rtv->resource->draw_binding);
             }
         }
@@ -470,8 +489,13 @@ void draw_primitive(struct wined3d_device *device, const struct wined3d_state *s
         {
             RECT current_rect, draw_rect, r;
 
+#if !defined(STAGING_CSMT)
             if (!context->render_offscreen && ds != device->onscreen_depth_stencil)
                 device_switch_onscreen_ds(device, context, ds);
+#else  /* STAGING_CSMT */
+            if (!context->render_offscreen && ds != device->cs->onscreen_depth_stencil)
+                wined3d_cs_switch_onscreen_ds(device->cs, context, ds);
+#endif /* STAGING_CSMT */
 
             if (surface_get_sub_resource(ds)->locations & location)
                 SetRect(&current_rect, 0, 0, ds->ds_current_size.cx, ds->ds_current_size.cy);
@@ -482,7 +506,11 @@ void draw_primitive(struct wined3d_device *device, const struct wined3d_state *s
 
             IntersectRect(&r, &draw_rect, &current_rect);
             if (!EqualRect(&r, &draw_rect))
+#if !defined(STAGING_CSMT)
                 surface_load_location(ds, context, location);
+#else  /* STAGING_CSMT */
+                wined3d_texture_load_location(ds->container, surface_get_sub_resource_idx(ds), context, location);
+#endif /* STAGING_CSMT */
             else
                 wined3d_texture_prepare_location(ds->container, dsv->sub_resource_idx, context, location);
         }
diff --git a/dlls/wined3d/glsl_shader.c b/dlls/wined3d/glsl_shader.c
--- a/dlls/wined3d/glsl_shader.c
+++ b/dlls/wined3d/glsl_shader.c
@@ -1495,7 +1495,11 @@ static void shader_glsl_load_constants(void *shader_priv, struct wined3d_context
         const struct wined3d_vec4 correction_params =
         {
             /* Position is relative to the framebuffer, not the viewport. */
+#if !defined(STAGING_CSMT)
             context->render_offscreen ? 0.0f : (float)state->fb->render_targets[0]->height,
+#else  /* STAGING_CSMT */
+            context->render_offscreen ? 0.0f : (float)state->fb.render_targets[0]->height,
+#endif /* STAGING_CSMT */
             context->render_offscreen ? 1.0f : -1.0f,
             0.0f,
             0.0f,
@@ -1601,6 +1605,13 @@ static void shader_glsl_update_float_vertex_constants(struct wined3d_device *dev
     {
         update_heap_entry(heap, i, priv->next_constant_version);
     }
+#if defined(STAGING_CSMT)
+
+    for (i = 0; i < device->context_count; ++i)
+    {
+        device->contexts[i]->constant_update_mask |= WINED3D_SHADER_CONST_VS_F;
+    }
+#endif /* STAGING_CSMT */
 }
 
 static void shader_glsl_update_float_pixel_constants(struct wined3d_device *device, UINT start, UINT count)
@@ -1613,6 +1624,13 @@ static void shader_glsl_update_float_pixel_constants(struct wined3d_device *devi
     {
         update_heap_entry(heap, i, priv->next_constant_version);
     }
+#if defined(STAGING_CSMT)
+
+    for (i = 0; i < device->context_count; ++i)
+    {
+        device->contexts[i]->constant_update_mask |= WINED3D_SHADER_CONST_PS_F;
+    }
+#endif /* STAGING_CSMT */
 }
 
 static unsigned int vec4_varyings(DWORD shader_major, const struct wined3d_gl_info *gl_info)
diff --git a/dlls/wined3d/query.c b/dlls/wined3d/query.c
--- a/dlls/wined3d/query.c
+++ b/dlls/wined3d/query.c
@@ -35,6 +35,9 @@ static void wined3d_query_init(struct wined3d_query *query, struct wined3d_devic
     query->type = type;
     query->data_size = data_size;
     query->query_ops = query_ops;
+#if defined(STAGING_CSMT)
+    list_init(&query->poll_list_entry);
+#endif /* STAGING_CSMT */
 }
 
 static struct wined3d_event_query *wined3d_event_query_from_query(struct wined3d_query *query)
@@ -264,6 +267,11 @@ static void wined3d_query_destroy_object(void *object)
 {
     struct wined3d_query *query = object;
 
+#if defined(STAGING_CSMT)
+    if (!list_empty(&query->poll_list_entry))
+        list_remove(&query->poll_list_entry);
+
+#endif /* STAGING_CSMT */
     /* Queries are specific to the GL context that created them. Not
      * deleting the query will obviously leak it, but that's still better
      * than potentially deleting a different query with the same id in this
@@ -339,7 +347,21 @@ HRESULT CDECL wined3d_query_issue(struct wined3d_query *query, DWORD flags)
 {
     TRACE("query %p, flags %#x.\n", query, flags);
 
+#if !defined(STAGING_CSMT)
     return query->query_ops->query_issue(query, flags);
+#else  /* STAGING_CSMT */
+    if (flags & WINED3DISSUE_END)
+        query->counter_main++;
+
+    wined3d_cs_emit_query_issue(query->device->cs, query, flags);
+
+    if (flags & WINED3DISSUE_BEGIN)
+        query->state = QUERY_BUILDING;
+    else
+        query->state = QUERY_SIGNALLED;
+
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
 
 static void fill_query_data(void *out, unsigned int out_size, const void *result, unsigned int result_size)
@@ -351,6 +373,7 @@ static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
         void *data, DWORD size, DWORD flags)
 {
     struct wined3d_occlusion_query *oq = wined3d_occlusion_query_from_query(query);
+#if !defined(STAGING_CSMT)
     struct wined3d_device *device = query->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     struct wined3d_context *context;
@@ -362,6 +385,9 @@ static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
 
     if (!oq->context)
         query->state = QUERY_CREATED;
+#else  /* STAGING_CSMT */
+    GLuint samples;
+#endif /* STAGING_CSMT */
 
     if (query->state == QUERY_CREATED)
     {
@@ -372,6 +398,10 @@ static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
         return S_OK;
     }
 
+#if defined(STAGING_CSMT)
+    TRACE("(%p) : type D3DQUERY_OCCLUSION, data %p, size %#x, flags %#x.\n", query, data, size, flags);
+
+#endif /* STAGING_CSMT */
     if (query->state == QUERY_BUILDING)
     {
         /* Msdn says this returns an error, but our tests show that S_FALSE is returned */
@@ -379,12 +409,45 @@ static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
         return S_FALSE;
     }
 
+#if defined(STAGING_CSMT)
+    if (!wined3d_settings.cs_multithreaded)
+    {
+        if (!query->query_ops->query_poll(query))
+            return S_FALSE;
+    }
+    else if (query->counter_main != query->counter_retrieved)
+    {
+        return S_FALSE;
+    }
+
+    if (data)
+        fill_query_data(data, size, &oq->samples, sizeof(oq->samples));
+
+    return S_OK;
+}
+
+static BOOL wined3d_occlusion_query_ops_poll(struct wined3d_query *query)
+{
+    struct wined3d_occlusion_query *oq = wined3d_occlusion_query_from_query(query);
+    struct wined3d_device *device = query->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    struct wined3d_context *context;
+    GLuint available;
+    GLuint samples;
+    BOOL ret;
+
+#endif /* STAGING_CSMT */
     if (oq->context->tid != GetCurrentThreadId())
     {
         FIXME("%p Wrong thread, returning 1.\n", query);
+#if !defined(STAGING_CSMT)
         samples = 1;
         fill_query_data(data, size, &samples, sizeof(samples));
         return S_OK;
+#else  /* STAGING_CSMT */
+        oq->samples = 1;
+        return TRUE;
+#endif /* STAGING_CSMT */
     }
 
     context = context_acquire(device, context_get_rt_surface(oq->context));
@@ -395,6 +458,7 @@ static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
 
     if (available)
     {
+#if !defined(STAGING_CSMT)
         if (size)
         {
             GL_EXTCALL(glGetQueryObjectuiv(oq->id, GL_QUERY_RESULT, &samples));
@@ -403,34 +467,55 @@ static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
             fill_query_data(data, size, &samples, sizeof(samples));
         }
         res = S_OK;
+#else  /* STAGING_CSMT */
+        GL_EXTCALL(glGetQueryObjectuiv(oq->id, GL_QUERY_RESULT, &samples));
+        checkGLcall("glGetQueryObjectuiv(GL_QUERY_RESULT)");
+        TRACE("Returning %d samples.\n", samples);
+        oq->samples = samples;
+        ret = TRUE;
+#endif /* STAGING_CSMT */
     }
     else
     {
+#if !defined(STAGING_CSMT)
         res = S_FALSE;
+#else  /* STAGING_CSMT */
+        ret = FALSE;
+#endif /* STAGING_CSMT */
     }
 
     context_release(context);
 
+#if !defined(STAGING_CSMT)
     return res;
 }
 
 static HRESULT wined3d_event_query_ops_get_data(struct wined3d_query *query,
         void *data, DWORD size, DWORD flags)
+#else  /* STAGING_CSMT */
+    return ret;
+}
+
+static BOOL wined3d_event_query_ops_poll(struct wined3d_query *query)
+#endif /* STAGING_CSMT */
 {
     struct wined3d_event_query *event_query = wined3d_event_query_from_query(query);
     enum wined3d_event_query_result ret;
+#if !defined(STAGING_CSMT)
     BOOL signaled;
 
     TRACE("query %p, data %p, size %#x, flags %#x.\n", query, data, size, flags);
 
     if (!data || !size)
         return S_OK;
+#endif /* STAGING_CSMT */
 
     ret = wined3d_event_query_test(event_query, query->device);
     switch(ret)
     {
         case WINED3D_EVENT_QUERY_OK:
         case WINED3D_EVENT_QUERY_NOT_STARTED:
+#if !defined(STAGING_CSMT)
             signaled = TRUE;
             fill_query_data(data, size, &signaled, sizeof(signaled));
             break;
@@ -439,17 +524,58 @@ static HRESULT wined3d_event_query_ops_get_data(struct wined3d_query *query,
             signaled = FALSE;
             fill_query_data(data, size, &signaled, sizeof(signaled));
             break;
+#else  /* STAGING_CSMT */
+            return TRUE;
+
+        case WINED3D_EVENT_QUERY_WAITING:
+            return FALSE;
+#endif /* STAGING_CSMT */
 
         case WINED3D_EVENT_QUERY_WRONG_THREAD:
             FIXME("(%p) Wrong thread, reporting GPU idle.\n", query);
+#if !defined(STAGING_CSMT)
             signaled = TRUE;
             fill_query_data(data, size, &signaled, sizeof(signaled));
             break;
+#else  /* STAGING_CSMT */
+            return TRUE;
+#endif /* STAGING_CSMT */
 
         case WINED3D_EVENT_QUERY_ERROR:
             ERR("The GL event query failed, returning D3DERR_INVALIDCALL\n");
+#if !defined(STAGING_CSMT)
             return WINED3DERR_INVALIDCALL;
     }
+#else  /* STAGING_CSMT */
+            return TRUE;
+
+        default:
+            ERR("Unexpected wined3d_event_query_test result %u\n", ret);
+            return TRUE;
+    }
+}
+
+static HRESULT wined3d_event_query_ops_get_data(struct wined3d_query *query,
+        void *pData, DWORD dwSize, DWORD flags)
+{
+    BOOL *data = pData;
+    enum wined3d_event_query_result ret;
+
+    TRACE("query %p, pData %p, dwSize %#x, flags %#x.\n", query, pData, dwSize, flags);
+
+    if (!pData || !dwSize)
+        return S_OK;
+
+    if (!wined3d_settings.cs_multithreaded)
+        ret = query->query_ops->query_poll(query);
+    else if (query->counter_main != query->counter_retrieved)
+        ret = FALSE;
+    else
+        ret = TRUE;
+
+    if (data)
+        fill_query_data(data, dwSize, &ret, sizeof(ret));
+#endif /* STAGING_CSMT */
 
     return S_OK;
 }
@@ -468,7 +594,11 @@ enum wined3d_query_type CDECL wined3d_query_get_type(const struct wined3d_query
     return query->type;
 }
 
+#if !defined(STAGING_CSMT)
 static HRESULT wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD flags)
+#else  /* STAGING_CSMT */
+static BOOL wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD flags)
+#endif /* STAGING_CSMT */
 {
     TRACE("query %p, flags %#x.\n", query, flags);
 
@@ -477,12 +607,16 @@ static HRESULT wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD
         struct wined3d_event_query *event_query = wined3d_event_query_from_query(query);
 
         wined3d_event_query_issue(event_query, query->device);
+#if defined(STAGING_CSMT)
+        return TRUE;
+#endif /* STAGING_CSMT */
     }
     else if (flags & WINED3DISSUE_BEGIN)
     {
         /* Started implicitly at query creation. */
         ERR("Event query issued with START flag - what to do?\n");
     }
+#if !defined(STAGING_CSMT)
 
     if (flags & WINED3DISSUE_BEGIN)
         query->state = QUERY_BUILDING;
@@ -493,11 +627,20 @@ static HRESULT wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD
 }
 
 static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD flags)
+#else  /* STAGING_CSMT */
+    return FALSE;
+}
+
+static BOOL wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD flags)
+#endif /* STAGING_CSMT */
 {
     struct wined3d_occlusion_query *oq = wined3d_occlusion_query_from_query(query);
     struct wined3d_device *device = query->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     struct wined3d_context *context;
+#if defined(STAGING_CSMT)
+    BOOL poll = FALSE;
+#endif /* STAGING_CSMT */
 
     TRACE("query %p, flags %#x.\n", query, flags);
 
@@ -505,7 +648,11 @@ static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DW
      * restart. */
     if (flags & WINED3DISSUE_BEGIN)
     {
+#if !defined(STAGING_CSMT)
         if (query->state == QUERY_BUILDING)
+#else  /* STAGING_CSMT */
+        if (oq->started)
+#endif /* STAGING_CSMT */
         {
             if (oq->context->tid != GetCurrentThreadId())
             {
@@ -535,13 +682,20 @@ static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DW
         checkGLcall("glBeginQuery()");
 
         context_release(context);
+#if defined(STAGING_CSMT)
+        oq->started = TRUE;
+#endif /* STAGING_CSMT */
     }
     if (flags & WINED3DISSUE_END)
     {
         /* MSDN says END on a non-building occlusion query returns an error,
          * but our tests show that it returns OK. But OpenGL doesn't like it,
          * so avoid generating an error. */
+#if !defined(STAGING_CSMT)
         if (query->state == QUERY_BUILDING)
+#else  /* STAGING_CSMT */
+        if (oq->started)
+#endif /* STAGING_CSMT */
         {
             if (oq->context->tid != GetCurrentThreadId())
             {
@@ -555,6 +709,7 @@ static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DW
                 checkGLcall("glEndQuery()");
 
                 context_release(context);
+#if !defined(STAGING_CSMT)
             }
         }
     }
@@ -565,17 +720,61 @@ static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DW
         query->state = QUERY_SIGNALLED;
 
     return WINED3D_OK; /* can be WINED3DERR_INVALIDCALL.    */
+#else  /* STAGING_CSMT */
+                poll = TRUE;
+            }
+        }
+        oq->started = FALSE;
+    }
+
+    return poll;
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT wined3d_timestamp_query_ops_get_data(struct wined3d_query *query,
         void *data, DWORD size, DWORD flags)
 {
     struct wined3d_timestamp_query *tq = wined3d_timestamp_query_from_query(query);
+#if defined(STAGING_CSMT)
+
+    TRACE("(%p) : type D3DQUERY_TIMESTAMP, data %p, size %#x, flags %#x.\n", query, data, size, flags);
+
+    if (query->state == QUERY_CREATED)
+    {
+        UINT64 zero = 0;
+        /* D3D allows GetData on a new query, OpenGL doesn't. So just invent the data ourselves */
+        TRACE("Query wasn't yet started, returning S_OK.\n");
+        if (data)
+            fill_query_data(data, size, &zero, sizeof(zero));
+        return S_OK;
+    }
+
+    if (!wined3d_settings.cs_multithreaded)
+    {
+        if (!query->query_ops->query_poll(query))
+            return S_FALSE;
+    }
+    else if (query->counter_main != query->counter_retrieved)
+    {
+        return S_FALSE;
+    }
+
+    if (data)
+        fill_query_data(data, size, &tq->timestamp, sizeof(tq->timestamp));
+
+    return S_OK;
+}
+
+static BOOL wined3d_timestamp_query_ops_poll(struct wined3d_query *query)
+{
+    struct wined3d_timestamp_query *tq = wined3d_timestamp_query_from_query(query);
+#endif /* STAGING_CSMT */
     struct wined3d_device *device = query->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     struct wined3d_context *context;
     GLuint available;
     GLuint64 timestamp;
+#if !defined(STAGING_CSMT)
     HRESULT res;
 
     TRACE("query %p, data %p, size %#x, flags %#x.\n", query, data, size, flags);
@@ -590,14 +789,28 @@ static HRESULT wined3d_timestamp_query_ops_get_data(struct wined3d_query *query,
         timestamp = 0;
         fill_query_data(data, size, &timestamp, sizeof(timestamp));
         return S_OK;
+#else  /* STAGING_CSMT */
+    BOOL ret;
+
+    if (!gl_info->supported[ARB_TIMER_QUERY])
+    {
+        TRACE("Faking timestamp.\n");
+        QueryPerformanceCounter((LARGE_INTEGER *)&tq->timestamp);
+        return TRUE;
+#endif /* STAGING_CSMT */
     }
 
     if (tq->context->tid != GetCurrentThreadId())
     {
         FIXME("%p Wrong thread, returning 1.\n", query);
+#if !defined(STAGING_CSMT)
         timestamp = 1;
         fill_query_data(data, size, &timestamp, sizeof(timestamp));
         return S_OK;
+#else  /* STAGING_CSMT */
+        tq->timestamp = 1;
+        return TRUE;
+#endif /* STAGING_CSMT */
     }
 
     context = context_acquire(device, context_get_rt_surface(tq->context));
@@ -608,6 +821,7 @@ static HRESULT wined3d_timestamp_query_ops_get_data(struct wined3d_query *query,
 
     if (available)
     {
+#if !defined(STAGING_CSMT)
         if (size)
         {
             GL_EXTCALL(glGetQueryObjectui64v(tq->id, GL_QUERY_RESULT, &timestamp));
@@ -616,18 +830,36 @@ static HRESULT wined3d_timestamp_query_ops_get_data(struct wined3d_query *query,
             fill_query_data(data, size, &timestamp, sizeof(timestamp));
         }
         res = S_OK;
+#else  /* STAGING_CSMT */
+        GL_EXTCALL(glGetQueryObjectui64v(tq->id, GL_QUERY_RESULT, &timestamp));
+        checkGLcall("glGetQueryObjectui64v(GL_QUERY_RESULT)");
+        TRACE("Returning timestamp %s.\n", wine_dbgstr_longlong(timestamp));
+        tq->timestamp = timestamp;
+        ret = TRUE;
+#endif /* STAGING_CSMT */
     }
     else
     {
+#if !defined(STAGING_CSMT)
         res = S_FALSE;
+#else  /* STAGING_CSMT */
+        ret = FALSE;
+#endif /* STAGING_CSMT */
     }
 
     context_release(context);
 
+#if !defined(STAGING_CSMT)
     return res;
 }
 
 static HRESULT wined3d_timestamp_query_ops_issue(struct wined3d_query *query, DWORD flags)
+#else  /* STAGING_CSMT */
+    return ret;
+}
+
+static BOOL wined3d_timestamp_query_ops_issue(struct wined3d_query *query, DWORD flags)
+#endif /* STAGING_CSMT */
 {
     struct wined3d_timestamp_query *tq = wined3d_timestamp_query_from_query(query);
     struct wined3d_device *device = query->device;
@@ -649,18 +881,28 @@ static HRESULT wined3d_timestamp_query_ops_issue(struct wined3d_query *query, DW
         GL_EXTCALL(glQueryCounter(tq->id, GL_TIMESTAMP));
         checkGLcall("glQueryCounter()");
         context_release(context);
+#if !defined(STAGING_CSMT)
 
         query->state = QUERY_SIGNALLED;
     }
 
     return WINED3D_OK;
+#else  /* STAGING_CSMT */
+    }
+
+    if (flags & WINED3DISSUE_END)
+        return TRUE;
+    return FALSE;
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT wined3d_timestamp_disjoint_query_ops_get_data(struct wined3d_query *query,
         void *data, DWORD size, DWORD flags)
 {
     TRACE("query %p, data %p, size %#x, flags %#x.\n", query, data, size, flags);
+#if !defined(STAGING_CSMT)
 
+#endif /* STAGING_CSMT */
     if (query->type == WINED3D_QUERY_TYPE_TIMESTAMP_DISJOINT)
     {
         static const struct wined3d_query_data_timestamp_disjoint disjoint_data = {1000 * 1000 * 1000, FALSE};
@@ -682,6 +924,7 @@ static HRESULT wined3d_timestamp_disjoint_query_ops_get_data(struct wined3d_quer
     return S_OK;
 }
 
+#if !defined(STAGING_CSMT)
 static HRESULT wined3d_timestamp_disjoint_query_ops_issue(struct wined3d_query *query, DWORD flags)
 {
     TRACE("query %p, flags %#x.\n", query, flags);
@@ -692,6 +935,17 @@ static HRESULT wined3d_timestamp_disjoint_query_ops_issue(struct wined3d_query *
         query->state = QUERY_SIGNALLED;
 
     return WINED3D_OK;
+#else  /* STAGING_CSMT */
+static BOOL wined3d_timestamp_disjoint_query_ops_poll(struct wined3d_query *query)
+{
+    return TRUE;
+}
+
+static BOOL wined3d_timestamp_disjoint_query_ops_issue(struct wined3d_query *query, DWORD flags)
+{
+    TRACE("query %p, flags %#x.\n", query, flags);
+    return FALSE;
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT wined3d_statistics_query_ops_get_data(struct wined3d_query *query,
@@ -706,10 +960,22 @@ static HRESULT wined3d_statistics_query_ops_get_data(struct wined3d_query *query
     return S_OK;
 }
 
+#if !defined(STAGING_CSMT)
 static HRESULT wined3d_statistics_query_ops_issue(struct wined3d_query *query, DWORD flags)
 {
     FIXME("query %p, flags %#x.\n", query, flags);
     return WINED3D_OK;
+#else  /* STAGING_CSMT */
+static BOOL wined3d_statistics_query_ops_poll(struct wined3d_query *query)
+{
+    return TRUE;
+}
+
+static BOOL wined3d_statistics_query_ops_issue(struct wined3d_query *query, DWORD flags)
+{
+    FIXME("query %p, flags %#x.\n", query, flags);
+    return FALSE;
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT wined3d_overflow_query_ops_get_data(struct wined3d_query *query,
@@ -724,15 +990,30 @@ static HRESULT wined3d_overflow_query_ops_get_data(struct wined3d_query *query,
     return S_OK;
 }
 
+#if !defined(STAGING_CSMT)
 static HRESULT wined3d_overflow_query_ops_issue(struct wined3d_query *query, DWORD flags)
 {
     FIXME("query %p, flags %#x.\n", query, flags);
     return WINED3D_OK;
+#else  /* STAGING_CSMT */
+static BOOL wined3d_overflow_query_ops_poll(struct wined3d_query *query)
+{
+    return TRUE;
+}
+
+static BOOL wined3d_overflow_query_ops_issue(struct wined3d_query *query, DWORD flags)
+{
+    FIXME("query %p, flags %#x.\n", query, flags);
+    return FALSE;
+#endif /* STAGING_CSMT */
 }
 
 static const struct wined3d_query_ops event_query_ops =
 {
     wined3d_event_query_ops_get_data,
+#if defined(STAGING_CSMT)
+    wined3d_event_query_ops_poll,
+#endif /* STAGING_CSMT */
     wined3d_event_query_ops_issue,
 };
 
@@ -764,6 +1045,9 @@ static HRESULT wined3d_event_query_create(struct wined3d_device *device,
 static const struct wined3d_query_ops occlusion_query_ops =
 {
     wined3d_occlusion_query_ops_get_data,
+#if defined(STAGING_CSMT)
+    wined3d_occlusion_query_ops_poll,
+#endif /* STAGING_CSMT */
     wined3d_occlusion_query_ops_issue,
 };
 
@@ -795,6 +1079,9 @@ static HRESULT wined3d_occlusion_query_create(struct wined3d_device *device,
 static const struct wined3d_query_ops timestamp_query_ops =
 {
     wined3d_timestamp_query_ops_get_data,
+#if defined(STAGING_CSMT)
+    wined3d_timestamp_query_ops_poll,
+#endif /* STAGING_CSMT */
     wined3d_timestamp_query_ops_issue,
 };
 
@@ -826,6 +1113,9 @@ static HRESULT wined3d_timestamp_query_create(struct wined3d_device *device,
 static const struct wined3d_query_ops timestamp_disjoint_query_ops =
 {
     wined3d_timestamp_disjoint_query_ops_get_data,
+#if defined(STAGING_CSMT)
+    wined3d_timestamp_disjoint_query_ops_poll,
+#endif /* STAGING_CSMT */
     wined3d_timestamp_disjoint_query_ops_issue,
 };
 
@@ -861,6 +1151,9 @@ static HRESULT wined3d_timestamp_disjoint_query_create(struct wined3d_device *de
 static const struct wined3d_query_ops statistics_query_ops =
 {
     wined3d_statistics_query_ops_get_data,
+#if defined(STAGING_CSMT)
+    wined3d_statistics_query_ops_poll,
+#endif /* STAGING_CSMT */
     wined3d_statistics_query_ops_issue,
 };
 
@@ -886,6 +1179,9 @@ static HRESULT wined3d_statistics_query_create(struct wined3d_device *device,
 static const struct wined3d_query_ops overflow_query_ops =
 {
     wined3d_overflow_query_ops_get_data,
+#if defined(STAGING_CSMT)
+    wined3d_overflow_query_ops_poll,
+#endif /* STAGING_CSMT */
     wined3d_overflow_query_ops_issue,
 };
 
diff --git a/dlls/wined3d/resource.c b/dlls/wined3d/resource.c
--- a/dlls/wined3d/resource.c
+++ b/dlls/wined3d/resource.c
@@ -213,6 +213,9 @@ HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *
             ERR("Failed to allocate system memory.\n");
             return E_OUTOFMEMORY;
         }
+#if defined(STAGING_CSMT)
+        resource->heap_memory = resource->map_heap_memory;
+#endif /* STAGING_CSMT */
     }
     else
     {
@@ -241,6 +244,9 @@ static void wined3d_resource_destroy_object(void *object)
     struct wined3d_resource *resource = object;
 
     wined3d_resource_free_sysmem(resource);
+#if defined(STAGING_CSMT)
+    resource->map_heap_memory = NULL;
+#endif /* STAGING_CSMT */
     context_resource_released(resource->device, resource, resource->type);
     wined3d_resource_release(resource);
 }
@@ -342,7 +348,11 @@ BOOL wined3d_resource_allocate_sysmem(struct wined3d_resource *resource)
     p = (void **)(((ULONG_PTR)mem + align) & ~(RESOURCE_ALIGNMENT - 1)) - 1;
     *p = mem;
 
+#if !defined(STAGING_CSMT)
     resource->heap_memory = ++p;
+#else  /* STAGING_CSMT */
+    resource->map_heap_memory = ++p;
+#endif /* STAGING_CSMT */
 
     return TRUE;
 }
diff --git a/dlls/wined3d/sampler.c b/dlls/wined3d/sampler.c
--- a/dlls/wined3d/sampler.c
+++ b/dlls/wined3d/sampler.c
@@ -66,22 +66,31 @@ void * CDECL wined3d_sampler_get_parent(const struct wined3d_sampler *sampler)
     return sampler->parent;
 }
 
+#if !defined(STAGING_CSMT)
 static void wined3d_sampler_init(struct wined3d_sampler *sampler, struct wined3d_device *device,
         const struct wined3d_sampler_desc *desc, void *parent)
+#else  /* STAGING_CSMT */
+void wined3d_sampler_init(struct wined3d_sampler *sampler)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
 
+#if !defined(STAGING_CSMT)
     sampler->refcount = 1;
     sampler->device = device;
     sampler->parent = parent;
     sampler->desc = *desc;
 
     context = context_acquire(device, NULL);
+#else  /* STAGING_CSMT */
+    context = context_acquire(sampler->device, NULL);
+#endif /* STAGING_CSMT */
     gl_info = context->gl_info;
 
     GL_EXTCALL(glGenSamplers(1, &sampler->name));
     GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_WRAP_S,
+#if !defined(STAGING_CSMT)
             gl_info->wrap_lookup[desc->address_u - WINED3D_TADDRESS_WRAP]));
     GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_WRAP_T,
             gl_info->wrap_lookup[desc->address_v - WINED3D_TADDRESS_WRAP]));
@@ -103,6 +112,29 @@ static void wined3d_sampler_init(struct wined3d_sampler *sampler, struct wined3d
             wined3d_gl_compare_func(desc->comparison_func)));
     if ((context->d3d_info->wined3d_creation_flags & WINED3D_SRGB_READ_WRITE_CONTROL)
             && gl_info->supported[EXT_TEXTURE_SRGB_DECODE] && !desc->srgb_decode)
+#else  /* STAGING_CSMT */
+            gl_info->wrap_lookup[sampler->desc.address_u - WINED3D_TADDRESS_WRAP]));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_WRAP_T,
+            gl_info->wrap_lookup[sampler->desc.address_v - WINED3D_TADDRESS_WRAP]));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_WRAP_R,
+            gl_info->wrap_lookup[sampler->desc.address_w - WINED3D_TADDRESS_WRAP]));
+    GL_EXTCALL(glSamplerParameterfv(sampler->name, GL_TEXTURE_BORDER_COLOR, &sampler->desc.border_color[0]));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_MAG_FILTER,
+            wined3d_gl_mag_filter(sampler->desc.mag_filter)));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_MIN_FILTER,
+            wined3d_gl_min_mip_filter(sampler->desc.min_filter, sampler->desc.mip_filter)));
+    GL_EXTCALL(glSamplerParameterf(sampler->name, GL_TEXTURE_LOD_BIAS, sampler->desc.lod_bias));
+    GL_EXTCALL(glSamplerParameterf(sampler->name, GL_TEXTURE_MIN_LOD, sampler->desc.min_lod));
+    GL_EXTCALL(glSamplerParameterf(sampler->name, GL_TEXTURE_MAX_LOD, sampler->desc.max_lod));
+    if (gl_info->supported[EXT_TEXTURE_FILTER_ANISOTROPIC])
+        GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_MAX_ANISOTROPY_EXT, sampler->desc.max_anisotropy));
+    if (sampler->desc.compare)
+        GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_R_TO_TEXTURE));
+    GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_COMPARE_FUNC,
+            wined3d_gl_compare_func(sampler->desc.comparison_func)));
+    if ((context->d3d_info->wined3d_creation_flags & WINED3D_SRGB_READ_WRITE_CONTROL)
+            && gl_info->supported[EXT_TEXTURE_SRGB_DECODE] && !sampler->desc.srgb_decode)
+#endif /* STAGING_CSMT */
         GL_EXTCALL(glSamplerParameteri(sampler->name, GL_TEXTURE_SRGB_DECODE_EXT, GL_SKIP_DECODE_EXT));
     checkGLcall("sampler creation");
 
@@ -114,6 +146,14 @@ static void wined3d_sampler_init(struct wined3d_sampler *sampler, struct wined3d
 HRESULT CDECL wined3d_sampler_create(struct wined3d_device *device, const struct wined3d_sampler_desc *desc,
         void *parent, struct wined3d_sampler **sampler)
 {
+#if defined(STAGING_CSMT)
+    return wined3d_sampler_create_from_cs(device, desc, parent, sampler, FALSE);
+}
+
+HRESULT wined3d_sampler_create_from_cs(struct wined3d_device *device, const struct wined3d_sampler_desc *desc,
+        void *parent, struct wined3d_sampler **sampler, BOOL from_cs)
+{
+#endif /* STAGING_CSMT */
     struct wined3d_sampler *object;
 
     TRACE("device %p, desc %p, parent %p, sampler %p.\n", device, desc, parent, sampler);
@@ -134,7 +174,18 @@ HRESULT CDECL wined3d_sampler_create(struct wined3d_device *device, const struct
     if (!(object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object))))
         return E_OUTOFMEMORY;
 
+#if !defined(STAGING_CSMT)
     wined3d_sampler_init(object, device, desc, parent);
+#else  /* STAGING_CSMT */
+    object->refcount = 1;
+    object->device = device;
+    object->parent = parent;
+    object->desc = *desc;
+    if (from_cs)
+        wined3d_sampler_init(object);
+    else
+        wined3d_cs_emit_sampler_init(device->cs, object);
+#endif /* STAGING_CSMT */
 
     TRACE("Created sampler %p.\n", object);
     *sampler = object;
diff --git a/dlls/wined3d/shader.c b/dlls/wined3d/shader.c
--- a/dlls/wined3d/shader.c
+++ b/dlls/wined3d/shader.c
@@ -3052,7 +3052,11 @@ void find_ps_compile_args(const struct wined3d_state *state, const struct wined3
     UINT i;
 
     memset(args, 0, sizeof(*args)); /* FIXME: Make sure all bits are set. */
+#if !defined(STAGING_CSMT)
     if (!gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, state, state->fb))
+#else  /* STAGING_CSMT */
+    if (!gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, state, &state->fb))
+#endif /* STAGING_CSMT */
     {
         static unsigned int warned = 0;
 
diff --git a/dlls/wined3d/state.c b/dlls/wined3d/state.c
--- a/dlls/wined3d/state.c
+++ b/dlls/wined3d/state.c
@@ -105,7 +105,11 @@ static void state_zenable(struct wined3d_context *context, const struct wined3d_
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     /* No z test without depth stencil buffers */
+#if !defined(STAGING_CSMT)
     if (!state->fb->depth_stencil)
+#else  /* STAGING_CSMT */
+    if (!state->fb.depth_stencil)
+#endif /* STAGING_CSMT */
     {
         TRACE("No Z buffer - disabling depth test\n");
         zenable = WINED3D_ZB_FALSE;
@@ -382,14 +386,23 @@ static void state_blend(struct wined3d_context *context, const struct wined3d_st
     GLenum srcBlend, dstBlend;
     unsigned int rt_fmt_flags;
 
+#if !defined(STAGING_CSMT)
     if (!state->fb->render_targets[0])
+#else  /* STAGING_CSMT */
+    if (!state->fb.render_targets[0])
+#endif /* STAGING_CSMT */
     {
         gl_info->gl_ops.gl.p_glDisable(GL_BLEND);
         return;
     }
 
+#if !defined(STAGING_CSMT)
     rt_format = state->fb->render_targets[0]->format;
     rt_fmt_flags = state->fb->render_targets[0]->format_flags;
+#else  /* STAGING_CSMT */
+    rt_format = state->fb.render_targets[0]->format;
+    rt_fmt_flags = state->fb.render_targets[0]->format_flags;
+#endif /* STAGING_CSMT */
 
     /* According to the red book, GL_LINE_SMOOTH needs GL_BLEND with specific
      * blending parameters to work. */
@@ -823,7 +836,11 @@ static void state_stencil(struct wined3d_context *context, const struct wined3d_
     GLint depthFail_ccw;
 
     /* No stencil test without a stencil buffer. */
+#if !defined(STAGING_CSMT)
     if (!state->fb->depth_stencil)
+#else  /* STAGING_CSMT */
+    if (!state->fb.depth_stencil)
+#endif /* STAGING_CSMT */
     {
         gl_info->gl_ops.gl.p_glDisable(GL_STENCIL_TEST);
         checkGLcall("glDisable GL_STENCIL_TEST");
@@ -919,7 +936,11 @@ static void state_stencil(struct wined3d_context *context, const struct wined3d_
 
 static void state_stencilwrite2s(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
+#if !defined(STAGING_CSMT)
     DWORD mask = state->fb->depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+#else  /* STAGING_CSMT */
+    DWORD mask = state->fb.depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     GL_EXTCALL(glActiveStencilFaceEXT(GL_BACK));
@@ -933,7 +954,11 @@ static void state_stencilwrite2s(struct wined3d_context *context, const struct w
 
 static void state_stencilwrite(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
+#if !defined(STAGING_CSMT)
     DWORD mask = state->fb->depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+#else  /* STAGING_CSMT */
+    DWORD mask = state->fb.depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     gl_info->gl_ops.gl.p_glStencilMask(mask);
@@ -1671,7 +1696,11 @@ static void state_depthbias(struct wined3d_context *context, const struct wined3
     if (state->render_states[WINED3D_RS_SLOPESCALEDEPTHBIAS]
             || state->render_states[WINED3D_RS_DEPTHBIAS])
     {
+#if !defined(STAGING_CSMT)
         const struct wined3d_rendertarget_view *depth = state->fb->depth_stencil;
+#else  /* STAGING_CSMT */
+        const struct wined3d_rendertarget_view *depth = state->fb.depth_stencil;
+#endif /* STAGING_CSMT */
         float scale;
 
         union
@@ -3604,7 +3633,11 @@ static void sampler(struct wined3d_context *context, const struct wined3d_state
             }
             else
             {
+#if !defined(STAGING_CSMT)
                 if (FAILED(wined3d_sampler_create(device, &desc, NULL, &sampler)))
+#else  /* STAGING_CSMT */
+                if (FAILED(wined3d_sampler_create_from_cs(device, &desc, NULL, &sampler, TRUE)))
+#endif /* STAGING_CSMT */
                 {
                     ERR("Failed to create sampler.\n");
                     sampler = NULL;
@@ -4585,8 +4618,13 @@ static void vertexdeclaration(struct wined3d_context *context, const struct wine
 
 static void viewport_miscpart(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
+#if !defined(STAGING_CSMT)
     const struct wined3d_rendertarget_view *depth_stencil = state->fb->depth_stencil;
     const struct wined3d_rendertarget_view *target = state->fb->render_targets[0];
+#else  /* STAGING_CSMT */
+    const struct wined3d_rendertarget_view *depth_stencil = state->fb.depth_stencil;
+    const struct wined3d_rendertarget_view *target = state->fb.render_targets[0];
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info = context->gl_info;
     struct wined3d_viewport vp = state->viewport;
     unsigned int width, height;
@@ -4772,7 +4810,11 @@ static void scissorrect(struct wined3d_context *context, const struct wined3d_st
     }
     else
     {
+#if !defined(STAGING_CSMT)
         const struct wined3d_rendertarget_view *target = state->fb->render_targets[0];
+#else  /* STAGING_CSMT */
+        const struct wined3d_rendertarget_view *target = state->fb.render_targets[0];
+#endif /* STAGING_CSMT */
         UINT height;
         UINT width;
 
@@ -4840,7 +4882,11 @@ void state_srgbwrite(struct wined3d_context *context, const struct wined3d_state
 
     TRACE("context %p, state %p, state_id %#x.\n", context, state, state_id);
 
+#if !defined(STAGING_CSMT)
     if (needs_srgb_write(context, state, state->fb))
+#else  /* STAGING_CSMT */
+    if (needs_srgb_write(context, state, &state->fb))
+#endif /* STAGING_CSMT */
         gl_info->gl_ops.gl.p_glEnable(GL_FRAMEBUFFER_SRGB);
     else
         gl_info->gl_ops.gl.p_glDisable(GL_FRAMEBUFFER_SRGB);
diff --git a/dlls/wined3d/stateblock.c b/dlls/wined3d/stateblock.c
--- a/dlls/wined3d/stateblock.c
+++ b/dlls/wined3d/stateblock.c
@@ -430,6 +430,9 @@ void state_unbind_resources(struct wined3d_state *state)
     struct wined3d_texture *texture;
     struct wined3d_buffer *buffer;
     struct wined3d_shader *shader;
+#if defined(STAGING_CSMT)
+    struct wined3d_rendertarget_view *view;
+#endif /* STAGING_CSMT */
     unsigned int i, j;
 
     if ((decl = state->vertex_declaration))
@@ -506,6 +509,33 @@ void state_unbind_resources(struct wined3d_state *state)
             }
         }
     }
+#if defined(STAGING_CSMT)
+
+    if (state->fb.depth_stencil)
+    {
+        view = state->fb.depth_stencil;
+
+        TRACE("Releasing depth/stencil buffer %p.\n", view);
+
+        state->fb.depth_stencil = NULL;
+        wined3d_rendertarget_view_decref(view);
+    }
+
+    if (state->fb.render_targets)
+    {
+        for (i = 0; i < state->fb.rt_size; i++)
+        {
+            view = state->fb.render_targets[i];
+            TRACE("Setting rendertarget %u to NULL\n", i);
+            state->fb.render_targets[i] = NULL;
+            if (view)
+            {
+                TRACE("Releasing the rendertarget view at %p\n", view);
+                wined3d_rendertarget_view_decref(view);
+            }
+        }
+    }
+#endif /* STAGING_CSMT */
 }
 
 void state_cleanup(struct wined3d_state *state)
@@ -530,6 +560,10 @@ void state_cleanup(struct wined3d_state *state)
             HeapFree(GetProcessHeap(), 0, light);
         }
     }
+#if defined(STAGING_CSMT)
+
+    HeapFree(GetProcessHeap(), 0, state->fb.render_targets);
+#endif /* STAGING_CSMT */
 }
 
 ULONG CDECL wined3d_stateblock_decref(struct wined3d_stateblock *stateblock)
@@ -981,8 +1015,13 @@ void CDECL wined3d_stateblock_apply(const struct wined3d_stateblock *stateblock)
         gl_primitive_type = stateblock->state.gl_primitive_type;
         prev = device->update_state->gl_primitive_type;
         device->update_state->gl_primitive_type = gl_primitive_type;
+#if !defined(STAGING_CSMT)
         if (gl_primitive_type != prev && (gl_primitive_type == GL_POINTS || prev == GL_POINTS))
             device_invalidate_state(device, STATE_POINT_ENABLE);
+#else  /* STAGING_CSMT */
+        if (gl_primitive_type != prev)
+            wined3d_cs_emit_set_primitive_type(device->cs, gl_primitive_type);
+#endif /* STAGING_CSMT */
     }
 
     if (stateblock->changed.indices)
@@ -1241,35 +1280,77 @@ static void state_init_default(struct wined3d_state *state, const struct wined3d
         state->sampler_states[i][WINED3D_SAMP_ELEMENT_INDEX] = 0;
         /* TODO: Vertex offset in the presampled displacement map. */
         state->sampler_states[i][WINED3D_SAMP_DMAP_OFFSET] = 0;
+#if !defined(STAGING_CSMT)
     }
 }
 
 void state_init(struct wined3d_state *state, struct wined3d_fb_state *fb,
         const struct wined3d_gl_info *gl_info, const struct wined3d_d3d_info *d3d_info,
         DWORD flags)
+#else  /* STAGING_CSMT */
+        state->textures[i] = NULL;
+    }
+
+    state->index_buffer = NULL;
+    for (i = 0; i < sizeof(state->streams) / sizeof(*state->streams); i++)
+        memset(&state->streams[i], 0, sizeof(state->streams[i]));
+
+    state->shader[WINED3D_SHADER_TYPE_VERTEX] = NULL;
+    state->shader[WINED3D_SHADER_TYPE_PIXEL] = NULL;
+}
+
+HRESULT state_init(struct wined3d_state *state, const struct wined3d_gl_info *gl_info,
+        const struct wined3d_d3d_info *d3d_info, DWORD flags)
+#endif /* STAGING_CSMT */
 {
     unsigned int i;
 
     state->flags = flags;
+#if !defined(STAGING_CSMT)
     state->fb = fb;
+#endif /* STAGING_CSMT */
 
     for (i = 0; i < LIGHTMAP_SIZE; i++)
     {
         list_init(&state->light_map[i]);
     }
 
+#if !defined(STAGING_CSMT)
+    if (flags & WINED3D_STATE_INIT_DEFAULT)
+        state_init_default(state, gl_info);
+#else  /* STAGING_CSMT */
+    state->fb.rt_size = gl_info->limits.buffers;
+    if (!(state->fb.render_targets = wined3d_calloc(state->fb.rt_size,
+            sizeof(*state->fb.render_targets))))
+        return E_OUTOFMEMORY;
+
     if (flags & WINED3D_STATE_INIT_DEFAULT)
         state_init_default(state, gl_info);
+
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT stateblock_init(struct wined3d_stateblock *stateblock,
         struct wined3d_device *device, enum wined3d_stateblock_type type)
 {
+#if !defined(STAGING_CSMT)
+    const struct wined3d_d3d_info *d3d_info = &device->adapter->d3d_info;
+#else  /* STAGING_CSMT */
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     const struct wined3d_d3d_info *d3d_info = &device->adapter->d3d_info;
+    HRESULT hr;
+#endif /* STAGING_CSMT */
 
     stateblock->ref = 1;
     stateblock->device = device;
+#if !defined(STAGING_CSMT)
     state_init(&stateblock->state, NULL, &device->adapter->gl_info, d3d_info, 0);
+#else  /* STAGING_CSMT */
+
+    if (FAILED(hr = state_init(&stateblock->state, gl_info, d3d_info, 0)))
+        return hr;
+#endif /* STAGING_CSMT */
 
     if (type == WINED3D_SBT_RECORDED)
         return WINED3D_OK;
diff --git a/dlls/wined3d/surface.c b/dlls/wined3d/surface.c
--- a/dlls/wined3d/surface.c
+++ b/dlls/wined3d/surface.c
@@ -36,6 +36,13 @@ WINE_DECLARE_DEBUG_CHANNEL(d3d_perf);
 static const DWORD surface_simple_locations = WINED3D_LOCATION_SYSMEM
         | WINED3D_LOCATION_USER_MEMORY | WINED3D_LOCATION_BUFFER;
 
+#if defined(STAGING_CSMT)
+static HRESULT surface_cpu_blt(struct wined3d_texture *dst_texture, unsigned int dst_sub_resource_idx,
+        const struct wined3d_box *dst_box, struct wined3d_texture *src_texture, unsigned int src_sub_resource_idx,
+        const struct wined3d_box *src_box, DWORD flags, const struct wined3d_blt_fx *fx,
+        enum wined3d_texture_filter_type filter);
+
+#endif /* STAGING_CSMT */
 void surface_get_drawable_size(const struct wined3d_surface *surface, const struct wined3d_context *context,
         unsigned int *width, unsigned int *height)
 {
@@ -319,7 +326,11 @@ void wined3d_surface_destroy_dc(struct wined3d_surface *surface)
         gl_info = context->gl_info;
     }
 
+#if !defined(STAGING_CSMT)
     wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding);
+#else  /* STAGING_CSMT */
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding, FALSE);
+#endif /* STAGING_CSMT */
     wined3d_texture_unmap_bo_address(&data, gl_info, GL_PIXEL_UNPACK_BUFFER);
 
     if (context)
@@ -355,7 +366,11 @@ HRESULT wined3d_surface_create_dc(struct wined3d_surface *surface)
         gl_info = context->gl_info;
     }
 
+#if !defined(STAGING_CSMT)
     wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding);
+#else  /* STAGING_CSMT */
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding, FALSE);
+#endif /* STAGING_CSMT */
     desc.pMemory = wined3d_texture_map_bo_address(&data, texture->sub_resources[sub_resource_idx].size,
             gl_info, GL_PIXEL_UNPACK_BUFFER, 0);
 
@@ -450,9 +465,17 @@ static void surface_depth_blt_fbo(const struct wined3d_device *device,
 
     /* Make sure the locations are up-to-date. Loading the destination
      * surface isn't required if the entire surface is overwritten. */
+#if !defined(STAGING_CSMT)
     surface_load_location(src_surface, context, src_location);
     if (!surface_is_full_rect(dst_surface, dst_rect))
         surface_load_location(dst_surface, context, dst_location);
+#else  /* STAGING_CSMT */
+    wined3d_texture_load_location(src_surface->container, surface_get_sub_resource_idx(src_surface),
+            context, src_location);
+    if (!surface_is_full_rect(dst_surface, dst_rect))
+        wined3d_texture_load_location(dst_surface->container, surface_get_sub_resource_idx(dst_surface),
+                context, dst_location);
+#endif /* STAGING_CSMT */
     else
         wined3d_texture_prepare_location(dst_texture, dst_sub_resource_idx, context, dst_location);
 
@@ -546,9 +569,17 @@ static void surface_blt_fbo(const struct wined3d_device *device,
      * surface isn't required if the entire surface is overwritten. (And is
      * in fact harmful if we're being called by surface_load_location() with
      * the purpose of loading the destination surface.) */
+#if !defined(STAGING_CSMT)
     surface_load_location(src_surface, old_ctx, src_location);
     if (!surface_is_full_rect(dst_surface, &dst_rect))
         surface_load_location(dst_surface, old_ctx, dst_location);
+#else  /* STAGING_CSMT */
+    wined3d_texture_load_location(src_surface->container, surface_get_sub_resource_idx(src_surface),
+            old_ctx, src_location);
+    if (!surface_is_full_rect(dst_surface, &dst_rect))
+        wined3d_texture_load_location(dst_surface->container, surface_get_sub_resource_idx(dst_surface),
+                                      old_ctx, dst_location);
+#endif /* STAGING_CSMT */
     else
         wined3d_texture_prepare_location(dst_texture, dst_sub_resource_idx, old_ctx, dst_location);
 
@@ -619,7 +650,12 @@ static void surface_blt_fbo(const struct wined3d_device *device,
             dst_rect.left, dst_rect.top, dst_rect.right, dst_rect.bottom, GL_COLOR_BUFFER_BIT, gl_filter);
     checkGLcall("glBlitFramebuffer()");
 
+#if !defined(STAGING_CSMT)
     if (wined3d_settings.strict_draw_ordering || (dst_location == WINED3D_LOCATION_DRAWABLE
+#else  /* STAGING_CSMT */
+    if (wined3d_settings.strict_draw_ordering
+            || (dst_location == WINED3D_LOCATION_DRAWABLE
+#endif /* STAGING_CSMT */
             && dst_texture->swapchain->front_buffer == dst_texture))
         gl_info->gl_ops.gl.p_glFlush();
 
@@ -708,8 +744,12 @@ static HRESULT wined3d_surface_depth_fill(struct wined3d_surface *surface, const
 {
     struct wined3d_resource *resource = &surface->container->resource;
     struct wined3d_device *device = resource->device;
+#if !defined(STAGING_CSMT)
     struct wined3d_rendertarget_view_desc view_desc;
     struct wined3d_rendertarget_view *view;
+#else  /* STAGING_CSMT */
+    struct wined3d_rendertarget_view view;
+#endif /* STAGING_CSMT */
     const struct blit_shader *blitter;
     HRESULT hr;
 
@@ -720,6 +760,7 @@ static HRESULT wined3d_surface_depth_fill(struct wined3d_surface *surface, const
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     view_desc.format_id = resource->format->id;
     view_desc.u.texture.level_idx = surface->texture_level;
     view_desc.u.texture.layer_idx = surface->texture_layer;
@@ -733,6 +774,19 @@ static HRESULT wined3d_surface_depth_fill(struct wined3d_surface *surface, const
 
     hr = blitter->depth_fill(device, view, rect, WINED3DCLEAR_ZBUFFER, depth, 0);
     wined3d_rendertarget_view_decref(view);
+#else  /* STAGING_CSMT */
+    view.resource = resource;
+    view.parent = NULL;
+    view.parent_ops = &wined3d_null_parent_ops;
+    view.format = resource->format;
+    view.buffer_offset = 0;
+    view.width = wined3d_texture_get_level_width(surface->container, surface->texture_level);
+    view.height = wined3d_texture_get_level_height(surface->container, surface->texture_level);;
+    view.depth = 1;
+    view.sub_resource_idx = surface->texture_layer * surface->container->level_count + surface->texture_level;
+
+    hr = blitter->depth_fill(device, &view, rect, WINED3DCLEAR_ZBUFFER, depth, 0);
+#endif /* STAGING_CSMT */
 
     return hr;
 }
@@ -797,7 +851,11 @@ static void surface_download_data(struct wined3d_surface *surface, const struct
         }
     }
 
+#if !defined(STAGING_CSMT)
     wined3d_texture_get_memory(texture, sub_resource_idx, &data, dst_location);
+#else  /* STAGING_CSMT */
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, dst_location, FALSE);
+#endif /* STAGING_CSMT */
 
     if (texture->flags & WINED3D_TEXTURE_COND_NP2_EMULATED)
     {
@@ -1175,9 +1233,22 @@ HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const P
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     /* Use wined3d_surface_blt() instead of uploading directly if we need conversion. */
     if (dst_format->convert || wined3d_format_get_color_key_conversion(dst_texture, FALSE))
         return wined3d_surface_blt(dst_surface, &dst_rect, src_surface, src_rect, 0, NULL, WINED3D_TEXF_POINT);
+#else  /* STAGING_CSMT */
+    /* Use surface_cpu_blt() instead of uploading directly if we need
+     * conversion. Avoid calling wined3d_surface_blt() since that goes
+     * through the CS. */
+    if (dst_format->convert || wined3d_format_get_color_key_conversion(dst_texture, FALSE))
+    {
+        const struct wined3d_box dst_box = {dst_rect.left, dst_rect.top, dst_rect.right, dst_rect.bottom, 0, 1};
+        const struct wined3d_box src_box = {src_rect->left, src_rect->top, src_rect->right, src_rect->bottom, 0, 1};
+        return surface_cpu_blt(dst_texture, dst_sub_resource_idx, &dst_box, src_texture,
+                src_sub_resource_idx, &src_box, 0, NULL, WINED3D_TEXF_POINT);
+    }
+#endif /* STAGING_CSMT */
 
     context = context_acquire(dst_texture->resource.device, NULL);
     gl_info = context->gl_info;
@@ -1188,11 +1259,19 @@ HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const P
     if (update_w == dst_w && update_h == dst_h)
         wined3d_texture_prepare_texture(dst_texture, context, FALSE);
     else
+#if !defined(STAGING_CSMT)
         surface_load_location(dst_surface, context, WINED3D_LOCATION_TEXTURE_RGB);
+#else  /* STAGING_CSMT */
+        wined3d_texture_load_location(dst_texture, dst_sub_resource_idx, context, WINED3D_LOCATION_TEXTURE_RGB);
+#endif /* STAGING_CSMT */
     wined3d_texture_bind_and_dirtify(dst_texture, context, FALSE);
 
     wined3d_texture_get_memory(src_texture, src_sub_resource_idx, &data,
+#if !defined(STAGING_CSMT)
             src_texture->sub_resources[src_sub_resource_idx].locations);
+#else  /* STAGING_CSMT */
+            src_texture->sub_resources[src_sub_resource_idx].locations, FALSE);
+#endif /* STAGING_CSMT */
     wined3d_texture_get_pitch(src_texture, src_surface->texture_level, &src_row_pitch, &src_slice_pitch);
 
     wined3d_surface_upload_data(dst_surface, gl_info, src_format, src_rect,
@@ -1693,11 +1772,22 @@ static struct wined3d_texture *surface_convert_format(struct wined3d_texture *sr
 {
     unsigned int texture_level = sub_resource_idx % src_texture->level_count;
     const struct wined3d_format *src_format = src_texture->resource.format;
+#if !defined(STAGING_CSMT)
     struct wined3d_device *device = src_texture->resource.device;
     const struct d3dfmt_converter_desc *conv = NULL;
     struct wined3d_texture *dst_texture;
     struct wined3d_resource_desc desc;
     struct wined3d_map_desc src_map;
+#else  /* STAGING_CSMT */
+    void *dst_data = NULL, *src_data = NULL;
+    UINT src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch;
+    const struct d3dfmt_converter_desc *conv;
+    struct wined3d_texture *dst_texture;
+    struct wined3d_resource_desc desc;
+    struct wined3d_context *context = NULL;
+    struct wined3d_device *device = src_texture->resource.device;
+    struct wined3d_bo_address src_bo_addr;
+#endif /* STAGING_CSMT */
 
     if (!(conv = find_converter(src_format->id, dst_format->id)) && (!device->d3d_initialized
             || !is_identity_fixup(src_format->color_fixup) || src_format->convert
@@ -1727,6 +1817,7 @@ static struct wined3d_texture *surface_convert_format(struct wined3d_texture *sr
         return NULL;
     }
 
+#if !defined(STAGING_CSMT)
     memset(&src_map, 0, sizeof(src_map));
     if (FAILED(wined3d_resource_map(&src_texture->resource, sub_resource_idx,
             &src_map, NULL, WINED3D_MAP_READONLY)))
@@ -1751,10 +1842,51 @@ static struct wined3d_texture *surface_convert_format(struct wined3d_texture *sr
         conv->convert(src_map.data, dst_map.data, src_map.row_pitch, dst_map.row_pitch, desc.width, desc.height);
 
         wined3d_resource_unmap(&dst_texture->resource, 0);
+#else  /* STAGING_CSMT */
+    wined3d_texture_get_pitch(src_texture, sub_resource_idx & src_texture->level_count,
+            &src_row_pitch, &src_slice_pitch);
+    wined3d_texture_get_pitch(dst_texture, 0, &dst_row_pitch, &dst_slice_pitch);
+
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+
+    wined3d_texture_load_location(src_texture, sub_resource_idx, context,
+            src_texture->resource.map_binding);
+    wined3d_texture_get_memory(src_texture, sub_resource_idx, &src_bo_addr,
+            src_texture->resource.map_binding, FALSE);
+    src_data = wined3d_texture_map_bo_address(&src_bo_addr,
+            src_texture->sub_resources[sub_resource_idx].size,
+            context->gl_info, GL_PIXEL_UNPACK_BUFFER, WINED3D_MAP_READONLY);
+    if (!src_data)
+        goto error;
+
+    if (conv)
+    {
+        struct wined3d_bo_address dst_bo_addr;
+
+        wined3d_texture_prepare_location(dst_texture, 0, context, dst_texture->resource.map_binding);
+        wined3d_texture_get_memory(dst_texture, 0, &dst_bo_addr,
+                dst_texture->resource.map_binding, FALSE);
+        dst_data = wined3d_texture_map_bo_address(&dst_bo_addr,
+                dst_texture->sub_resources[0].size,
+                context->gl_info, GL_PIXEL_UNPACK_BUFFER, 0);
+        if (!dst_data)
+            goto error;
+
+        conv->convert(src_data, dst_data, src_row_pitch, dst_row_pitch, desc.width, desc.height);
+
+        wined3d_texture_unmap_bo_address(&dst_bo_addr, context->gl_info, GL_PIXEL_UNPACK_BUFFER);
+#endif /* STAGING_CSMT */
     }
     else
     {
+#if !defined(STAGING_CSMT)
         struct wined3d_bo_address data = {0, src_map.data};
+#else  /* STAGING_CSMT */
+        /* FIXME: This seems weird, considering that we got a wined3d_bo_address from the source
+         * surface above. Though not sure if the upload_data would work properly with a PBO src. */
+        struct wined3d_bo_address data = {0, src_data};
+#endif /* STAGING_CSMT */
         RECT src_rect = {0, 0, desc.width, desc.height};
         const struct wined3d_gl_info *gl_info;
         struct wined3d_context *context;
@@ -1767,16 +1899,40 @@ static struct wined3d_texture *surface_convert_format(struct wined3d_texture *sr
         wined3d_texture_prepare_texture(dst_texture, context, FALSE);
         wined3d_texture_bind_and_dirtify(dst_texture, context, FALSE);
         wined3d_surface_upload_data(dst_texture->sub_resources[0].u.surface, gl_info, src_format,
+#if !defined(STAGING_CSMT)
                 &src_rect, src_map.row_pitch, &dst_point, FALSE, wined3d_const_bo_address(&data));
+#else  /* STAGING_CSMT */
+                &src_rect, src_row_pitch, &dst_point, FALSE, wined3d_const_bo_address(&data));
+#endif /* STAGING_CSMT */
 
         context_release(context);
 
         wined3d_texture_validate_location(dst_texture, 0, WINED3D_LOCATION_TEXTURE_RGB);
         wined3d_texture_invalidate_location(dst_texture, 0, ~WINED3D_LOCATION_TEXTURE_RGB);
     }
+#if !defined(STAGING_CSMT)
     wined3d_resource_unmap(&src_texture->resource, sub_resource_idx);
 
     return dst_texture;
+#else  /* STAGING_CSMT */
+    wined3d_texture_unmap_bo_address(&src_bo_addr, context->gl_info, GL_PIXEL_UNPACK_BUFFER);
+
+    if (context)
+        context_release(context);
+
+    return dst_texture;
+
+error:
+    ERR("Surface conversion failed.\n");
+
+    if (src_data)
+        wined3d_texture_unmap_bo_address(&src_bo_addr, context->gl_info, GL_PIXEL_UNPACK_BUFFER);
+    if (dst_texture)
+        wined3d_texture_decref(dst_texture);
+    if (context)
+        context_release(context);
+    return NULL;
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT _Blt_ColorFill(BYTE *buf, unsigned int width, unsigned int height,
@@ -1854,7 +2010,11 @@ static void read_from_framebuffer(struct wined3d_surface *surface,
     BOOL srcIsUpsideDown;
     struct wined3d_bo_address data;
 
+#if !defined(STAGING_CSMT)
     wined3d_texture_get_memory(texture, sub_resource_idx, &data, dst_location);
+#else  /* STAGING_CSMT */
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, dst_location, FALSE);
+#endif /* STAGING_CSMT */
 
     restore_rt = context_get_rt_surface(old_ctx);
     if (restore_rt != surface)
@@ -2381,7 +2541,13 @@ static void fb_copy_to_texture_hwstretch(struct wined3d_surface *dst_surface, st
         checkGLcall("glDeleteTextures(1, &backup)");
     }
 
+#if !defined(STAGING_CSMT)
     if (wined3d_settings.strict_draw_ordering)
+#else  /* STAGING_CSMT */
+    if (wined3d_settings.cs_multithreaded)
+        gl_info->gl_ops.gl.p_glFinish();
+    else if (wined3d_settings.strict_draw_ordering)
+#endif /* STAGING_CSMT */
         gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
     context_release(context);
@@ -2446,9 +2612,15 @@ static void surface_blt_to_drawable(const struct wined3d_device *device,
 
     gl_info = context->gl_info;
 
+#if !defined(STAGING_CSMT)
     /* Make sure the surface is up-to-date. This should probably use
      * surface_load_location() and worry about the destination surface too,
      * unless we're overwriting it completely. */
+#else  /* STAGING_CSMT */
+    /* Make sure the surface is up-to-date. This should probably use
+     * wined3d_texture_load_location() and worry about the destination surface too,
+     * unless we're overwriting it completely. */
+#endif /* STAGING_CSMT */
     wined3d_texture_load(src_texture, context, FALSE);
 
     /* Activate the destination context, set it up for blitting */
@@ -2491,8 +2663,16 @@ static void surface_blt_to_drawable(const struct wined3d_device *device,
     /* Leave the opengl state valid for blitting */
     device->blitter->unset_shader(context->gl_info);
 
+#if !defined(STAGING_CSMT)
     if (wined3d_settings.strict_draw_ordering
             || (dst_texture->swapchain && dst_texture->swapchain->front_buffer == dst_texture))
+#else  /* STAGING_CSMT */
+    if (wined3d_settings.cs_multithreaded)
+        gl_info->gl_ops.gl.p_glFinish();
+    else if (wined3d_settings.strict_draw_ordering
+            || (dst_texture->swapchain
+            && dst_texture->swapchain->front_buffer == dst_texture))
+#endif /* STAGING_CSMT */
         gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
     if (restore_rt)
@@ -2503,8 +2683,12 @@ HRESULT surface_color_fill(struct wined3d_surface *s, const RECT *rect, const st
 {
     struct wined3d_resource *resource = &s->container->resource;
     struct wined3d_device *device = resource->device;
+#if !defined(STAGING_CSMT)
     struct wined3d_rendertarget_view_desc view_desc;
     struct wined3d_rendertarget_view *view;
+#else  /* STAGING_CSMT */
+    struct wined3d_rendertarget_view view;
+#endif /* STAGING_CSMT */
     const struct blit_shader *blitter;
     HRESULT hr;
 
@@ -2515,6 +2699,7 @@ HRESULT surface_color_fill(struct wined3d_surface *s, const RECT *rect, const st
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     view_desc.format_id = resource->format->id;
     view_desc.u.texture.level_idx = s->texture_level;
     view_desc.u.texture.layer_idx = s->texture_layer;
@@ -2528,6 +2713,19 @@ HRESULT surface_color_fill(struct wined3d_surface *s, const RECT *rect, const st
 
     hr = blitter->color_fill(device, view, rect, color);
     wined3d_rendertarget_view_decref(view);
+#else  /* STAGING_CSMT */
+    view.resource = resource;
+    view.parent = NULL;
+    view.parent_ops = &wined3d_null_parent_ops;
+    view.format = resource->format;
+    view.buffer_offset = 0;
+    view.width = wined3d_texture_get_level_width(s->container, s->texture_level);
+    view.height = wined3d_texture_get_level_height(s->container, s->texture_level);;
+    view.depth = 1;
+    view.sub_resource_idx = s->texture_layer * s->container->level_count + s->texture_level;
+
+    hr = blitter->color_fill(device, &view, rect, color);
+#endif /* STAGING_CSMT */
 
     return hr;
 }
@@ -2538,7 +2736,11 @@ static HRESULT surface_blt_special(struct wined3d_surface *dst_surface, const RE
 {
     struct wined3d_texture *dst_texture = dst_surface->container;
     struct wined3d_device *device = dst_texture->resource.device;
+#if !defined(STAGING_CSMT)
     const struct wined3d_surface *rt = wined3d_rendertarget_view_get_surface(device->fb.render_targets[0]);
+#else  /* STAGING_CSMT */
+    const struct wined3d_surface *rt = wined3d_rendertarget_view_get_surface(device->state.fb.render_targets[0]);
+#endif /* STAGING_CSMT */
     struct wined3d_swapchain *src_swapchain, *dst_swapchain;
     struct wined3d_texture *src_texture;
 
@@ -2839,7 +3041,13 @@ static void surface_load_ds_location(struct wined3d_surface *surface, struct win
 
         context_invalidate_state(context, STATE_FRAMEBUFFER);
 
+#if !defined(STAGING_CSMT)
         if (wined3d_settings.strict_draw_ordering)
+#else  /* STAGING_CSMT */
+        if (wined3d_settings.cs_multithreaded)
+            gl_info->gl_ops.gl.p_glFinish();
+        else if (wined3d_settings.strict_draw_ordering)
+#endif /* STAGING_CSMT */
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
     }
     else if (location == WINED3D_LOCATION_DRAWABLE)
@@ -2856,7 +3064,13 @@ static void surface_load_ds_location(struct wined3d_surface *surface, struct win
 
         context_invalidate_state(context, STATE_FRAMEBUFFER);
 
+#if !defined(STAGING_CSMT)
         if (wined3d_settings.strict_draw_ordering)
+#else  /* STAGING_CSMT */
+        if (wined3d_settings.cs_multithreaded)
+            gl_info->gl_ops.gl.p_glFinish();
+        else if (wined3d_settings.strict_draw_ordering)
+#endif /* STAGING_CSMT */
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
     }
     else
@@ -2865,6 +3079,7 @@ static void surface_load_ds_location(struct wined3d_surface *surface, struct win
     }
 }
 
+#if !defined(STAGING_CSMT)
 static DWORD resource_access_from_location(DWORD location)
 {
     switch (location)
@@ -2926,6 +3141,7 @@ static void surface_copy_simple_location(struct wined3d_surface *surface, DWORD
     memcpy(dst.addr, src.addr, sub_resource->size);
 }
 
+#endif /* STAGING_CSMT */
 /* Context activation is done by the caller. */
 static void surface_load_sysmem(struct wined3d_surface *surface,
         struct wined3d_context *context, DWORD dst_location)
@@ -2938,6 +3154,7 @@ static void surface_load_sysmem(struct wined3d_surface *surface,
     wined3d_texture_prepare_location(texture, sub_resource_idx, context, dst_location);
 
     sub_resource = &texture->sub_resources[sub_resource_idx];
+#if !defined(STAGING_CSMT)
     if (sub_resource->locations & surface_simple_locations)
     {
         surface_copy_simple_location(surface, dst_location);
@@ -2946,6 +3163,11 @@ static void surface_load_sysmem(struct wined3d_surface *surface,
 
     if (sub_resource->locations & (WINED3D_LOCATION_RB_MULTISAMPLE | WINED3D_LOCATION_RB_RESOLVED))
         surface_load_location(surface, context, WINED3D_LOCATION_TEXTURE_RGB);
+#else  /* STAGING_CSMT */
+    if (sub_resource->locations & (WINED3D_LOCATION_RB_MULTISAMPLE | WINED3D_LOCATION_RB_RESOLVED))
+        wined3d_texture_load_location(surface->container, surface_get_sub_resource_idx(surface),
+                context, WINED3D_LOCATION_TEXTURE_RGB);
+#endif /* STAGING_CSMT */
 
     /* Download the surface to system memory. */
     if (sub_resource->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
@@ -2983,7 +3205,12 @@ static HRESULT surface_load_drawable(struct wined3d_surface *surface,
     }
 
     surface_get_rect(surface, NULL, &r);
+#if !defined(STAGING_CSMT)
     surface_load_location(surface, context, WINED3D_LOCATION_TEXTURE_RGB);
+#else  /* STAGING_CSMT */
+    wined3d_texture_load_location(texture, surface_get_sub_resource_idx(surface),
+            context, WINED3D_LOCATION_TEXTURE_RGB);
+#endif /* STAGING_CSMT */
     surface_blt_to_drawable(texture->resource.device, context,
             WINED3D_TEXF_POINT, FALSE, surface, &r, surface, &r);
 
@@ -3060,7 +3287,12 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
                 == WINED3D_LOCATION_TEXTURE_RGB)
         {
             FIXME_(d3d_perf)("Downloading RGB surface %p to reload it as sRGB.\n", surface);
+#if !defined(STAGING_CSMT)
             surface_load_location(surface, context, texture->resource.map_binding);
+#else  /* STAGING_CSMT */
+            wined3d_texture_load_location(texture, surface_get_sub_resource_idx(surface),
+                    context, texture->resource.map_binding);
+#endif /* STAGING_CSMT */
         }
     }
     else
@@ -3069,7 +3301,12 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
                 == WINED3D_LOCATION_TEXTURE_SRGB)
         {
             FIXME_(d3d_perf)("Downloading sRGB surface %p to reload it as RGB.\n", surface);
+#if !defined(STAGING_CSMT)
             surface_load_location(surface, context, texture->resource.map_binding);
+#else  /* STAGING_CSMT */
+            wined3d_texture_load_location(texture, surface_get_sub_resource_idx(surface),
+                    context, texture->resource.map_binding);
+#endif /* STAGING_CSMT */
         }
     }
 
@@ -3077,7 +3314,11 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
     {
         WARN("Trying to load a texture from sysmem, but no simple location is valid.\n");
         /* Lets hope we get it from somewhere... */
+#if !defined(STAGING_CSMT)
         surface_load_location(surface, context, WINED3D_LOCATION_SYSMEM);
+#else  /* STAGING_CSMT */
+        wined3d_texture_load_location(texture, surface_get_sub_resource_idx(surface), context, WINED3D_LOCATION_SYSMEM);
+#endif /* STAGING_CSMT */
     }
 
     wined3d_texture_prepare_texture(texture, context, srgb);
@@ -3091,15 +3332,27 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
     /* Don't use PBOs for converted surfaces. During PBO conversion we look at
      * WINED3D_TEXTURE_CONVERTED but it isn't set (yet) in all cases it is
      * getting called. */
+#if !defined(STAGING_CSMT)
     if ((format.convert || conversion) && texture->sub_resources[sub_resource_idx].buffer_object)
+#else  /* STAGING_CSMT */
+    if ((format.convert || conversion) && texture->sub_resources[sub_resource_idx].buffer)
+#endif /* STAGING_CSMT */
     {
         TRACE("Removing the pbo attached to surface %p.\n", surface);
 
+#if !defined(STAGING_CSMT)
         surface_load_location(surface, context, WINED3D_LOCATION_SYSMEM);
+#else  /* STAGING_CSMT */
+        wined3d_texture_load_location(texture, sub_resource_idx, context, WINED3D_LOCATION_SYSMEM);
+#endif /* STAGING_CSMT */
         wined3d_texture_set_map_binding(texture, WINED3D_LOCATION_SYSMEM);
     }
 
+#if !defined(STAGING_CSMT)
     wined3d_texture_get_memory(texture, sub_resource_idx, &data, sub_resource->locations);
+#else  /* STAGING_CSMT */
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, sub_resource->locations, FALSE);
+#endif /* STAGING_CSMT */
     if (format.convert)
     {
         /* This code is entered for texture formats which need a fixup. */
@@ -3182,16 +3435,23 @@ static void surface_load_renderbuffer(struct wined3d_surface *surface, struct wi
 }
 
 /* Context activation is done by the caller. Context may be NULL in ddraw-only mode. */
+#if !defined(STAGING_CSMT)
 HRESULT surface_load_location(struct wined3d_surface *surface, struct wined3d_context *context, DWORD location)
+#else  /* STAGING_CSMT */
+void surface_load_location(struct wined3d_surface *surface, struct wined3d_context *context, DWORD location)
+#endif /* STAGING_CSMT */
 {
     unsigned int sub_resource_idx = surface_get_sub_resource_idx(surface);
     struct wined3d_texture *texture = surface->container;
     struct wined3d_texture_sub_resource *sub_resource;
+#if !defined(STAGING_CSMT)
     unsigned int surface_w, surface_h;
+#endif /* STAGING_CSMT */
     HRESULT hr;
 
     TRACE("surface %p, location %s.\n", surface, wined3d_debug_location(location));
 
+#if !defined(STAGING_CSMT)
     surface_w = wined3d_texture_get_level_width(texture, surface->texture_level);
     surface_h = wined3d_texture_get_level_height(texture, surface->texture_level);
 
@@ -3226,6 +3486,9 @@ HRESULT surface_load_location(struct wined3d_surface *surface, struct wined3d_co
         wined3d_texture_validate_location(texture, sub_resource_idx, WINED3D_LOCATION_DISCARDED);
         return surface_load_location(surface, context, location);
     }
+#else  /* STAGING_CSMT */
+    sub_resource = &texture->sub_resources[sub_resource_idx];
+#endif /* STAGING_CSMT */
 
     if (texture->resource.usage & WINED3DUSAGE_DEPTHSTENCIL)
     {
@@ -3238,7 +3501,11 @@ HRESULT surface_load_location(struct wined3d_surface *surface, struct wined3d_co
 
         FIXME("Unimplemented copy from %s to %s for depth/stencil buffers.\n",
                 wined3d_debug_location(sub_resource->locations), wined3d_debug_location(location));
+#if !defined(STAGING_CSMT)
         return WINED3DERR_INVALIDCALL;
+#else  /* STAGING_CSMT */
+        return;
+#endif /* STAGING_CSMT */
     }
 
     switch (location)
@@ -3251,7 +3518,11 @@ HRESULT surface_load_location(struct wined3d_surface *surface, struct wined3d_co
 
         case WINED3D_LOCATION_DRAWABLE:
             if (FAILED(hr = surface_load_drawable(surface, context)))
+#if !defined(STAGING_CSMT)
                 return hr;
+#else  /* STAGING_CSMT */
+                return;
+#endif /* STAGING_CSMT */
             break;
 
         case WINED3D_LOCATION_RB_RESOLVED:
@@ -3263,7 +3534,11 @@ HRESULT surface_load_location(struct wined3d_surface *surface, struct wined3d_co
         case WINED3D_LOCATION_TEXTURE_SRGB:
             if (FAILED(hr = surface_load_texture(surface, context,
                     location == WINED3D_LOCATION_TEXTURE_SRGB)))
+#if !defined(STAGING_CSMT)
                 return hr;
+#else  /* STAGING_CSMT */
+                return;
+#endif /* STAGING_CSMT */
             break;
 
         default:
@@ -3272,6 +3547,7 @@ HRESULT surface_load_location(struct wined3d_surface *surface, struct wined3d_co
     }
 
 done:
+#if !defined(STAGING_CSMT)
     wined3d_texture_validate_location(texture, sub_resource_idx, location);
 
     if (texture->resource.usage & WINED3DUSAGE_DEPTHSTENCIL)
@@ -3281,6 +3557,9 @@ done:
     }
 
     return WINED3D_OK;
+#else  /* STAGING_CSMT */
+    return;
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT ffp_blit_alloc(struct wined3d_device *device) { return WINED3D_OK; }
@@ -3612,16 +3891,41 @@ static HRESULT surface_cpu_blt(struct wined3d_texture *dst_texture, unsigned int
     const BYTE *sbuf;
     BYTE *dbuf;
     int x, y;
+#if defined(STAGING_CSMT)
+    struct wined3d_device *device = dst_texture->resource.device;
+    struct wined3d_context *context = NULL;
+    struct wined3d_bo_address src_bo_addr, dst_bo_addr;
+#endif /* STAGING_CSMT */
 
     TRACE("dst_texture %p, dst_sub_resource_idx %u, dst_box %s, src_texture %p, "
             "src_sub_resource_idx %u, src_box %s, flags %#x, fx %p, filter %s.\n",
             dst_texture, dst_sub_resource_idx, debug_box(dst_box), src_texture,
             src_sub_resource_idx, debug_box(src_box), flags, fx, debug_d3dtexturefiltertype(filter));
 
+#if defined(STAGING_CSMT)
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+
+    wined3d_texture_load_location(dst_texture, dst_sub_resource_idx,
+            context, dst_texture->resource.map_binding);
+
+#endif /* STAGING_CSMT */
     if (src_texture == dst_texture && src_sub_resource_idx == dst_sub_resource_idx)
     {
         same_sub_resource = TRUE;
+#if !defined(STAGING_CSMT)
         wined3d_resource_map(&dst_texture->resource, dst_sub_resource_idx, &dst_map, NULL, 0);
+#else  /* STAGING_CSMT */
+
+        wined3d_texture_get_memory(dst_texture, dst_sub_resource_idx, &dst_bo_addr,
+                dst_texture->resource.map_binding, FALSE);
+        dst_map.data = wined3d_texture_map_bo_address(&dst_bo_addr,
+                dst_texture->sub_resources[dst_sub_resource_idx].size,
+                context->gl_info, GL_PIXEL_UNPACK_BUFFER, 0);
+        wined3d_texture_get_pitch(dst_texture, dst_sub_resource_idx % dst_texture->level_count,
+                &dst_map.row_pitch, &dst_map.slice_pitch);
+
+#endif /* STAGING_CSMT */
         src_map = dst_map;
         src_format = dst_texture->resource.format;
         dst_format = src_format;
@@ -3646,7 +3950,20 @@ static HRESULT surface_cpu_blt(struct wined3d_texture *dst_texture, unsigned int
                 src_texture = converted_texture;
                 src_sub_resource_idx = 0;
             }
+#if !defined(STAGING_CSMT)
             wined3d_resource_map(&src_texture->resource, src_sub_resource_idx, &src_map, NULL, WINED3D_MAP_READONLY);
+#else  /* STAGING_CSMT */
+            wined3d_texture_load_location(src_texture, src_sub_resource_idx,
+                    context, src_texture->resource.map_binding);
+            wined3d_texture_get_pitch(src_texture, src_sub_resource_idx % src_texture->level_count,
+                    &src_map.row_pitch, &src_map.slice_pitch);
+            wined3d_texture_get_memory(src_texture, src_sub_resource_idx, &src_bo_addr,
+                    src_texture->resource.map_binding, FALSE);
+            src_map.data = wined3d_texture_map_bo_address(&src_bo_addr,
+                    src_texture->sub_resources[src_sub_resource_idx].size,
+                    context->gl_info, GL_PIXEL_UNPACK_BUFFER, 0);
+
+#endif /* STAGING_CSMT */
             src_format = src_texture->resource.format;
             src_fmt_flags = src_texture->resource.format_flags;
         }
@@ -3656,7 +3973,17 @@ static HRESULT surface_cpu_blt(struct wined3d_texture *dst_texture, unsigned int
             src_fmt_flags = dst_fmt_flags;
         }
 
+#if !defined(STAGING_CSMT)
         wined3d_resource_map(&dst_texture->resource, dst_sub_resource_idx, &dst_map, dst_box, 0);
+#else  /* STAGING_CSMT */
+        wined3d_texture_get_memory(dst_texture, dst_sub_resource_idx, &dst_bo_addr,
+                dst_texture->resource.map_binding, FALSE);
+        dst_map.data = wined3d_texture_map_bo_address(&dst_bo_addr,
+                dst_texture->sub_resources[dst_sub_resource_idx].size,
+                context->gl_info, GL_PIXEL_UNPACK_BUFFER, 0);
+        wined3d_texture_get_pitch(dst_texture, dst_sub_resource_idx % dst_texture->level_count,
+                &dst_map.row_pitch, &dst_map.slice_pitch);
+#endif /* STAGING_CSMT */
     }
 
     bpp = dst_format->byte_count;
@@ -3670,12 +3997,18 @@ static HRESULT surface_cpu_blt(struct wined3d_texture *dst_texture, unsigned int
         sbase = (BYTE *)src_map.data
                 + ((src_box->top / src_format->block_height) * src_map.row_pitch)
                 + ((src_box->left / src_format->block_width) * src_format->block_byte_count);
+#if !defined(STAGING_CSMT)
     if (same_sub_resource)
         dbuf = (BYTE *)dst_map.data
                 + ((dst_box->top / dst_format->block_height) * dst_map.row_pitch)
                 + ((dst_box->left / dst_format->block_width) * dst_format->block_byte_count);
     else
         dbuf = dst_map.data;
+#else  /* STAGING_CSMT */
+    dbuf = (BYTE *)dst_map.data
+            + ((dst_box->top / dst_format->block_height) * dst_map.row_pitch)
+            + ((dst_box->left / dst_format->block_width) * dst_format->block_byte_count);
+#endif /* STAGING_CSMT */
 
     if (src_fmt_flags & dst_fmt_flags & WINED3DFMT_FLAG_BLOCKS)
     {
@@ -4068,16 +4401,42 @@ do { \
         }
     }
 
+#if defined(STAGING_CSMT)
+    wined3d_texture_invalidate_location(dst_texture, dst_sub_resource_idx,
+            ~dst_texture->resource.map_binding);
+
+#endif /* STAGING_CSMT */
 error:
     if (flags)
         FIXME("    Unsupported flags %#x.\n", flags);
 
 release:
+#if !defined(STAGING_CSMT)
     wined3d_resource_unmap(&dst_texture->resource, dst_sub_resource_idx);
     if (src_texture && !same_sub_resource)
         wined3d_resource_unmap(&src_texture->resource, src_sub_resource_idx);
     if (converted_texture)
         wined3d_texture_decref(converted_texture);
+#else  /* STAGING_CSMT */
+    wined3d_texture_unmap_bo_address(&dst_bo_addr, context->gl_info, GL_PIXEL_UNPACK_BUFFER);
+
+    if (dst_texture->swapchain
+            && dst_texture == dst_texture->swapchain->front_buffer)
+    {
+        RECT *r = &dst_texture->swapchain->front_buffer_update;
+
+        SetRect(r, dst_box->left, dst_box->top, dst_box->right, dst_box->bottom);
+        if (!(dst_texture->sub_resources[dst_sub_resource_idx].locations
+                & (WINED3D_LOCATION_DRAWABLE | WINED3D_LOCATION_TEXTURE_RGB)))
+            dst_texture->swapchain->swapchain_ops->swapchain_frontbuffer_updated(dst_texture->swapchain);
+    }
+    if (src_texture && !same_sub_resource)
+        wined3d_texture_unmap_bo_address(&src_bo_addr, context->gl_info, GL_PIXEL_UNPACK_BUFFER);
+    if (converted_texture)
+        wined3d_texture_decref(converted_texture);
+    if (context)
+        context_release(context);
+#endif /* STAGING_CSMT */
 
     return hr;
 }
@@ -4122,7 +4481,11 @@ const struct blit_shader cpu_blit =  {
     cpu_blit_blit_surface,
 };
 
+#if !defined(STAGING_CSMT)
 HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst_rect,
+#else  /* STAGING_CSMT */
+void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
+#endif /* STAGING_CSMT */
         struct wined3d_surface *src_surface, const RECT *src_rect, DWORD flags,
         const struct wined3d_blt_fx *fx, enum wined3d_texture_filter_type filter)
 {
@@ -4132,9 +4495,14 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
     struct wined3d_texture *dst_texture = dst_surface->container;
     struct wined3d_device *device = dst_texture->resource.device;
     struct wined3d_swapchain *src_swapchain, *dst_swapchain;
+#if !defined(STAGING_CSMT)
     struct wined3d_texture *src_texture = NULL;
     unsigned int dst_w, dst_h, src_w, src_h;
     unsigned int src_sub_resource_idx = 0;
+#else  /* STAGING_CSMT */
+    struct wined3d_texture *src_texture;
+    unsigned int src_sub_resource_idx;
+#endif /* STAGING_CSMT */
     DWORD src_ds_flags, dst_ds_flags;
     BOOL scale, convert;
 
@@ -4147,6 +4515,7 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
             | WINED3D_BLT_DO_NOT_WAIT
             | WINED3D_BLT_ALPHA_TEST;
 
+#if !defined(STAGING_CSMT)
     TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
             dst_surface, wine_dbgstr_rect(dst_rect), src_surface, wine_dbgstr_rect(src_rect),
             flags, fx, debug_d3dtexturefiltertype(filter));
@@ -4164,10 +4533,12 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
                 fx->src_color_key.color_space_high_value);
     }
 
+#endif /* STAGING_CSMT */
     if (src_surface)
     {
         src_texture = src_surface->container;
         src_sub_resource_idx = surface_get_sub_resource_idx(src_surface);
+#if !defined(STAGING_CSMT)
     }
 
     if (dst_texture->sub_resources[dst_sub_resource_idx].map_count
@@ -4225,6 +4596,15 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
         if (!once++)
             FIXME("Can't handle WINED3D_BLT_DO_NOT_WAIT flag.\n");
         flags &= ~WINED3D_BLT_DO_NOT_WAIT;
+#else  /* STAGING_CSMT */
+        src_swapchain = src_texture->swapchain;
+    }
+    else
+    {
+        src_texture = NULL;
+        src_sub_resource_idx = 0;
+        src_swapchain = NULL;
+#endif /* STAGING_CSMT */
     }
 
     if (!device->d3d_initialized)
@@ -4249,11 +4629,13 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
         goto fallback;
     }
 
+#if !defined(STAGING_CSMT)
     if (src_texture)
         src_swapchain = src_texture->swapchain;
     else
         src_swapchain = NULL;
 
+#endif /* STAGING_CSMT */
     dst_swapchain = dst_texture->swapchain;
 
     /* This isn't strictly needed. FBO blits for example could deal with
@@ -4289,13 +4671,21 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
             TRACE("Depth fill.\n");
 
             if (!surface_convert_depth_to_float(dst_surface, fx->fill_color, &depth))
+#if !defined(STAGING_CSMT)
                 return WINED3DERR_INVALIDCALL;
 
             if (SUCCEEDED(wined3d_surface_depth_fill(dst_surface, dst_rect, depth)))
                 return WINED3D_OK;
+#else  /* STAGING_CSMT */
+                return;
+
+            if (SUCCEEDED(wined3d_surface_depth_fill(dst_surface, dst_rect, depth)))
+                return;
+#endif /* STAGING_CSMT */
         }
         else
         {
+#if !defined(STAGING_CSMT)
             if (src_ds_flags != dst_ds_flags)
             {
                 WARN("Rejecting depth / stencil blit between incompatible formats.\n");
@@ -4305,6 +4695,11 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
             if (SUCCEEDED(wined3d_surface_depth_blt(src_surface, src_texture->resource.draw_binding,
                     src_rect, dst_surface, dst_texture->resource.draw_binding, dst_rect)))
                 return WINED3D_OK;
+#else  /* STAGING_CSMT */
+            if (SUCCEEDED(wined3d_surface_depth_blt(src_surface, src_texture->resource.draw_binding,
+                    src_rect, dst_surface, dst_texture->resource.draw_binding, dst_rect)))
+                return;
+#endif /* STAGING_CSMT */
         }
     }
     else
@@ -4340,7 +4735,11 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
                 goto fallback;
 
             if (SUCCEEDED(surface_color_fill(dst_surface, dst_rect, &color)))
+#if !defined(STAGING_CSMT)
                 return WINED3D_OK;
+#else  /* STAGING_CSMT */
+                return;
+#endif /* STAGING_CSMT */
         }
         else
         {
@@ -4379,10 +4778,18 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
                         if (!wined3d_resource_is_offscreen(&dst_texture->resource))
                         {
                             struct wined3d_context *context = context_acquire(device, dst_surface);
+#if !defined(STAGING_CSMT)
                             surface_load_location(dst_surface, context, dst_texture->resource.draw_binding);
                             context_release(context);
                         }
                         return WINED3D_OK;
+#else  /* STAGING_CSMT */
+                            wined3d_texture_load_location(dst_texture, surface_get_sub_resource_idx(dst_surface),
+                                    context, dst_texture->resource.draw_binding);
+                            context_release(context);
+                        }
+                        return;
+#endif /* STAGING_CSMT */
                     }
                 }
             }
@@ -4406,7 +4813,11 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
                 wined3d_swapchain_present(dst_swapchain, NULL, NULL, dst_swapchain->win_handle, 0);
                 dst_swapchain->desc.swap_effect = swap_effect;
 
+#if !defined(STAGING_CSMT)
                 return WINED3D_OK;
+#else  /* STAGING_CSMT */
+                return;
+#endif /* STAGING_CSMT */
             }
 
             if (fbo_blit_supported(&device->adapter->gl_info, blit_op,
@@ -4427,7 +4838,11 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
                 wined3d_texture_invalidate_location(dst_texture, dst_sub_resource_idx,
                         ~dst_texture->resource.draw_binding);
 
+#if !defined(STAGING_CSMT)
                 return WINED3D_OK;
+#else  /* STAGING_CSMT */
+                return;
+#endif /* STAGING_CSMT */
             }
 
             blitter = wined3d_select_blitter(&device->adapter->gl_info, &device->adapter->d3d_info, blit_op,
@@ -4437,7 +4852,11 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
             {
                 blitter->blit_surface(device, blit_op, filter, src_surface,
                         src_rect, dst_surface, dst_rect, color_key);
+#if !defined(STAGING_CSMT)
                 return WINED3D_OK;
+#else  /* STAGING_CSMT */
+                return;
+#endif /* STAGING_CSMT */
             }
         }
     }
@@ -4445,9 +4864,156 @@ HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst
 fallback:
     /* Special cases for render targets. */
     if (SUCCEEDED(surface_blt_special(dst_surface, dst_rect, src_surface, src_rect, flags, fx, filter)))
+#if !defined(STAGING_CSMT)
         return WINED3D_OK;
 
 cpu:
     return surface_cpu_blt(dst_texture, dst_sub_resource_idx, &dst_box,
             src_texture, src_sub_resource_idx, &src_box, flags, fx, filter);
+#else  /* STAGING_CSMT */
+        return;
+
+cpu:
+    surface_cpu_blt(dst_texture, dst_sub_resource_idx, &dst_box,
+            src_texture, src_sub_resource_idx, &src_box, flags, fx, filter);
+    return;
+}
+
+HRESULT wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst_rect_in,
+        struct wined3d_surface *src_surface, const RECT *src_rect_in, DWORD flags,
+        const struct wined3d_blt_fx *fx, enum wined3d_texture_filter_type filter)
+{
+    struct wined3d_texture *dst_texture = dst_surface->container;
+    struct wined3d_device *device = dst_texture->resource.device;
+    unsigned int dst_sub_resource_idx = surface_get_sub_resource_idx(dst_surface), src_sub_resource_idx;
+    struct wined3d_texture_sub_resource *dst_sub_resource =
+            &dst_texture->sub_resources[dst_sub_resource_idx];
+    struct wined3d_texture_sub_resource *src_sub_resource = NULL;
+    RECT src_rect, dst_rect;
+    unsigned int dst_w, dst_h, src_w, src_h;
+
+    TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
+            dst_surface, wine_dbgstr_rect(dst_rect_in), src_surface, wine_dbgstr_rect(src_rect_in),
+            flags, fx, debug_d3dtexturefiltertype(filter));
+    TRACE("Usage is %s.\n", debug_d3dusage(dst_texture->resource.usage));
+
+    if (fx)
+    {
+        TRACE("fx %#x.\n", fx->fx);
+        TRACE("fill_color 0x%08x.\n", fx->fill_color);
+        TRACE("dst_color_key {0x%08x, 0x%08x}.\n",
+                fx->dst_color_key.color_space_low_value,
+                fx->dst_color_key.color_space_high_value);
+        TRACE("src_color_key {0x%08x, 0x%08x}.\n",
+                fx->src_color_key.color_space_low_value,
+                fx->src_color_key.color_space_high_value);
+    }
+
+    if (src_surface)
+    {
+        src_sub_resource_idx = surface_get_sub_resource_idx(src_surface);
+        src_sub_resource = &src_surface->container->sub_resources[src_sub_resource_idx];
+    }
+
+    if (dst_sub_resource->map_count || (src_sub_resource && src_sub_resource->map_count))
+    {
+        /* TODO: Separate application maps from internal maps */
+        if (!wined3d_settings.cs_multithreaded)
+        {
+            WARN("Surface is busy, returning WINEDDERR_SURFACEBUSY.\n");
+            return WINEDDERR_SURFACEBUSY;
+        }
+
+        wined3d_cs_emit_glfinish(device->cs);
+        device->cs->ops->finish(device->cs);
+
+        if (dst_sub_resource->map_count || (src_sub_resource && src_sub_resource->map_count))
+        {
+            WARN("Surface is busy, returning WINEDDERR_SURFACEBUSY.\n");
+            return WINEDDERR_SURFACEBUSY;
+        }
+    }
+
+    surface_get_rect(dst_surface, dst_rect_in, &dst_rect);
+
+    dst_w = wined3d_texture_get_level_width(dst_texture, dst_surface->texture_level);
+    dst_h = wined3d_texture_get_level_height(dst_texture, dst_surface->texture_level);
+    if (IsRectEmpty(&dst_rect)
+            || dst_rect.left > dst_w || dst_rect.left < 0
+            || dst_rect.top > dst_h || dst_rect.top < 0
+            || dst_rect.right > dst_w || dst_rect.right < 0
+            || dst_rect.bottom > dst_h || dst_rect.bottom < 0)
+    {
+        WARN("The application gave us a bad destination rectangle.\n");
+        return WINEDDERR_INVALIDRECT;
+    }
+
+    if (src_surface)
+    {
+        DWORD src_ds_flags, dst_ds_flags;
+
+        surface_get_rect(src_surface, src_rect_in, &src_rect);
+
+        src_w = wined3d_texture_get_level_width(src_surface->container, src_surface->texture_level);
+        src_h = wined3d_texture_get_level_height(src_surface->container, src_surface->texture_level);
+        if (IsRectEmpty(&src_rect)
+                || src_rect.left > src_w || src_rect.left < 0
+                || src_rect.top > src_h || src_rect.top < 0
+                || src_rect.right > src_w || src_rect.right < 0
+                || src_rect.bottom > src_h || src_rect.bottom < 0)
+        {
+            WARN("The application gave us a bad source rectangle.\n");
+            return WINEDDERR_INVALIDRECT;
+        }
+
+        dst_ds_flags = dst_texture->resource.format_flags
+                & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
+        src_ds_flags = src_surface->container->resource.format_flags
+                & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
+        if (src_ds_flags != dst_ds_flags)
+        {
+            WARN("Rejecting depth / stencil blit between incompatible formats.\n");
+            return WINED3DERR_INVALIDCALL;
+        }
+    }
+
+    /* FIXME: We should select the blitter in the main thread, that way we can return an error if the blit
+     * is unsupported without duplicating all the checks... */
+    if (flags & WINED3D_BLT_COLOR_FILL && (dst_surface->container->resource.format_flags & WINED3DFMT_FLAG_BLOCKS))
+    {
+        WARN("Block color fill, returning WINED3DERR_INVALIDCALL\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (!fx || !(fx->fx))
+        flags &= ~WINED3D_BLT_FX;
+
+    if (flags & WINED3D_BLT_WAIT)
+        flags &= ~WINED3D_BLT_WAIT;
+
+    if (flags & WINED3D_BLT_ASYNC)
+    {
+        static unsigned int once;
+
+        if (!once++)
+            FIXME("Can't handle WINED3D_BLT_ASYNC flag.\n");
+        flags &= ~WINED3D_BLT_ASYNC;
+    }
+
+    /* WINED3D_BLT_DO_NOT_WAIT appeared in DX7. */
+    if (flags & WINED3D_BLT_DO_NOT_WAIT)
+    {
+        static unsigned int once;
+
+        if (!once++)
+            FIXME("Can't handle WINED3D_BLT_DO_NOT_WAIT flag.\n");
+        flags &= ~WINED3D_BLT_DO_NOT_WAIT;
+    }
+
+    TRACE("Emitting blit %p <== %p\n", dst_surface, src_surface);
+    wined3d_cs_emit_blt(device->cs, dst_surface, &dst_rect, src_surface, &src_rect,
+            flags, fx, filter);
+
+    return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
diff --git a/dlls/wined3d/swapchain.c b/dlls/wined3d/swapchain.c
--- a/dlls/wined3d/swapchain.c
+++ b/dlls/wined3d/swapchain.c
@@ -105,6 +105,13 @@ ULONG CDECL wined3d_swapchain_decref(struct wined3d_swapchain *swapchain)
 
     if (!refcount)
     {
+#if defined(STAGING_CSMT)
+        struct wined3d_device *device = swapchain->device;
+
+        if (wined3d_settings.cs_multithreaded)
+            device->cs->ops->finish(device->cs);
+
+#endif /* STAGING_CSMT */
         swapchain_cleanup(swapchain);
         swapchain->parent_ops->wined3d_object_destroyed(swapchain->parent);
         HeapFree(GetProcessHeap(), 0, swapchain);
@@ -327,7 +334,11 @@ static void swapchain_blit(const struct wined3d_swapchain *swapchain,
         if (texture->resource.multisample_type)
         {
             location = WINED3D_LOCATION_RB_RESOLVED;
+#if !defined(STAGING_CSMT)
             surface_load_location(back_buffer, context, location);
+#else  /* STAGING_CSMT */
+            wined3d_texture_load_location(texture, 0, context, location);
+#endif /* STAGING_CSMT */
         }
 
         context_apply_fbo_state_blit(context, GL_READ_FRAMEBUFFER, back_buffer, NULL, location);
@@ -457,7 +468,11 @@ static void wined3d_swapchain_rotate(struct wined3d_swapchain *swapchain, struct
         sub_resource = &texture->sub_resources[0];
 
         if (!(sub_resource->locations & supported_locations))
+#if !defined(STAGING_CSMT)
             surface_load_location(sub_resource->u.surface, context, texture->resource.draw_binding);
+#else  /* STAGING_CSMT */
+            wined3d_texture_load_location(texture, 0, context, texture->resource.draw_binding);
+#endif /* STAGING_CSMT */
 
         texture_prev->texture_rgb = texture->texture_rgb;
         texture_prev->rb_multisample = texture->rb_multisample;
@@ -478,10 +493,17 @@ static void wined3d_swapchain_rotate(struct wined3d_swapchain *swapchain, struct
 }
 
 static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
+#if !defined(STAGING_CSMT)
         const RECT *src_rect, const RECT *dst_rect, DWORD flags)
 {
     struct wined3d_surface *back_buffer = swapchain->back_buffers[0]->sub_resources[0].u.surface;
     const struct wined3d_fb_state *fb = &swapchain->device->fb;
+#else  /* STAGING_CSMT */
+        const RECT *src_rect, const RECT *dst_rect, DWORD flags,
+        struct wined3d_rendertarget_view *depth_stencil)
+{
+    struct wined3d_surface *back_buffer = swapchain->back_buffers[0]->sub_resources[0].u.surface;
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info;
     struct wined3d_texture *logo_texture;
     struct wined3d_context *context;
@@ -502,7 +524,12 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
         RECT rect = {0, 0, logo_texture->resource.width, logo_texture->resource.height};
 
         /* Blit the logo into the upper left corner of the drawable. */
+#if !defined(STAGING_CSMT)
         wined3d_texture_blt(swapchain->back_buffers[0], 0, &rect, logo_texture, 0, &rect,
+#else  /* STAGING_CSMT */
+        surface_blt_ugly(swapchain->back_buffers[0]->sub_resources[0].u.surface, &rect,
+                logo_texture->sub_resources[0].u.surface, &rect,
+#endif /* STAGING_CSMT */
                 WINED3D_BLT_ALPHA_TEST, NULL, WINED3D_TEXF_POINT);
     }
 
@@ -531,8 +558,13 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
         if (swapchain->desc.windowed)
             MapWindowPoints(NULL, swapchain->win_handle, (POINT *)&dst_rect, 2);
         if (wined3d_clip_blit(&clip_rect, &dst_rect, &src_rect))
+#if !defined(STAGING_CSMT)
             wined3d_texture_blt(swapchain->back_buffers[0], 0, &dst_rect,
                     swapchain->device->cursor_texture, 0, &src_rect,
+#else  /* STAGING_CSMT */
+            surface_blt_ugly(swapchain->back_buffers[0]->sub_resources[0].u.surface, &dst_rect,
+                    swapchain->device->cursor_texture->sub_resources[0].u.surface, &src_rect,
+#endif /* STAGING_CSMT */
                     WINED3D_BLT_ALPHA_TEST, NULL, WINED3D_TEXF_POINT);
     }
 
@@ -556,14 +588,23 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
      */
     if (!swapchain->render_to_fbo && render_to_fbo && wined3d_settings.offscreen_rendering_mode == ORM_FBO)
     {
+#if !defined(STAGING_CSMT)
         surface_load_location(back_buffer, context, WINED3D_LOCATION_TEXTURE_RGB);
+#else  /* STAGING_CSMT */
+        wined3d_texture_load_location(back_buffer->container, 0, context, WINED3D_LOCATION_TEXTURE_RGB);
+#endif /* STAGING_CSMT */
         wined3d_texture_invalidate_location(back_buffer->container, 0, WINED3D_LOCATION_DRAWABLE);
         swapchain->render_to_fbo = TRUE;
         swapchain_update_draw_bindings(swapchain);
     }
     else
     {
+#if !defined(STAGING_CSMT)
         surface_load_location(back_buffer, context, back_buffer->container->resource.draw_binding);
+#else  /* STAGING_CSMT */
+        wined3d_texture_load_location(swapchain->back_buffers[0], 0, context,
+                swapchain->back_buffers[0]->resource.draw_binding);
+#endif /* STAGING_CSMT */
     }
 
     if (swapchain->render_to_fbo)
@@ -576,8 +617,13 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
         swapchain_blit(swapchain, context, src_rect, dst_rect);
     }
 
+#if !defined(STAGING_CSMT)
     if (swapchain->num_contexts > 1)
         gl_info->gl_ops.gl.p_glFinish();
+#else  /* STAGING_CSMT */
+    if (swapchain->num_contexts > 1 && !wined3d_settings.cs_multithreaded)
+        gl_info->gl_ops.gl.p_glFlush();
+#endif /* STAGING_CSMT */
 
     /* call wglSwapBuffers through the gl table to avoid confusing the Steam overlay */
     gl_info->gl_ops.wgl.p_wglSwapBuffers(context->hdc);
@@ -614,19 +660,33 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
         wined3d_texture_validate_location(swapchain->back_buffers[swapchain->desc.backbuffer_count - 1],
                 0, WINED3D_LOCATION_DISCARDED);
 
+#if !defined(STAGING_CSMT)
     if (fb->depth_stencil)
     {
         struct wined3d_surface *ds = wined3d_rendertarget_view_get_surface(fb->depth_stencil);
+#else  /* STAGING_CSMT */
+    if (depth_stencil)
+    {
+        struct wined3d_surface *ds = wined3d_rendertarget_view_get_surface(depth_stencil);
+#endif /* STAGING_CSMT */
 
         if (ds && (swapchain->desc.flags & WINED3DPRESENTFLAG_DISCARD_DEPTHSTENCIL
                 || ds->container->flags & WINED3D_TEXTURE_DISCARD))
         {
             surface_modify_ds_location(ds, WINED3D_LOCATION_DISCARDED,
+#if !defined(STAGING_CSMT)
                     fb->depth_stencil->width, fb->depth_stencil->height);
             if (ds == swapchain->device->onscreen_depth_stencil)
             {
                 wined3d_texture_decref(swapchain->device->onscreen_depth_stencil->container);
                 swapchain->device->onscreen_depth_stencil = NULL;
+#else  /* STAGING_CSMT */
+                    depth_stencil->width, depth_stencil->height);
+            if (ds == swapchain->device->cs->onscreen_depth_stencil)
+            {
+                wined3d_texture_decref(swapchain->device->cs->onscreen_depth_stencil->container);
+                swapchain->device->cs->onscreen_depth_stencil = NULL;
+#endif /* STAGING_CSMT */
             }
         }
     }
@@ -636,12 +696,21 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain,
 
 static void swapchain_gl_frontbuffer_updated(struct wined3d_swapchain *swapchain)
 {
+#if !defined(STAGING_CSMT)
     struct wined3d_surface *surface;
     struct wined3d_context *context;
 
     surface = swapchain->front_buffer->sub_resources[0].u.surface;
     context = context_acquire(swapchain->device, surface);
     surface_load_location(surface, context, surface->container->resource.draw_binding);
+#else  /* STAGING_CSMT */
+    struct wined3d_texture *texture = swapchain->front_buffer;
+    struct wined3d_surface *surface = texture->sub_resources[0].u.surface;
+    struct wined3d_context *context;
+
+    context = context_acquire(swapchain->device, surface);
+    wined3d_texture_load_location(texture, 0, context, texture->resource.draw_binding);
+#endif /* STAGING_CSMT */
     context_release(context);
     SetRectEmpty(&swapchain->front_buffer_update);
 }
@@ -695,7 +764,12 @@ static void swapchain_gdi_frontbuffer_updated(struct wined3d_swapchain *swapchai
 }
 
 static void swapchain_gdi_present(struct wined3d_swapchain *swapchain,
+#if !defined(STAGING_CSMT)
         const RECT *src_rect, const RECT *dst_rect, DWORD flags)
+#else  /* STAGING_CSMT */
+        const RECT *src_rect, const RECT *dst_rect, DWORD flags,
+        struct wined3d_rendertarget_view *depth_stencil)
+#endif /* STAGING_CSMT */
 {
     struct wined3d_surface *front, *back;
     HBITMAP bitmap;
@@ -806,6 +880,71 @@ static void wined3d_swapchain_apply_sample_count_override(const struct wined3d_s
     *quality = 0;
 }
 
+#if defined(STAGING_CSMT)
+HRESULT swapchain_create_context_cs(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+    const struct wined3d_adapter *adapter = device->adapter;
+    const struct wined3d_gl_info *gl_info = &adapter->gl_info;
+    UINT i;
+
+    static const enum wined3d_format_id formats[] =
+    {
+        WINED3DFMT_D24_UNORM_S8_UINT,
+        WINED3DFMT_D32_UNORM,
+        WINED3DFMT_R24_UNORM_X8_TYPELESS,
+        WINED3DFMT_D16_UNORM,
+        WINED3DFMT_S1_UINT_D15_UNORM
+    };
+
+    swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
+    if (!swapchain->context)
+    {
+        ERR("Failed to create the context array.\n");
+        return E_OUTOFMEMORY;
+    }
+    swapchain->num_contexts = 1;
+
+    /* In WGL both color, depth and stencil are features of a pixel format. In case of D3D they are separate.
+     * You are able to add a depth + stencil surface at a later stage when you need it.
+     * In order to support this properly in WineD3D we need the ability to recreate the opengl context and
+     * drawable when this is required. This is very tricky as we need to reapply ALL opengl states for the new
+     * context, need torecreate shaders, textures and other resources.
+     *
+     * The context manager already takes care of the state problem and for the other tasks code from Reset
+     * can be used. These changes are way to risky during the 1.0 code freeze which is taking place right now.
+     * Likely a lot of other new bugs will be exposed. For that reason request a depth stencil surface all the
+     * time. It can cause a slight performance hit but fixes a lot of regressions. A fixme reminds of that this
+     * issue needs to be fixed. */
+    for (i = 0; i < (sizeof(formats) / sizeof(*formats)); i++)
+    {
+        swapchain->ds_format = wined3d_get_format(gl_info, formats[i]);
+        swapchain->context[0] = context_create(swapchain, swapchain->front_buffer, swapchain->ds_format);
+        if (swapchain->context[0]) break;
+        TRACE("Depth stencil format %s is not supported, trying next format\n",
+                debug_d3dformat(formats[i]));
+    }
+
+    if (!swapchain->context[0])
+    {
+        WARN("Failed to create context.\n");
+        HeapFree(GetProcessHeap(), 0, swapchain->context);
+        swapchain->context = NULL;
+        return WINED3DERR_NOTAVAILABLE;
+    }
+
+    if (wined3d_settings.offscreen_rendering_mode != ORM_FBO
+            && (!swapchain->desc.enable_auto_depth_stencil
+            || swapchain->desc.auto_depth_stencil_format != swapchain->ds_format->id))
+    {
+        FIXME("Add OpenGL context recreation support to context_validate_onscreen_formats\n");
+    }
+    context_release(swapchain->context[0]);
+    swapchain_update_swap_interval(swapchain);
+
+    return WINED3D_OK;
+}
+
+#endif /* STAGING_CSMT */
 static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3d_device *device,
         struct wined3d_swapchain_desc *desc, void *parent, const struct wined3d_parent_ops *parent_ops)
 {
@@ -923,6 +1062,7 @@ static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3
 
     if (!(device->wined3d->flags & WINED3D_NO3D))
     {
+#if !defined(STAGING_CSMT)
         static const enum wined3d_format_id formats[] =
         {
             WINED3DFMT_D24_UNORM_S8_UINT,
@@ -978,6 +1118,11 @@ static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3
         }
         context_release(swapchain->context[0]);
         swapchain_update_swap_interval(swapchain);
+#else  /* STAGING_CSMT */
+        hr = wined3d_cs_emit_create_swapchain_context(device->cs, swapchain);
+        if (FAILED(hr))
+            goto err;
+#endif /* STAGING_CSMT */
     }
 
     if (swapchain->desc.backbuffer_count > 0)
@@ -1303,6 +1448,9 @@ HRESULT CDECL wined3d_swapchain_resize_buffers(struct wined3d_swapchain *swapcha
         enum wined3d_multisample_type multisample_type, unsigned int multisample_quality)
 {
     BOOL update_desc = FALSE;
+#if defined(STAGING_CSMT)
+    struct wined3d_device *device = swapchain->device;
+#endif /* STAGING_CSMT */
 
     TRACE("swapchain %p, buffer_count %u, width %u, height %u, format %s, "
             "multisample_type %#x, multisample_quality %#x.\n",
@@ -1314,6 +1462,11 @@ HRESULT CDECL wined3d_swapchain_resize_buffers(struct wined3d_swapchain *swapcha
     if (buffer_count && buffer_count != swapchain->desc.backbuffer_count)
         FIXME("Cannot change the back buffer count yet.\n");
 
+#if defined(STAGING_CSMT)
+    if (wined3d_settings.cs_multithreaded)
+        device->cs->ops->finish(device->cs);
+
+#endif /* STAGING_CSMT */
     if (!width || !height)
     {
         /* The application is requesting that either the swapchain width or
diff --git a/dlls/wined3d/texture.c b/dlls/wined3d/texture.c
--- a/dlls/wined3d/texture.c
+++ b/dlls/wined3d/texture.c
@@ -104,6 +104,9 @@ static void wined3d_texture_evict_sysmem(struct wined3d_texture *texture)
         sub_resource->locations &= ~WINED3D_LOCATION_SYSMEM;
     }
     wined3d_resource_free_sysmem(&texture->resource);
+#if defined(STAGING_CSMT)
+    texture->resource.map_heap_memory = NULL;
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_texture_validate_location(struct wined3d_texture *texture,
@@ -195,7 +198,11 @@ void wined3d_texture_unmap_bo_address(const struct wined3d_bo_address *data,
 }
 
 void wined3d_texture_get_memory(struct wined3d_texture *texture, unsigned int sub_resource_idx,
+#if !defined(STAGING_CSMT)
         struct wined3d_bo_address *data, DWORD locations)
+#else  /* STAGING_CSMT */
+        struct wined3d_bo_address *data, DWORD locations, BOOL map)
+#endif /* STAGING_CSMT */
 {
     struct wined3d_texture_sub_resource *sub_resource;
 
@@ -206,7 +213,14 @@ void wined3d_texture_get_memory(struct wined3d_texture *texture, unsigned int su
     if (locations & WINED3D_LOCATION_BUFFER)
     {
         data->addr = NULL;
+#if !defined(STAGING_CSMT)
         data->buffer_object = sub_resource->buffer_object;
+#else  /* STAGING_CSMT */
+        if (map)
+            data->buffer_object = sub_resource->map_buffer->name;
+        else
+            data->buffer_object = sub_resource->buffer->name;
+#endif /* STAGING_CSMT */
         return;
     }
     if (locations & WINED3D_LOCATION_USER_MEMORY)
@@ -217,7 +231,14 @@ void wined3d_texture_get_memory(struct wined3d_texture *texture, unsigned int su
     }
     if (locations & WINED3D_LOCATION_SYSMEM)
     {
+#if !defined(STAGING_CSMT)
         data->addr = texture->resource.heap_memory;
+#else  /* STAGING_CSMT */
+        if (map)
+            data->addr = texture->resource.map_heap_memory;
+        else
+            data->addr = texture->resource.heap_memory;
+#endif /* STAGING_CSMT */
         data->addr += sub_resource->offset;
         data->buffer_object = 0;
         return;
@@ -303,6 +324,7 @@ static HRESULT wined3d_texture_init(struct wined3d_texture *texture, const struc
 
 /* Context activation is done by the caller. */
 static void wined3d_texture_remove_buffer_object(struct wined3d_texture *texture,
+#if !defined(STAGING_CSMT)
         unsigned int sub_resource_idx, const struct wined3d_gl_info *gl_info)
 {
     GLuint *buffer_object;
@@ -315,6 +337,24 @@ static void wined3d_texture_remove_buffer_object(struct wined3d_texture *texture
 
     TRACE("Deleted buffer object %u for texture %p, sub-resource %u.\n",
             *buffer_object, texture, sub_resource_idx);
+#else  /* STAGING_CSMT */
+        unsigned int sub_resource_idx, struct wined3d_context *context)
+{
+    struct wined3d_gl_bo *buffer = texture->sub_resources[sub_resource_idx].buffer;
+    GLuint name = buffer->name;
+
+    if (buffer != texture->sub_resources[sub_resource_idx].map_buffer)
+        ERR("Buffer is %p, map buffer is %p.\n", buffer,
+                texture->sub_resources[sub_resource_idx].map_buffer);
+
+    wined3d_device_release_bo(texture->resource.device, buffer, context);
+    texture->sub_resources[sub_resource_idx].buffer = NULL;
+    texture->sub_resources[sub_resource_idx].map_buffer = NULL;
+    wined3d_texture_invalidate_location(texture, sub_resource_idx, WINED3D_LOCATION_BUFFER);
+
+    TRACE("Deleted buffer object %u for texture %p, sub-resource %u.\n",
+            name, texture, sub_resource_idx);
+#endif /* STAGING_CSMT */
 }
 
 static void wined3d_texture_update_map_binding(struct wined3d_texture *texture)
@@ -331,10 +371,17 @@ static void wined3d_texture_update_map_binding(struct wined3d_texture *texture)
     for (i = 0; i < sub_count; ++i)
     {
         if (texture->sub_resources[i].locations == texture->resource.map_binding
+#if !defined(STAGING_CSMT)
                 && !texture->texture_ops->texture_load_location(texture, i, context, map_binding))
             ERR("Failed to load location %s.\n", wined3d_debug_location(map_binding));
         if (texture->resource.map_binding == WINED3D_LOCATION_BUFFER)
             wined3d_texture_remove_buffer_object(texture, i, context->gl_info);
+#else  /* STAGING_CSMT */
+                && !wined3d_texture_load_location(texture, i, context, map_binding))
+            ERR("Failed to load location %s.\n", wined3d_debug_location(map_binding));
+        if (texture->resource.map_binding == WINED3D_LOCATION_BUFFER)
+            wined3d_texture_remove_buffer_object(texture, i, context);
+#endif /* STAGING_CSMT */
     }
 
     if (context)
@@ -491,28 +538,51 @@ static void wined3d_texture_cleanup(struct wined3d_texture *texture)
     unsigned int sub_count = texture->level_count * texture->layer_count;
     struct wined3d_device *device = texture->resource.device;
     struct wined3d_context *context = NULL;
+#if !defined(STAGING_CSMT)
     const struct wined3d_gl_info *gl_info;
     GLuint buffer_object;
+#else  /* STAGING_CSMT */
+    struct wined3d_gl_bo *buffer;
+#endif /* STAGING_CSMT */
     unsigned int i;
 
     TRACE("texture %p.\n", texture);
 
     for (i = 0; i < sub_count; ++i)
     {
+#if !defined(STAGING_CSMT)
         if (!(buffer_object = texture->sub_resources[i].buffer_object))
             continue;
 
         TRACE("Deleting buffer object %u.\n", buffer_object);
+#else  /* STAGING_CSMT */
+        if (texture->sub_resources[i].buffer != texture->sub_resources[i].map_buffer)
+            ERR("Buffer is %p, map buffer is %p.\n", texture->sub_resources[i].buffer,
+                    texture->sub_resources[i].map_buffer);
+
+        if (!(buffer = texture->sub_resources[i].buffer))
+            continue;
+
+        TRACE("Deleting buffer object %u.\n", buffer->name);
+#endif /* STAGING_CSMT */
 
         /* We may not be able to get a context in wined3d_texture_cleanup() in
          * general, but if a buffer object was previously created we can. */
         if (!context)
+#if !defined(STAGING_CSMT)
         {
             context = context_acquire(device, NULL);
             gl_info = context->gl_info;
         }
 
         GL_EXTCALL(glDeleteBuffers(1, &buffer_object));
+#else  /* STAGING_CSMT */
+            context = context_acquire(device, NULL);
+
+        wined3d_device_release_bo(device, buffer, context);
+        texture->sub_resources[i].buffer = NULL;
+        texture->sub_resources[i].map_buffer = NULL;
+#endif /* STAGING_CSMT */
     }
     if (context)
         context_release(context);
@@ -815,6 +885,12 @@ ULONG CDECL wined3d_texture_incref(struct wined3d_texture *texture)
 static void wined3d_texture_cleanup_sync(struct wined3d_texture *texture)
 {
     wined3d_texture_sub_resources_destroyed(texture);
+#if defined(STAGING_CSMT)
+
+    if (texture->resource.map_binding == WINED3D_LOCATION_USER_MEMORY)
+        wined3d_resource_wait_idle(&texture->resource);
+
+#endif /* STAGING_CSMT */
     resource_cleanup(&texture->resource);
     wined3d_resource_wait_idle(&texture->resource);
     wined3d_texture_cleanup(texture);
@@ -842,6 +918,15 @@ ULONG CDECL wined3d_texture_decref(struct wined3d_texture *texture)
     {
         wined3d_texture_sub_resources_destroyed(texture);
         texture->resource.parent_ops->wined3d_object_destroyed(texture->resource.parent);
+#if defined(STAGING_CSMT)
+
+        /* Wait for the CS to finish operations on this texture when user memory was in use.
+         * The application is allowed to free the memory after texture / surface destruction
+         * returns. */
+        if (texture->resource.map_binding == WINED3D_LOCATION_USER_MEMORY)
+            wined3d_resource_wait_idle(&texture->resource);
+
+#endif /* STAGING_CSMT */
         resource_cleanup(&texture->resource);
         wined3d_cs_emit_destroy_object(texture->resource.device->cs, wined3d_texture_destroy_object, texture);
     }
@@ -893,7 +978,11 @@ void wined3d_texture_load(struct wined3d_texture *texture,
         TRACE("Reloading because of color key value change.\n");
         for (i = 0; i < sub_count; i++)
         {
+#if !defined(STAGING_CSMT)
             if (!texture->texture_ops->texture_load_location(texture, i, context, texture->resource.map_binding))
+#else  /* STAGING_CSMT */
+            if (!wined3d_texture_load_location(texture, i, context, texture->resource.map_binding))
+#endif /* STAGING_CSMT */
                 ERR("Failed to load location %s.\n", wined3d_debug_location(texture->resource.map_binding));
             else
                 wined3d_texture_invalidate_location(texture, i, ~texture->resource.map_binding);
@@ -911,7 +1000,11 @@ void wined3d_texture_load(struct wined3d_texture *texture,
     /* Reload the surfaces if the texture is marked dirty. */
     for (i = 0; i < sub_count; ++i)
     {
+#if !defined(STAGING_CSMT)
         if (!texture->texture_ops->texture_load_location(texture, i, context,
+#else  /* STAGING_CSMT */
+        if (!wined3d_texture_load_location(texture, i, context,
+#endif /* STAGING_CSMT */
                 srgb ? WINED3D_LOCATION_TEXTURE_SRGB : WINED3D_LOCATION_TEXTURE_RGB))
             ERR("Failed to load location (srgb %#x).\n", srgb);
     }
@@ -920,10 +1013,15 @@ void wined3d_texture_load(struct wined3d_texture *texture,
 
 void CDECL wined3d_texture_preload(struct wined3d_texture *texture)
 {
+#if !defined(STAGING_CSMT)
     struct wined3d_context *context;
     context = context_acquire(texture->resource.device, NULL);
     wined3d_texture_load(texture, context, texture->flags & WINED3D_TEXTURE_IS_SRGB);
     context_release(context);
+#else  /* STAGING_CSMT */
+    const struct wined3d_device *device = texture->resource.device;
+    wined3d_cs_emit_texture_preload(device->cs, texture);
+#endif /* STAGING_CSMT */
 }
 
 void * CDECL wined3d_texture_get_parent(const struct wined3d_texture *texture)
@@ -986,6 +1084,15 @@ DWORD CDECL wined3d_texture_set_lod(struct wined3d_texture *texture, DWORD lod)
 
     if (texture->lod != lod)
     {
+#if defined(STAGING_CSMT)
+        if (wined3d_settings.cs_multithreaded)
+        {
+            struct wined3d_device *device = texture->resource.device;
+            FIXME("Waiting for cs.\n");
+            device->cs->ops->finish(device->cs);
+        }
+
+#endif /* STAGING_CSMT */
         texture->lod = lod;
 
         texture->texture_rgb.base_level = ~0u;
@@ -1106,7 +1213,14 @@ HRESULT CDECL wined3d_texture_update_desc(struct wined3d_texture *texture, UINT
     }
 
     if (device->d3d_initialized)
+#if !defined(STAGING_CSMT)
         texture->resource.resource_ops->resource_unload(&texture->resource);
+#else  /* STAGING_CSMT */
+    {
+        wined3d_cs_emit_evict_resource(device->cs, &texture->resource);
+        device->cs->ops->finish(device->cs);
+    }
+#endif /* STAGING_CSMT */
 
     sub_resource = &texture->sub_resources[0];
     surface = sub_resource->u.surface;
@@ -1117,6 +1231,9 @@ HRESULT CDECL wined3d_texture_update_desc(struct wined3d_texture *texture, UINT
     }
 
     wined3d_resource_free_sysmem(&texture->resource);
+#if defined(STAGING_CSMT)
+    texture->resource.map_heap_memory = NULL;
+#endif /* STAGING_CSMT */
 
     if ((texture->row_pitch = pitch))
         texture->slice_pitch = height * pitch;
@@ -1173,18 +1290,31 @@ HRESULT CDECL wined3d_texture_update_desc(struct wined3d_texture *texture, UINT
     wined3d_texture_invalidate_location(texture, 0, ~valid_location);
 
     if (create_dib)
+#if !defined(STAGING_CSMT)
         wined3d_surface_create_dc(surface);
+#else  /* STAGING_CSMT */
+    {
+        HDC dc;
+        wined3d_texture_get_dc(texture, 0, &dc);
+        wined3d_texture_release_dc(texture, 0, dc);
+    }
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
 
 /* Context activation is done by the caller. */
 static void wined3d_texture_prepare_buffer_object(struct wined3d_texture *texture,
+#if !defined(STAGING_CSMT)
         unsigned int sub_resource_idx, const struct wined3d_gl_info *gl_info)
+#else  /* STAGING_CSMT */
+        unsigned int sub_resource_idx, struct wined3d_context *context)
+#endif /* STAGING_CSMT */
 {
     struct wined3d_texture_sub_resource *sub_resource;
 
     sub_resource = &texture->sub_resources[sub_resource_idx];
+#if !defined(STAGING_CSMT)
     if (sub_resource->buffer_object)
         return;
 
@@ -1196,6 +1326,25 @@ static void wined3d_texture_prepare_buffer_object(struct wined3d_texture *textur
 
     TRACE("Created buffer object %u for texture %p, sub-resource %u.\n",
             sub_resource->buffer_object, texture, sub_resource_idx);
+#else  /* STAGING_CSMT */
+    if (sub_resource->buffer)
+        return;
+
+    sub_resource->buffer = wined3d_device_get_bo(texture->resource.device,
+            sub_resource->size, GL_STREAM_DRAW, GL_PIXEL_UNPACK_BUFFER, context);
+    sub_resource->map_buffer = sub_resource->buffer;
+
+    TRACE("Created buffer object %u for texture %p, sub-resource %u.\n",
+            sub_resource->buffer->name, texture, sub_resource_idx);
+
+    /* FIXME: PBOs are (still) allocated per sub resource, this is global for the texture. It *should* work
+     * since whether we use PBOs is a per-texture choice, but it is shaky.
+     *
+     * This is needed because otherwise the next unmap will re-assign it with the resource_changed
+     * message. Freeing the actual memory and setting the read pointer to 0 is
+     * the task of the worker thread. */
+    texture->resource.map_heap_memory = NULL;
+#endif /* STAGING_CSMT */
 }
 
 static void wined3d_texture_force_reload(struct wined3d_texture *texture)
@@ -1313,6 +1462,9 @@ BOOL wined3d_texture_prepare_location(struct wined3d_texture *texture, unsigned
                 ERR("Failed to allocate system memory.\n");
                 return FALSE;
             }
+#if defined(STAGING_CSMT)
+            texture->resource.heap_memory = texture->resource.map_heap_memory;
+#endif /* STAGING_CSMT */
             return TRUE;
 
         case WINED3D_LOCATION_USER_MEMORY:
@@ -1321,7 +1473,11 @@ BOOL wined3d_texture_prepare_location(struct wined3d_texture *texture, unsigned
             return TRUE;
 
         case WINED3D_LOCATION_BUFFER:
+#if !defined(STAGING_CSMT)
             wined3d_texture_prepare_buffer_object(texture, sub_resource_idx, context->gl_info);
+#else  /* STAGING_CSMT */
+            wined3d_texture_prepare_buffer_object(texture, sub_resource_idx, context);
+#endif /* STAGING_CSMT */
             return TRUE;
 
         case WINED3D_LOCATION_TEXTURE_RGB:
@@ -1392,7 +1548,11 @@ HRESULT CDECL wined3d_texture_add_dirty_region(struct wined3d_texture *texture,
         WARN("Ignoring dirty_region %s.\n", debug_box(dirty_region));
 
     context = context_acquire(texture->resource.device, NULL);
+#if !defined(STAGING_CSMT)
     if (!texture->texture_ops->texture_load_location(texture, sub_resource_idx,
+#else  /* STAGING_CSMT */
+    if (!wined3d_texture_load_location(texture, sub_resource_idx,
+#endif /* STAGING_CSMT */
             context, texture->resource.map_binding))
     {
         ERR("Failed to load location %s.\n", wined3d_debug_location(texture->resource.map_binding));
@@ -1438,6 +1598,9 @@ static HRESULT wined3d_texture_upload_data(struct wined3d_texture *texture,
     return WINED3D_OK;
 }
 
+#if defined(STAGING_CSMT)
+/* Context activation is done by the caller. */
+#endif /* STAGING_CSMT */
 static void texture2d_upload_data(struct wined3d_texture *texture, unsigned int sub_resource_idx,
         const struct wined3d_context *context, const struct wined3d_sub_resource_data *data)
 {
@@ -1460,7 +1623,12 @@ static void texture2d_upload_data(struct wined3d_texture *texture, unsigned int
 static BOOL texture2d_load_location(struct wined3d_texture *texture, unsigned int sub_resource_idx,
         struct wined3d_context *context, DWORD location)
 {
+#if !defined(STAGING_CSMT)
     return SUCCEEDED(surface_load_location(texture->sub_resources[sub_resource_idx].u.surface, context, location));
+#else  /* STAGING_CSMT */
+    surface_load_location(texture->sub_resources[sub_resource_idx].u.surface, context, location);
+    return TRUE;
+#endif /* STAGING_CSMT */
 }
 
 /* Context activation is done by the caller. */
@@ -1598,7 +1766,11 @@ static void wined3d_texture_unload(struct wined3d_resource *resource)
         struct wined3d_texture_sub_resource *sub_resource = &texture->sub_resources[i];
 
         if (resource->pool != WINED3D_POOL_DEFAULT
+#if !defined(STAGING_CSMT)
                 && texture->texture_ops->texture_load_location(texture, i, context, resource->map_binding))
+#else  /* STAGING_CSMT */
+                && wined3d_texture_load_location(texture, i, context, resource->map_binding))
+#endif /* STAGING_CSMT */
         {
             wined3d_texture_invalidate_location(texture, i, ~resource->map_binding);
         }
@@ -1613,8 +1785,13 @@ static void wined3d_texture_unload(struct wined3d_resource *resource)
             wined3d_texture_invalidate_location(texture, i, ~WINED3D_LOCATION_DISCARDED);
         }
 
+#if !defined(STAGING_CSMT)
         if (sub_resource->buffer_object)
             wined3d_texture_remove_buffer_object(texture, i, context->gl_info);
+#else  /* STAGING_CSMT */
+        if (sub_resource->buffer)
+            wined3d_texture_remove_buffer_object(texture, i, context);
+#endif /* STAGING_CSMT */
 
         if (resource->type == WINED3D_RTYPE_TEXTURE_2D)
         {
@@ -1639,6 +1816,89 @@ static void wined3d_texture_unload(struct wined3d_resource *resource)
     wined3d_texture_unload_gl_texture(texture);
 }
 
+#if defined(STAGING_CSMT)
+void *wined3d_texture_map_internal(struct wined3d_texture *texture, unsigned int sub_resource_idx, DWORD flags)
+{
+    struct wined3d_device *device = texture->resource.device;
+    struct wined3d_context *context = NULL;
+    void *data;
+    BOOL ret;
+    struct wined3d_texture_sub_resource *sub_resource = wined3d_texture_get_sub_resource(texture, sub_resource_idx);
+    struct wined3d_bo_address bo_data;
+
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+
+    if (flags & WINED3D_MAP_DISCARD)
+    {
+        /* MSDN says DISCARD on sub resource 0 discards the entire texture, whereas DISCARD on all other
+         * sub resources is ignored. Currently we can do it the MSDN way for sysmem, but not for buffers. */
+        if (sub_resource_idx != 0)
+            FIXME("Discard of sub resource %u.\n", sub_resource_idx);
+
+        switch(texture->resource.map_binding)
+        {
+            case WINED3D_LOCATION_BUFFER:
+                sub_resource->map_buffer = wined3d_device_get_bo(device, sub_resource->size,
+                        GL_STREAM_DRAW, GL_PIXEL_UNPACK_BUFFER, context);
+                if (!sub_resource->buffer)
+                    sub_resource->buffer = sub_resource->map_buffer;
+                ret = !!sub_resource->map_buffer;
+                break;
+
+            case WINED3D_LOCATION_SYSMEM:
+                if (!sub_resource_idx)
+                    wined3d_resource_allocate_sysmem(&texture->resource);
+                ret = !!texture->resource.heap_memory;
+                break;
+
+            default:
+                ret = wined3d_texture_prepare_location(texture, sub_resource_idx,
+                        context, texture->resource.map_binding);
+        }
+        TRACE("WINED3D_MAP_DISCARD flag passed, marking %s as up to date.\n",
+                wined3d_debug_location(texture->resource.map_binding));
+        if (ret)
+            wined3d_texture_validate_location(texture, sub_resource_idx, texture->resource.map_binding);
+    }
+    else
+    {
+        if (texture->resource.usage & WINED3DUSAGE_DYNAMIC)
+            WARN_(d3d_perf)("Mapping a dynamic texture without WINED3D_MAP_DISCARD.\n");
+        ret = wined3d_texture_load_location(texture,
+                sub_resource_idx, context, texture->resource.map_binding);
+    }
+
+    if (!ret)
+    {
+        ERR("Failed to prepare location.\n");
+        context_release(context);
+        return NULL;
+    }
+
+    if (!(flags & WINED3D_MAP_READONLY))
+        sub_resource->unmap_dirtify = TRUE;
+
+    wined3d_texture_get_memory(texture, sub_resource_idx, &bo_data, texture->resource.map_binding, TRUE);
+    data = wined3d_texture_map_bo_address(&bo_data, sub_resource->size,
+            context->gl_info, GL_PIXEL_UNPACK_BUFFER, flags);
+
+    if (context)
+        context_release(context);
+
+    if (texture->swapchain && texture->swapchain->front_buffer == texture)
+    {
+        RECT *r = &texture->swapchain->front_buffer_update;
+
+        /* FIXME: Preserve the map box... */
+        SetRect(r, 0, 0, texture->resource.width, texture->resource.height);
+        TRACE("Mapped front buffer %s.\n", wine_dbgstr_rect(r));
+    }
+
+    return data;
+}
+
+#endif /* STAGING_CSMT */
 static HRESULT texture_resource_sub_resource_map(struct wined3d_resource *resource, unsigned int sub_resource_idx,
         struct wined3d_map_desc *map_desc, const struct wined3d_box *box, DWORD flags)
 {
@@ -1646,6 +1906,7 @@ static HRESULT texture_resource_sub_resource_map(struct wined3d_resource *resour
     struct wined3d_texture_sub_resource *sub_resource;
     struct wined3d_device *device = resource->device;
     unsigned int fmt_flags = resource->format_flags;
+#if !defined(STAGING_CSMT)
     const struct wined3d_gl_info *gl_info = NULL;
     struct wined3d_context *context = NULL;
     struct wined3d_texture *texture;
@@ -1653,6 +1914,11 @@ static HRESULT texture_resource_sub_resource_map(struct wined3d_resource *resour
     unsigned int texture_level;
     BYTE *base_memory;
     BOOL ret;
+#else  /* STAGING_CSMT */
+    struct wined3d_texture *texture;
+    unsigned int texture_level;
+    BYTE *base_memory;
+#endif /* STAGING_CSMT */
 
     TRACE("resource %p, sub_resource_idx %u, map_desc %p, box %s, flags %#x.\n",
             resource, sub_resource_idx, map_desc, debug_box(box), flags);
@@ -1699,14 +1965,20 @@ static HRESULT texture_resource_sub_resource_map(struct wined3d_resource *resour
 
     flags = wined3d_resource_sanitize_map_flags(resource, flags);
 
+#if !defined(STAGING_CSMT)
     if (device->d3d_initialized)
     {
         context = context_acquire(device, NULL);
         gl_info = context->gl_info;
     }
+#else  /* STAGING_CSMT */
+    if (flags & WINED3D_MAP_NOOVERWRITE)
+        FIXME("WINED3D_MAP_NOOVERWRITE is not implemented yet.\n");
+#endif /* STAGING_CSMT */
 
     if (flags & WINED3D_MAP_DISCARD)
     {
+#if !defined(STAGING_CSMT)
         TRACE("WINED3D_MAP_DISCARD flag passed, marking %s as up to date.\n",
                 wined3d_debug_location(texture->resource.map_binding));
         if ((ret = wined3d_texture_prepare_location(texture, sub_resource_idx,
@@ -1738,6 +2010,24 @@ static HRESULT texture_resource_sub_resource_map(struct wined3d_resource *resour
 
     if (context)
         context_release(context);
+#else  /* STAGING_CSMT */
+        switch (resource->map_binding)
+        {
+            case WINED3D_LOCATION_BUFFER:
+            case WINED3D_LOCATION_SYSMEM:
+                break;
+
+            default:
+                FIXME("Implement discard maps with %s map binding.\n",
+                        wined3d_debug_location(texture->resource.map_binding));
+                wined3d_resource_wait_idle(&texture->resource);
+        }
+    }
+    else
+        wined3d_resource_wait_idle(&texture->resource);
+
+    base_memory = wined3d_cs_emit_texture_map(device->cs, texture, sub_resource_idx, flags);
+#endif /* STAGING_CSMT */
 
     if (fmt_flags & WINED3DFMT_FLAG_BROKEN_PITCH)
     {
@@ -1773,6 +2063,7 @@ static HRESULT texture_resource_sub_resource_map(struct wined3d_resource *resour
         }
     }
 
+#if !defined(STAGING_CSMT)
     if (texture->swapchain && texture->swapchain->front_buffer == texture)
     {
         RECT *r = &texture->swapchain->front_buffer_update;
@@ -1784,6 +2075,7 @@ static HRESULT texture_resource_sub_resource_map(struct wined3d_resource *resour
         TRACE("Mapped front buffer %s.\n", wine_dbgstr_rect(r));
     }
 
+#endif /* STAGING_CSMT */
     ++resource->map_count;
     ++sub_resource->map_count;
 
@@ -1793,14 +2085,71 @@ static HRESULT texture_resource_sub_resource_map(struct wined3d_resource *resour
     return WINED3D_OK;
 }
 
+#if defined(STAGING_CSMT)
+void wined3d_texture_unmap_internal(struct wined3d_texture *texture, unsigned int sub_resource_idx)
+{
+    struct wined3d_context *context = NULL;
+    struct wined3d_bo_address data;
+
+    if (texture->resource.device->d3d_initialized)
+        context = context_acquire(texture->resource.device, NULL);
+
+    wined3d_texture_get_memory(texture, sub_resource_idx, &data, texture->resource.map_binding, TRUE);
+    wined3d_texture_unmap_bo_address(&data, context->gl_info, GL_PIXEL_UNPACK_BUFFER);
+
+    if (context)
+        context_release(context);
+
+    if (texture->swapchain && texture->swapchain->front_buffer == texture)
+    {
+        struct wined3d_texture_sub_resource *sub_resource = &texture->sub_resources[sub_resource_idx];
+
+        if (!(sub_resource->locations & (WINED3D_LOCATION_DRAWABLE | WINED3D_LOCATION_TEXTURE_RGB)))
+            texture->swapchain->swapchain_ops->swapchain_frontbuffer_updated(texture->swapchain);
+    }
+    else if (texture->resource.format_flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL))
+    {
+        FIXME("Depth / stencil buffer locking is not implemented.\n");
+    }
+}
+
+void wined3d_texture_changed(struct wined3d_texture *texture, unsigned int sub_resource_idx,
+        struct wined3d_gl_bo *swap_buffer, void *swap_heap_memory)
+{
+    struct wined3d_texture_sub_resource *sub_resource = &texture->sub_resources[sub_resource_idx];
+
+    if (swap_buffer && swap_buffer != sub_resource->buffer)
+    {
+        struct wined3d_device *device = texture->resource.device;
+        struct wined3d_context *context = context_acquire(device, NULL);
+        wined3d_device_release_bo(device, sub_resource->buffer, context);
+        context_release(context);
+        sub_resource->buffer = swap_buffer;
+    }
+
+    if (swap_heap_memory && swap_heap_memory != texture->resource.heap_memory && !sub_resource_idx)
+    {
+        wined3d_resource_free_sysmem(&texture->resource);
+        texture->resource.heap_memory = swap_heap_memory;
+    }
+
+    wined3d_texture_invalidate_location(texture, sub_resource_idx, ~texture->resource.map_binding);
+}
+
+#endif /* STAGING_CSMT */
 static HRESULT texture_resource_sub_resource_unmap(struct wined3d_resource *resource, unsigned int sub_resource_idx)
 {
     struct wined3d_texture_sub_resource *sub_resource;
+#if !defined(STAGING_CSMT)
     struct wined3d_device *device = resource->device;
     const struct wined3d_gl_info *gl_info = NULL;
     struct wined3d_context *context = NULL;
     struct wined3d_texture *texture;
     struct wined3d_bo_address data;
+#else  /* STAGING_CSMT */
+    struct wined3d_texture *texture;
+    struct wined3d_device *device = resource->device;
+#endif /* STAGING_CSMT */
 
     TRACE("resource %p, sub_resource_idx %u.\n", resource, sub_resource_idx);
 
@@ -1816,6 +2165,7 @@ static HRESULT texture_resource_sub_resource_unmap(struct wined3d_resource *reso
         return WINEDDERR_NOTLOCKED;
     }
 
+#if !defined(STAGING_CSMT)
     if (device->d3d_initialized)
     {
         context = context_acquire(device, NULL);
@@ -1836,6 +2186,15 @@ static HRESULT texture_resource_sub_resource_unmap(struct wined3d_resource *reso
     else if (resource->format_flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL))
     {
         FIXME("Depth / stencil buffer locking is not implemented.\n");
+#else  /* STAGING_CSMT */
+    wined3d_cs_emit_texture_unmap(device->cs, texture, sub_resource_idx);
+
+    if (sub_resource->unmap_dirtify)
+    {
+        wined3d_cs_emit_texture_changed(device->cs, texture, sub_resource_idx, sub_resource->map_buffer,
+                resource->map_heap_memory);
+        sub_resource->unmap_dirtify = FALSE;
+#endif /* STAGING_CSMT */
     }
 
     --sub_resource->map_count;
@@ -2067,11 +2426,23 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
 
             TRACE("Created surface level %u, layer %u @ %p.\n", i, j, surface);
 
+#if !defined(STAGING_CSMT)
             if (((desc->usage & WINED3DUSAGE_OWNDC) || (device->wined3d->flags & WINED3D_NO3D))
                     && FAILED(hr = wined3d_surface_create_dc(surface)))
             {
                 wined3d_texture_cleanup_sync(texture);
                 return hr;
+#else  /* STAGING_CSMT */
+            if ((desc->usage & WINED3DUSAGE_OWNDC) || (device->wined3d->flags & WINED3D_NO3D))
+            {
+                HDC dc;
+                if (FAILED(hr = wined3d_texture_get_dc(texture, idx, &dc)))
+                {
+                    wined3d_texture_cleanup_sync(texture);
+                    return hr;
+                }
+                wined3d_texture_release_dc(texture, idx, dc);
+#endif /* STAGING_CSMT */
             }
         }
     }
@@ -2079,6 +2450,9 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
     return WINED3D_OK;
 }
 
+#if defined(STAGING_CSMT)
+/* Context activation is done by the caller. */
+#endif /* STAGING_CSMT */
 static void texture3d_upload_data(struct wined3d_texture *texture, unsigned int sub_resource_idx,
         const struct wined3d_context *context, const struct wined3d_sub_resource_data *data)
 {
@@ -2274,6 +2648,9 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
     if (wined3d_texture_use_pbo(texture, gl_info))
     {
         wined3d_resource_free_sysmem(&texture->resource);
+#if defined(STAGING_CSMT)
+        texture->resource.map_heap_memory = NULL;
+#endif /* STAGING_CSMT */
         texture->resource.map_binding = WINED3D_LOCATION_BUFFER;
     }
 
@@ -2618,13 +2995,47 @@ HRESULT CDECL wined3d_texture_create(struct wined3d_device *device, const struct
     return WINED3D_OK;
 }
 
+#if defined(STAGING_CSMT)
+void wined3d_texture_get_dc_cs(struct wined3d_texture *texture, unsigned int sub_resource_idx)
+{
+    struct wined3d_device *device = texture->resource.device;
+    struct wined3d_context *context = NULL;
+    struct wined3d_texture_sub_resource *sub_resource = &texture->sub_resources[sub_resource_idx];
+    struct wined3d_surface *surface = sub_resource->u.surface;
+
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+
+    wined3d_texture_load_location(texture, sub_resource_idx, context, texture->resource.map_binding);
+    wined3d_texture_invalidate_location(texture, sub_resource_idx, ~texture->resource.map_binding);
+
+    if (!surface->dc)
+        texture->dc_hr = wined3d_surface_create_dc(surface);
+    else
+        texture->dc_hr = WINED3D_OK;
+    if (context)
+        context_release(context);
+    if (FAILED(texture->dc_hr))
+        return;
+
+    if (!(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
+        texture->flags |= WINED3D_TEXTURE_DC_IN_USE;
+    ++texture->resource.map_count;
+    ++sub_resource->map_count;
+}
+
+#endif /* STAGING_CSMT */
 HRESULT CDECL wined3d_texture_get_dc(struct wined3d_texture *texture, unsigned int sub_resource_idx, HDC *dc)
 {
     struct wined3d_device *device = texture->resource.device;
     struct wined3d_texture_sub_resource *sub_resource;
+#if !defined(STAGING_CSMT)
     struct wined3d_context *context = NULL;
     struct wined3d_surface *surface;
     HRESULT hr = WINED3D_OK;
+#else  /* STAGING_CSMT */
+    struct wined3d_surface *surface;
+#endif /* STAGING_CSMT */
 
     TRACE("texture %p, sub_resource_idx %u, dc %p.\n", texture, sub_resource_idx, dc);
 
@@ -2642,6 +3053,7 @@ HRESULT CDECL wined3d_texture_get_dc(struct wined3d_texture *texture, unsigned i
     if (texture->resource.map_count && !(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
         return WINED3DERR_INVALIDCALL;
 
+#if !defined(STAGING_CSMT)
     if (device->d3d_initialized)
         context = context_acquire(device, NULL);
 
@@ -2664,6 +3076,32 @@ HRESULT CDECL wined3d_texture_get_dc(struct wined3d_texture *texture, unsigned i
     TRACE("Returning dc %p.\n", *dc);
 
     return hr;
+#else  /* STAGING_CSMT */
+    wined3d_cs_emit_get_dc(device->cs, texture, sub_resource_idx);
+    if (FAILED(texture->dc_hr))
+        return texture->dc_hr;
+
+    *dc = surface->dc;
+    TRACE("Returning dc %p.\n", *dc);
+
+    return WINED3D_OK;
+}
+
+void wined3d_texture_release_dc_cs(struct wined3d_texture *texture, unsigned int sub_resource_idx)
+{
+    struct wined3d_device *device = texture->resource.device;
+    struct wined3d_texture_sub_resource *sub_resource = &texture->sub_resources[sub_resource_idx];
+    struct wined3d_surface *surface = sub_resource->u.surface;
+
+    if (!(texture->resource.usage & WINED3DUSAGE_OWNDC) && !(device->wined3d->flags & WINED3D_NO3D))
+        wined3d_surface_destroy_dc(surface);
+
+    --sub_resource->map_count;
+    if (!--texture->resource.map_count && texture->update_map_binding)
+        wined3d_texture_update_map_binding(texture);
+    if (!(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
+        texture->flags &= ~WINED3D_TEXTURE_DC_IN_USE;
+#endif /* STAGING_CSMT */
 }
 
 HRESULT CDECL wined3d_texture_release_dc(struct wined3d_texture *texture, unsigned int sub_resource_idx, HDC dc)
@@ -2694,6 +3132,7 @@ HRESULT CDECL wined3d_texture_release_dc(struct wined3d_texture *texture, unsign
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     if (!(texture->resource.usage & WINED3DUSAGE_OWNDC) && !(device->wined3d->flags & WINED3D_NO3D))
         wined3d_surface_destroy_dc(surface);
 
@@ -2702,6 +3141,141 @@ HRESULT CDECL wined3d_texture_release_dc(struct wined3d_texture *texture, unsign
         wined3d_texture_update_map_binding(texture);
     if (!(texture->flags & WINED3D_TEXTURE_GET_DC_LENIENT))
         texture->flags &= ~WINED3D_TEXTURE_DC_IN_USE;
+#else  /* STAGING_CSMT */
+    wined3d_cs_emit_release_dc(device->cs, texture, sub_resource_idx);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
+#if defined(STAGING_CSMT)
+
+static BOOL wined3d_texture_copy_sysmem_location(struct wined3d_texture *texture,
+        unsigned int sub_resource_idx, struct wined3d_context *context, DWORD location)
+{
+    struct wined3d_device *device = texture->resource.device;
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_bo_address dst, src;
+    UINT size = texture->sub_resources[sub_resource_idx].size;
+
+    wined3d_texture_prepare_location(texture, sub_resource_idx, context, location);
+
+    wined3d_texture_get_memory(texture, sub_resource_idx, &dst, location, FALSE);
+    wined3d_texture_get_memory(texture, sub_resource_idx, &src,
+            texture->sub_resources[sub_resource_idx].locations, FALSE);
+
+    if (dst.buffer_object)
+    {
+        context = context_acquire(device, NULL);
+        gl_info = context->gl_info;
+        GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, dst.buffer_object));
+        GL_EXTCALL(glBufferSubData(GL_PIXEL_UNPACK_BUFFER, 0, size, src.addr));
+        GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0));
+        checkGLcall("Upload PBO");
+        context_release(context);
+        return TRUE;
+    }
+    if (src.buffer_object)
+    {
+        context = context_acquire(device, NULL);
+        gl_info = context->gl_info;
+        GL_EXTCALL(glBindBuffer(GL_PIXEL_PACK_BUFFER, src.buffer_object));
+        GL_EXTCALL(glGetBufferSubData(GL_PIXEL_PACK_BUFFER, 0, size, dst.addr));
+        GL_EXTCALL(glBindBuffer(GL_PIXEL_PACK_BUFFER, 0));
+        checkGLcall("Download PBO");
+        context_release(context);
+        return TRUE;
+    }
+    memcpy(dst.addr, src.addr, size);
+    return TRUE;
+}
+
+static DWORD resource_access_from_location(DWORD location)
+{
+    switch (location)
+    {
+        case WINED3D_LOCATION_SYSMEM:
+        case WINED3D_LOCATION_USER_MEMORY:
+        case WINED3D_LOCATION_BUFFER:
+            return WINED3D_RESOURCE_ACCESS_CPU;
+
+        case WINED3D_LOCATION_DRAWABLE:
+        case WINED3D_LOCATION_TEXTURE_SRGB:
+        case WINED3D_LOCATION_TEXTURE_RGB:
+        case WINED3D_LOCATION_RB_MULTISAMPLE:
+        case WINED3D_LOCATION_RB_RESOLVED:
+            return WINED3D_RESOURCE_ACCESS_GPU;
+
+        default:
+            FIXME("Unhandled location %#x.\n", location);
+            return 0;
+    }
+}
+
+/* Context activation is done by the caller. Context may be NULL. */
+BOOL wined3d_texture_load_location(struct wined3d_texture *texture, unsigned int sub_resource_idx,
+        struct wined3d_context *context, DWORD location)
+{
+    BOOL ret;
+    DWORD current = texture->sub_resources[sub_resource_idx].locations;
+    struct wined3d_surface *surface = texture->sub_resources[sub_resource_idx].u.surface;
+    unsigned int sub_resource_w, sub_resource_h;
+
+    TRACE("Texture %p, sub_resource %u, location %s.\n", texture, sub_resource_idx,
+            wined3d_debug_location(location));
+
+    sub_resource_w = wined3d_texture_get_level_width(texture, sub_resource_idx % texture->level_count);
+    sub_resource_h = wined3d_texture_get_level_height(texture, sub_resource_idx % texture->level_count);
+
+    if ((current & location) && (!(surface && (texture->resource.usage & WINED3DUSAGE_DEPTHSTENCIL))
+            || (surface->ds_current_size.cx == sub_resource_w
+            && surface->ds_current_size.cy == sub_resource_h)))
+    {
+        TRACE("Location (%#x) is already up to date.\n", location);
+        return TRUE;
+    }
+
+    if (WARN_ON(d3d))
+    {
+        DWORD required_access = resource_access_from_location(location);
+        if ((texture->resource.access_flags & required_access) != required_access)
+            WARN("Operation requires %#x access, but texture only has %#x.\n",
+                 required_access, texture->resource.access_flags);
+    }
+
+    if (!current)
+    {
+        ERR("Texture %p, sub resource %u does not have any up to date location.\n", texture, sub_resource_idx);
+        wined3d_texture_validate_location(texture, sub_resource_idx, WINED3D_LOCATION_DISCARDED);
+        wined3d_texture_load_location(texture, sub_resource_idx, context, location);
+        return TRUE;
+    }
+
+    if (texture->sub_resources[sub_resource_idx].locations & WINED3D_LOCATION_DISCARDED)
+    {
+        wined3d_texture_prepare_location(texture, sub_resource_idx, context, location);
+        ret = TRUE;
+    }
+    else
+    {
+        static const DWORD sysmem_locations = WINED3D_LOCATION_SYSMEM | WINED3D_LOCATION_USER_MEMORY
+                | WINED3D_LOCATION_BUFFER;
+
+        if ((location & sysmem_locations) && (current & sysmem_locations))
+            ret = wined3d_texture_copy_sysmem_location(texture, sub_resource_idx, context, location);
+        else
+            ret = texture->texture_ops->texture_load_location(texture, sub_resource_idx, context, location);
+    }
+
+    if (ret)
+    {
+        wined3d_texture_validate_location(texture, sub_resource_idx, location);
+
+        if (surface && texture->resource.usage & WINED3DUSAGE_DEPTHSTENCIL)
+        {
+            surface->ds_current_size.cx = sub_resource_w;
+            surface->ds_current_size.cy = sub_resource_h;
+        }
+    }
+    return ret;
+}
+#endif /* STAGING_CSMT */
diff --git a/dlls/wined3d/utils.c b/dlls/wined3d/utils.c
--- a/dlls/wined3d/utils.c
+++ b/dlls/wined3d/utils.c
@@ -4494,7 +4494,11 @@ void get_projection_matrix(const struct wined3d_context *context, const struct w
         float y_offset = context->render_offscreen
                 ? (center_offset - (2.0f * y) - h) / h
                 : (center_offset - (2.0f * y) - h) / -h;
+#if !defined(STAGING_CSMT)
         enum wined3d_depth_buffer_type zenable = state->fb->depth_stencil ?
+#else  /* STAGING_CSMT */
+        enum wined3d_depth_buffer_type zenable = state->fb.depth_stencil ?
+#endif /* STAGING_CSMT */
                 state->render_states[WINED3D_RS_ZENABLE] : WINED3D_ZB_FALSE;
         float z_scale = zenable ? 2.0f : 0.0f;
         float z_offset = zenable ? -1.0f : 0.0f;
@@ -5291,7 +5295,11 @@ void gen_ffp_frag_op(const struct wined3d_context *context, const struct wined3d
                 break;
         }
     }
+#if !defined(STAGING_CSMT)
     settings->sRGB_write = !gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, state, state->fb);
+#else  /* STAGING_CSMT */
+    settings->sRGB_write = !gl_info->supported[ARB_FRAMEBUFFER_SRGB] && needs_srgb_write(context, state, &state->fb);
+#endif /* STAGING_CSMT */
     if (d3d_info->vs_clipping || !use_vs(state) || !state->render_states[WINED3D_RS_CLIPPING]
             || !state->render_states[WINED3D_RS_CLIPPLANEENABLE])
     {
diff --git a/dlls/wined3d/volume.c b/dlls/wined3d/volume.c
--- a/dlls/wined3d/volume.c
+++ b/dlls/wined3d/volume.c
@@ -119,6 +119,7 @@ static void wined3d_volume_download_data(struct wined3d_volume *volume,
 
 }
 
+#if !defined(STAGING_CSMT)
 static DWORD volume_access_from_location(DWORD location)
 {
     switch (location)
@@ -140,6 +141,7 @@ static DWORD volume_access_from_location(DWORD location)
     }
 }
 
+#endif /* STAGING_CSMT */
 /* Context activation is done by the caller. */
 static void wined3d_volume_srgb_transfer(struct wined3d_volume *volume,
         struct wined3d_context *context, BOOL dest_is_srgb)
@@ -170,7 +172,9 @@ static void wined3d_volume_srgb_transfer(struct wined3d_volume *volume,
 BOOL wined3d_volume_load_location(struct wined3d_volume *volume,
         struct wined3d_context *context, DWORD location)
 {
+#if !defined(STAGING_CSMT)
     DWORD required_access = volume_access_from_location(location);
+#endif /* STAGING_CSMT */
     unsigned int sub_resource_idx = volume->texture_level;
     struct wined3d_texture *texture = volume->container;
     struct wined3d_texture_sub_resource *sub_resource;
@@ -179,6 +183,7 @@ BOOL wined3d_volume_load_location(struct wined3d_volume *volume,
     TRACE("Volume %p, loading %s, have %s.\n", volume, wined3d_debug_location(location),
         wined3d_debug_location(sub_resource->locations));
 
+#if !defined(STAGING_CSMT)
     if ((sub_resource->locations & location) == location)
     {
         TRACE("Location(s) already up to date.\n");
@@ -192,9 +197,11 @@ BOOL wined3d_volume_load_location(struct wined3d_volume *volume,
         return FALSE;
     }
 
+#endif /* STAGING_CSMT */
     if (!wined3d_texture_prepare_location(texture, sub_resource_idx, context, location))
         return FALSE;
 
+#if !defined(STAGING_CSMT)
     if (sub_resource->locations & WINED3D_LOCATION_DISCARDED)
     {
         TRACE("Volume previously discarded, nothing to do.\n");
@@ -203,6 +210,7 @@ BOOL wined3d_volume_load_location(struct wined3d_volume *volume,
         goto done;
     }
 
+#endif /* STAGING_CSMT */
     switch (location)
     {
         case WINED3D_LOCATION_TEXTURE_RGB:
@@ -217,7 +225,11 @@ BOOL wined3d_volume_load_location(struct wined3d_volume *volume,
             }
             else if (sub_resource->locations & WINED3D_LOCATION_BUFFER)
             {
+#if !defined(STAGING_CSMT)
                 struct wined3d_const_bo_address data = {sub_resource->buffer_object, NULL};
+#else  /* STAGING_CSMT */
+                struct wined3d_const_bo_address data = {sub_resource->buffer->name, NULL};
+#endif /* STAGING_CSMT */
                 wined3d_texture_bind_and_dirtify(texture, context,
                         location == WINED3D_LOCATION_TEXTURE_SRGB);
                 wined3d_volume_upload_data(texture, sub_resource_idx, context, &data);
@@ -262,7 +274,11 @@ BOOL wined3d_volume_load_location(struct wined3d_volume *volume,
         case WINED3D_LOCATION_BUFFER:
             if (sub_resource->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
             {
+#if !defined(STAGING_CSMT)
                 struct wined3d_bo_address data = {sub_resource->buffer_object, NULL};
+#else  /* STAGING_CSMT */
+                struct wined3d_bo_address data = {sub_resource->buffer->name, NULL};
+#endif /* STAGING_CSMT */
 
                 if (sub_resource->locations & WINED3D_LOCATION_TEXTURE_RGB)
                     wined3d_texture_bind_and_dirtify(texture, context, FALSE);
@@ -285,7 +301,9 @@ BOOL wined3d_volume_load_location(struct wined3d_volume *volume,
             return FALSE;
     }
 
+#if !defined(STAGING_CSMT)
 done:
+#endif /* STAGING_CSMT */
     wined3d_texture_validate_location(texture, sub_resource_idx, location);
 
     return TRUE;
diff --git a/dlls/wined3d/wined3d_main.c b/dlls/wined3d/wined3d_main.c
--- a/dlls/wined3d/wined3d_main.c
+++ b/dlls/wined3d/wined3d_main.c
@@ -91,6 +91,9 @@ struct wined3d_settings wined3d_settings =
     ~0U,            /* No PS shader model limit by default. */
     ~0u,            /* No CS shader model limit by default. */
     FALSE,          /* 3D support enabled by default. */
+#if defined(STAGING_CSMT)
+    TRUE,           /* Multithreaded CS by default. */
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d * CDECL wined3d_create(DWORD flags)
@@ -334,7 +337,20 @@ static BOOL wined3d_dll_init(HINSTANCE hInstDLL)
             TRACE("Disabling 3D support.\n");
             wined3d_settings.no_3d = TRUE;
         }
+#if !defined(STAGING_CSMT)
     }
+#else  /* STAGING_CSMT */
+        if (!get_config_key(hkey, appkey, "CSMT", buffer, size)
+                && !strcmp(buffer,"disabled"))
+        {
+            TRACE("Disabling multithreaded command stream.\n");
+            wined3d_settings.cs_multithreaded = FALSE;
+        }
+    }
+
+    FIXME_(winediag)("Experimental wined3d CSMT feature is currently %s.\n",
+        wined3d_settings.cs_multithreaded ? "enabled" : "disabled");
+#endif /* STAGING_CSMT */
 
     if (appkey) RegCloseKey( appkey );
     if (hkey) RegCloseKey( hkey );
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -31,6 +31,9 @@
 #define WINE_GLAPI
 #endif
 
+#if defined(STAGING_CSMT)
+#include <assert.h>
+#endif /* STAGING_CSMT */
 #include <stdarg.h>
 #include <math.h>
 #include <limits.h>
@@ -310,6 +313,9 @@ struct wined3d_settings
     unsigned int max_sm_ps;
     unsigned int max_sm_cs;
     BOOL no_3d;
+#if defined(STAGING_CSMT)
+    BOOL cs_multithreaded;
+#endif /* STAGING_CSMT */
 };
 
 extern struct wined3d_settings wined3d_settings DECLSPEC_HIDDEN;
@@ -1380,7 +1386,12 @@ enum wined3d_query_state
 struct wined3d_query_ops
 {
     HRESULT (*query_get_data)(struct wined3d_query *query, void *data, DWORD data_size, DWORD flags);
+#if !defined(STAGING_CSMT)
     HRESULT (*query_issue)(struct wined3d_query *query, DWORD flags);
+#else  /* STAGING_CSMT */
+    BOOL (*query_poll)(struct wined3d_query *query);
+    BOOL (*query_issue)(struct wined3d_query *query, DWORD flags);
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_query
@@ -1393,6 +1404,10 @@ struct wined3d_query
     enum wined3d_query_type type;
     DWORD data_size;
     const struct wined3d_query_ops *query_ops;
+#if defined(STAGING_CSMT)
+    LONG counter_main, counter_retrieved;
+    struct list poll_list_entry;
+#endif /* STAGING_CSMT */
 };
 
 union wined3d_gl_query_object
@@ -1432,6 +1447,10 @@ struct wined3d_occlusion_query
     struct list entry;
     GLuint id;
     struct wined3d_context *context;
+#if defined(STAGING_CSMT)
+    DWORD samples;
+    BOOL started;
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_timestamp_query
@@ -1441,11 +1460,46 @@ struct wined3d_timestamp_query
     struct list entry;
     GLuint id;
     struct wined3d_context *context;
+#if defined(STAGING_CSMT)
+    UINT64 timestamp;
+#endif /* STAGING_CSMT */
 };
 
 void context_alloc_timestamp_query(struct wined3d_context *context, struct wined3d_timestamp_query *query) DECLSPEC_HIDDEN;
 void context_free_timestamp_query(struct wined3d_timestamp_query *query) DECLSPEC_HIDDEN;
 
+#if defined(STAGING_CSMT)
+struct wined3d_fb_state
+{
+    struct wined3d_rendertarget_view **render_targets;
+    struct wined3d_rendertarget_view *depth_stencil;
+    UINT rt_size;
+};
+
+static inline BOOL wined3d_fb_equal(const struct wined3d_fb_state *fb1, const struct wined3d_fb_state *fb2)
+{
+    UINT i;
+
+    if (fb1->depth_stencil != fb2->depth_stencil)
+        return FALSE;
+    if (fb1->rt_size != fb2->rt_size)
+        return FALSE;
+    for (i = 0; i < fb1->rt_size; i++)
+        if (fb1->render_targets[i] != fb2->render_targets[i])
+            return FALSE;
+    return TRUE;
+}
+
+static inline void wined3d_fb_copy(struct wined3d_fb_state *dst, const struct wined3d_fb_state *src)
+{
+    UINT i;
+
+    dst->depth_stencil = src->depth_stencil;
+    for (i = 0; i < min(dst->rt_size, src->rt_size); i++)
+        dst->render_targets[i] = src->render_targets[i];
+}
+
+#endif /* STAGING_CSMT */
 struct wined3d_context
 {
     const struct wined3d_gl_info *gl_info;
@@ -1460,6 +1514,9 @@ struct wined3d_context
     DWORD                   dirtyArray[STATE_HIGHEST + 1]; /* Won't get bigger than that, a state is never marked dirty 2 times */
     DWORD                   numDirtyEntries;
     DWORD isStateDirty[STATE_HIGHEST / (sizeof(DWORD) * CHAR_BIT) + 1]; /* Bitmap to find out quickly if a state is dirty */
+#if defined(STAGING_CSMT)
+    struct wined3d_fb_state current_fb;
+#endif /* STAGING_CSMT */
 
     struct wined3d_swapchain *swapchain;
     struct
@@ -1568,12 +1625,14 @@ struct wined3d_context
     GLuint                  dummy_arbfp_prog;
 };
 
+#if !defined(STAGING_CSMT)
 struct wined3d_fb_state
 {
     struct wined3d_rendertarget_view **render_targets;
     struct wined3d_rendertarget_view *depth_stencil;
 };
 
+#endif /* STAGING_CSMT */
 typedef void (*APPLYSTATEFUNC)(struct wined3d_context *ctx, const struct wined3d_state *state, DWORD state_id);
 
 struct StateEntry
@@ -1712,7 +1771,11 @@ void context_alloc_event_query(struct wined3d_context *context,
 void context_alloc_occlusion_query(struct wined3d_context *context,
         struct wined3d_occlusion_query *query) DECLSPEC_HIDDEN;
 void context_apply_blit_state(struct wined3d_context *context, const struct wined3d_device *device) DECLSPEC_HIDDEN;
+#if !defined(STAGING_CSMT)
 BOOL context_apply_clear_state(struct wined3d_context *context, const struct wined3d_state *state,
+#else  /* STAGING_CSMT */
+BOOL context_apply_clear_state(struct wined3d_context *context,
+#endif /* STAGING_CSMT */
         UINT rt_count, const struct wined3d_fb_state *fb) DECLSPEC_HIDDEN;
 BOOL context_apply_draw_state(struct wined3d_context *context,
         const struct wined3d_device *device, const struct wined3d_state *state) DECLSPEC_HIDDEN;
@@ -2338,7 +2401,11 @@ struct wined3d_stream_state
 struct wined3d_state
 {
     DWORD flags;
+#if !defined(STAGING_CSMT)
     const struct wined3d_fb_state *fb;
+#else  /* STAGING_CSMT */
+    struct wined3d_fb_state fb;
+#endif /* STAGING_CSMT */
 
     struct wined3d_vertex_declaration *vertex_declaration;
     struct wined3d_stream_output stream_output[MAX_STREAM_OUT];
@@ -2384,6 +2451,16 @@ struct wined3d_state
     DWORD render_states[WINEHIGHEST_RENDER_STATE + 1];
 };
 
+#if defined(STAGING_CSMT)
+struct wined3d_gl_bo
+{
+    GLuint name;
+    GLenum usage;
+    GLenum type_hint;
+    UINT size;
+};
+
+#endif /* STAGING_CSMT */
 #define WINED3D_UNMAPPED_STAGE ~0U
 
 /* Multithreaded flag. Removed from the public header to signal that
@@ -2436,16 +2513,21 @@ struct wined3d_device
     struct wined3d_rendertarget_view *back_buffer_view;
     struct wined3d_swapchain **swapchains;
     UINT swapchain_count;
+#if defined(STAGING_CSMT)
+    struct wined3d_rendertarget_view *auto_depth_stencil_view;
+#endif /* STAGING_CSMT */
 
     struct list             resources; /* a linked list to track resources created by the device */
     struct list             shaders;   /* a linked list to track shaders (pixel and vertex)      */
     struct wine_rb_tree samplers;
 
+#if !defined(STAGING_CSMT)
     /* Render Target Support */
     struct wined3d_fb_state fb;
     struct wined3d_surface *onscreen_depth_stencil;
     struct wined3d_rendertarget_view *auto_depth_stencil_view;
 
+#endif /* STAGING_CSMT */
     /* For rendering to a texture using glCopyTexImage */
     GLuint                  depth_blt_texture;
 
@@ -2492,9 +2574,23 @@ LRESULT device_process_message(struct wined3d_device *device, HWND window, BOOL
         UINT message, WPARAM wparam, LPARAM lparam, WNDPROC proc) DECLSPEC_HIDDEN;
 void device_resource_add(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void device_resource_released(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+#if !defined(STAGING_CSMT)
 void device_switch_onscreen_ds(struct wined3d_device *device, struct wined3d_context *context,
         struct wined3d_surface *depth_stencil) DECLSPEC_HIDDEN;
 void device_invalidate_state(const struct wined3d_device *device, DWORD state) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+void device_invalidate_state(const struct wined3d_device *device, DWORD state) DECLSPEC_HIDDEN;
+void device_invalidate_shader_constants(const struct wined3d_device *device, DWORD mask) DECLSPEC_HIDDEN;
+void device_exec_update_texture(struct wined3d_context *context, struct wined3d_texture *src_texture,
+        struct wined3d_texture *dst_texture) DECLSPEC_HIDDEN;
+struct wined3d_gl_bo *wined3d_device_get_bo(struct wined3d_device *device, UINT size, GLenum gl_usage,
+        GLenum type_hint, struct wined3d_context *context) DECLSPEC_HIDDEN;
+void wined3d_device_release_bo(struct wined3d_device *device, struct wined3d_gl_bo *bo,
+        const struct wined3d_context *context) DECLSPEC_HIDDEN;
+void device_create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context) DECLSPEC_HIDDEN;
+void device_delete_opengl_contexts_cs(struct wined3d_device *device,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 static inline BOOL isStateDirty(const struct wined3d_context *context, DWORD state)
 {
@@ -2538,7 +2634,11 @@ struct wined3d_resource
     UINT depth;
     UINT size;
     DWORD priority;
+#if !defined(STAGING_CSMT)
     void *heap_memory;
+#else  /* STAGING_CSMT */
+    void *heap_memory, *map_heap_memory;
+#endif /* STAGING_CSMT */
     struct list resource_list_entry;
     LONG access_count;
 
@@ -2645,6 +2745,9 @@ struct wined3d_texture
     DWORD flags;
     GLenum target;
     DWORD update_map_binding;
+#if defined(STAGING_CSMT)
+    HRESULT dc_hr;
+#endif /* STAGING_CSMT */
 
     GLuint rb_multisample;
     GLuint rb_resolved;
@@ -2682,7 +2785,12 @@ struct wined3d_texture
 
         unsigned int map_count;
         DWORD locations;
+#if !defined(STAGING_CSMT)
         GLuint buffer_object;
+#else  /* STAGING_CSMT */
+        struct wined3d_gl_bo *buffer, *map_buffer;
+        BOOL unmap_dirtify;
+#endif /* STAGING_CSMT */
     } sub_resources[1];
 };
 
@@ -2733,11 +2841,23 @@ void wined3d_texture_bind(struct wined3d_texture *texture,
         struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
 void wined3d_texture_bind_and_dirtify(struct wined3d_texture *texture,
         struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
+#if !defined(STAGING_CSMT)
 BOOL wined3d_texture_check_block_align(const struct wined3d_texture *texture,
         unsigned int level, const struct wined3d_box *box) DECLSPEC_HIDDEN;
 GLenum wined3d_texture_get_gl_buffer(const struct wined3d_texture *texture) DECLSPEC_HIDDEN;
 void wined3d_texture_get_memory(struct wined3d_texture *texture, unsigned int sub_resource_idx,
         struct wined3d_bo_address *data, DWORD locations) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+void wined3d_texture_changed(struct wined3d_texture *texture,
+        unsigned int sub_resource_idx, struct wined3d_gl_bo *swap_buffer,
+        void *swap_heap_memory) DECLSPEC_HIDDEN;
+BOOL wined3d_texture_check_block_align(const struct wined3d_texture *texture,
+        unsigned int level, const struct wined3d_box *box) DECLSPEC_HIDDEN;
+void wined3d_texture_get_dc_cs(struct wined3d_texture *texture, unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
+GLenum wined3d_texture_get_gl_buffer(const struct wined3d_texture *texture) DECLSPEC_HIDDEN;
+void wined3d_texture_get_memory(struct wined3d_texture *texture, unsigned int sub_resource_idx,
+        struct wined3d_bo_address *data, DWORD locations, BOOL map) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 struct wined3d_texture_sub_resource *wined3d_texture_get_sub_resource(struct wined3d_texture *texture,
         unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
 void wined3d_texture_invalidate_location(struct wined3d_texture *texture,
@@ -2748,13 +2868,28 @@ void *wined3d_texture_map_bo_address(const struct wined3d_bo_address *data, size
         const struct wined3d_gl_info *gl_info, GLenum binding, DWORD flags) DECLSPEC_HIDDEN;
 BOOL wined3d_texture_prepare_location(struct wined3d_texture *texture, unsigned int sub_resource_idx,
         struct wined3d_context *context, DWORD location) DECLSPEC_HIDDEN;
+#if !defined(STAGING_CSMT)
+void wined3d_texture_prepare_texture(struct wined3d_texture *texture,
+        struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+BOOL wined3d_texture_load_location(struct wined3d_texture *texture, unsigned int sub_resource_idx,
+        struct wined3d_context *context, DWORD location);
+void *wined3d_texture_map_internal(struct wined3d_texture *texture, unsigned int sub_resource_idx,
+        DWORD flags) DECLSPEC_HIDDEN;
 void wined3d_texture_prepare_texture(struct wined3d_texture *texture,
         struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
+void wined3d_texture_release_dc_cs(struct wined3d_texture *texture,
+        unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void wined3d_texture_set_map_binding(struct wined3d_texture *texture, DWORD map_binding) DECLSPEC_HIDDEN;
 void wined3d_texture_set_swapchain(struct wined3d_texture *texture,
         struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 void wined3d_texture_unmap_bo_address(const struct wined3d_bo_address *data,
         const struct wined3d_gl_info *gl_info, GLenum binding) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+void wined3d_texture_unmap_internal(struct wined3d_texture *texture,
+        unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void wined3d_texture_validate_location(struct wined3d_texture *texture,
         unsigned int sub_resource_idx, DWORD location) DECLSPEC_HIDDEN;
 
@@ -2872,7 +3007,11 @@ void surface_get_drawable_size(const struct wined3d_surface *surface, const stru
         unsigned int *width, unsigned int *height) DECLSPEC_HIDDEN;
 void surface_load_fb_texture(struct wined3d_surface *surface, BOOL srgb,
         struct wined3d_context *context) DECLSPEC_HIDDEN;
+#if !defined(STAGING_CSMT)
 HRESULT surface_load_location(struct wined3d_surface *surface,
+#else  /* STAGING_CSMT */
+void surface_load_location(struct wined3d_surface *surface,
+#endif /* STAGING_CSMT */
         struct wined3d_context *context, DWORD location) DECLSPEC_HIDDEN;
 void surface_modify_ds_location(struct wined3d_surface *surface, DWORD location, UINT w, UINT h) DECLSPEC_HIDDEN;
 void surface_set_compatible_renderbuffer(struct wined3d_surface *surface,
@@ -2883,6 +3022,11 @@ HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const P
 void wined3d_surface_upload_data(struct wined3d_surface *surface, const struct wined3d_gl_info *gl_info,
         const struct wined3d_format *format, const RECT *src_rect, UINT src_pitch, const POINT *dst_point,
         BOOL srgb, const struct wined3d_const_bo_address *data) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect_in,
+        struct wined3d_surface *src_surface, const RECT *src_rect_in, DWORD flags,
+        const struct wined3d_blt_fx *fx, enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 void draw_textured_quad(const struct wined3d_surface *src_surface, struct wined3d_context *context,
         const RECT *src_rect, const RECT *dst_rect, enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
@@ -2897,6 +3041,12 @@ struct wined3d_sampler
     GLuint name;
 };
 
+#if defined(STAGING_CSMT)
+HRESULT wined3d_sampler_create_from_cs(struct wined3d_device *device, const struct wined3d_sampler_desc *desc,
+        void *parent, struct wined3d_sampler **sampler, BOOL from_cs) DECLSPEC_HIDDEN;
+void wined3d_sampler_init(struct wined3d_sampler *sampler) DECLSPEC_HIDDEN;
+
+#endif /* STAGING_CSMT */
 struct wined3d_vertex_declaration_element
 {
     const struct wined3d_format *format;
@@ -2992,6 +3142,7 @@ struct wined3d_stateblock
 void stateblock_init_contained_states(struct wined3d_stateblock *stateblock) DECLSPEC_HIDDEN;
 
 void state_cleanup(struct wined3d_state *state) DECLSPEC_HIDDEN;
+#if !defined(STAGING_CSMT)
 void state_init(struct wined3d_state *state, struct wined3d_fb_state *fb,
         const struct wined3d_gl_info *gl_info, const struct wined3d_d3d_info *d3d_info,
         DWORD flags) DECLSPEC_HIDDEN;
@@ -3005,29 +3156,74 @@ enum wined3d_push_constants
     WINED3D_PUSH_CONSTANTS_PS_I,
     WINED3D_PUSH_CONSTANTS_VS_B,
     WINED3D_PUSH_CONSTANTS_PS_B,
+#else  /* STAGING_CSMT */
+HRESULT state_init(struct wined3d_state *state, const struct wined3d_gl_info *gl_info,
+        const struct wined3d_d3d_info *d3d_info, DWORD flags) DECLSPEC_HIDDEN;
+void state_unbind_resources(struct wined3d_state *state) DECLSPEC_HIDDEN;
+
+struct wined3d_cs_list
+{
+    struct list blocks;
+};
+
+#define WINED3D_CS_QUEUE_SIZE 0x100000
+#define WINED3D_CS_SPIN_COUNT 10000000
+
+struct wined3d_cs_queue
+{
+    LONG head, tail;
+    BYTE data[WINED3D_CS_QUEUE_SIZE];
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_cs_ops
 {
     void *(*require_space)(struct wined3d_cs *cs, size_t size);
+#if !defined(STAGING_CSMT)
     void (*submit)(struct wined3d_cs *cs);
     void (*push_constants)(struct wined3d_cs *cs, enum wined3d_push_constants p,
             unsigned int start_idx, unsigned int count, const void *constants);
+#else  /* STAGING_CSMT */
+    void *(*require_space_prio)(struct wined3d_cs *cs, size_t size);
+    void (*submit)(struct wined3d_cs *cs, size_t size);
+    void (*submit_prio)(struct wined3d_cs *cs, size_t size);
+    void (*finish)(struct wined3d_cs *cs);
+    void (*finish_prio)(struct wined3d_cs *cs);
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_cs
 {
     const struct wined3d_cs_ops *ops;
     struct wined3d_device *device;
+#if !defined(STAGING_CSMT)
     struct wined3d_fb_state fb;
     struct wined3d_state state;
 
     size_t data_size;
     void *data;
+#else  /* STAGING_CSMT */
+    struct wined3d_state state;
+    HANDLE thread;
+    DWORD thread_id;
+    struct wined3d_surface *onscreen_depth_stencil;
+
+    struct wined3d_cs_queue queue, prio_queue;
+
+    LONG pending_presents;
+    struct list query_poll_list;
+
+    HANDLE event;
+    BOOL waiting_for_event;
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device) DECLSPEC_HIDDEN;
 void wined3d_cs_destroy(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+void wined3d_cs_switch_onscreen_ds(struct wined3d_cs *cs, struct wined3d_context *context,
+        struct wined3d_surface *depth_stencil) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
         DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil) DECLSPEC_HIDDEN;
@@ -3078,12 +3274,70 @@ void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform
 void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs,
         struct wined3d_vertex_declaration *declaration) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport) DECLSPEC_HIDDEN;
+#if !defined(STAGING_CSMT)
 
 static inline void wined3d_cs_push_constants(struct wined3d_cs *cs, enum wined3d_push_constants p,
         unsigned int start_idx, unsigned int count, const void *constants)
 {
     cs->ops->push_constants(cs, p, start_idx, count, constants);
 }
+#else  /* STAGING_CSMT */
+void wined3d_cs_emit_set_consts_f(struct wined3d_cs *cs, unsigned int start_idx,
+        unsigned int count, const struct wined3d_vec4 *constants, enum wined3d_shader_type type) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_consts_b(struct wined3d_cs *cs, unsigned int start_idx,
+        unsigned int count, const BOOL *constants, enum wined3d_shader_type type) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_consts_i(struct wined3d_cs *cs, unsigned int start_idx,
+        unsigned int count, const struct wined3d_ivec4 *constants, enum wined3d_shader_type type) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_glfinish(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_base_vertex_index(struct wined3d_cs *cs,
+        UINT base_vertex_index) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_primitive_type(struct wined3d_cs *cs,
+        GLenum primitive_type) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_light(struct wined3d_cs *cs, const struct wined3d_light_info *light) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_light_enable(struct wined3d_cs *cs, UINT idx, BOOL enable) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_blt(struct wined3d_cs *cs, struct wined3d_surface *dst_surface,
+        const RECT *dst_rect, struct wined3d_surface *src_surface,
+        const RECT *src_rect, DWORD flags, const struct wined3d_blt_fx *fx,
+        enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_clear_rtv(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view,
+        const RECT *rect, DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil,
+        const struct blit_shader *blitter) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_texture_changed(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx, struct wined3d_gl_bo *swap_buffer,
+        void *swap_heap_memory) DECLSPEC_HIDDEN;
+void *wined3d_cs_emit_texture_map(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx, DWORD flags) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_texture_unmap(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_query_issue(struct wined3d_cs *cs, struct wined3d_query *query,
+        DWORD flags) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_query_get_data(struct wined3d_cs *cs, struct wined3d_query *query, void *data,
+        UINT data_size, DWORD flags, HRESULT *ret) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_texture_preload(struct wined3d_cs *cs, struct wined3d_texture *texture) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_update_texture(struct wined3d_cs *cs, struct wined3d_texture *src,
+        struct wined3d_texture *dst) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_evict_resource(struct wined3d_cs *cs, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_update_sub_resource(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        unsigned int sub_resource_idx, const struct wined3d_box *box, const void *data, unsigned int row_pitch,
+        unsigned int depth_pitch) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_buffer_swap_mem(struct wined3d_cs *cs, struct wined3d_buffer *buffer,
+        BYTE *mem) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_buffer_invalidate_bo_range(struct wined3d_cs *cs,
+        struct wined3d_buffer *buffer, unsigned int offset, unsigned int size) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_buffer_preload(struct wined3d_cs *cs, struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_create_vbo(struct wined3d_cs *cs, struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_sampler_init(struct wined3d_cs *cs, struct wined3d_sampler *sampler) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_get_dc(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_release_dc(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        unsigned int sub_resource_idx) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_create_dummy_textures(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+HRESULT wined3d_cs_emit_create_swapchain_context(struct wined3d_cs *cs,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_delete_opengl_contexts(struct wined3d_cs *cs,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_update_swap_interval(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 /* TODO: Add tests and support for FLOAT16_4 POSITIONT, D3DCOLOR position, other
  * fixed function semantics as D3DCOLOR or FLOAT16 */
@@ -3110,6 +3364,9 @@ struct wined3d_buffer
     GLenum buffer_object_usage;
     GLenum buffer_type_hint;
     DWORD flags;
+#if defined(STAGING_CSMT)
+    BOOL ignore_discard;
+#endif /* STAGING_CSMT */
     void *map_ptr;
 
     struct wined3d_map_range *maps;
@@ -3134,11 +3391,19 @@ void buffer_get_memory(struct wined3d_buffer *buffer, struct wined3d_context *co
 BYTE *buffer_get_sysmem(struct wined3d_buffer *buffer, struct wined3d_context *context) DECLSPEC_HIDDEN;
 void buffer_internal_preload(struct wined3d_buffer *buffer, struct wined3d_context *context,
         const struct wined3d_state *state) DECLSPEC_HIDDEN;
+#if !defined(STAGING_CSMT)
 void buffer_mark_used(struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 HRESULT wined3d_buffer_copy(struct wined3d_buffer *dst_buffer, unsigned int dst_offset,
         struct wined3d_buffer *src_buffer, unsigned int src_offset, unsigned int size) DECLSPEC_HIDDEN;
 HRESULT wined3d_buffer_upload_data(struct wined3d_buffer *buffer,
         const struct wined3d_box *box, const void *data) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+void buffer_invalidate_bo_range(struct wined3d_buffer *buffer, unsigned int offset, unsigned int size) DECLSPEC_HIDDEN;
+void buffer_swap_mem(struct wined3d_buffer *buffer, BYTE *mem) DECLSPEC_HIDDEN;
+void buffer_create_buffer_object(struct wined3d_buffer *This,
+        struct wined3d_context *context) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 struct wined3d_rendertarget_view
 {
@@ -3200,7 +3465,12 @@ struct wined3d_unordered_access_view
 struct wined3d_swapchain_ops
 {
     void (*swapchain_present)(struct wined3d_swapchain *swapchain,
+#if !defined(STAGING_CSMT)
             const RECT *src_rect, const RECT *dst_rect, DWORD flags);
+#else  /* STAGING_CSMT */
+            const RECT *src_rect, const RECT *dst_rect, DWORD flags,
+            struct wined3d_rendertarget_view *depth_stencil);
+#endif /* STAGING_CSMT */
     void (*swapchain_frontbuffer_updated)(struct wined3d_swapchain *swapchain);
 };
 
@@ -3236,6 +3506,10 @@ struct wined3d_swapchain
 
 void wined3d_swapchain_activate(struct wined3d_swapchain *swapchain, BOOL activate) DECLSPEC_HIDDEN;
 struct wined3d_context *swapchain_get_context(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+HRESULT swapchain_create_context_cs(struct wined3d_device *device,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void swapchain_destroy_contexts(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 HDC swapchain_get_backup_dc(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 void swapchain_update_draw_bindings(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
